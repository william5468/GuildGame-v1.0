/* === ローディング画面用プリロード機能 === */
let loadedCount = 0;

const assetsToLoad = [
    "Images/Guild_bg.jpg",
    "Images/Shop_bg.jpg",
    "Images/Character_bg.jpg",
    "Images/npc_bg.jpg",
    "Images/Street.jpg",
    "Images/Card.png",
    "Images/カイト.png",
    "Images/ルナ.png",
    "Images/main_char.png",
    "Images/STR_M.png",
    "Images/STR_F.png",
    "Images/WIS_F.png",
    "Images/DEX_M.png",
    "Images/DEX_F.png",
    "Images/LUC_M.png",
    "Images/LUC_F.png",
    "bgm.mp3",
    "yume.mp3",
    "battle.mp3",
    "STR_Attack.mp3",
    "WIS_Attack.mp3"
    // 必要に応じて他の画像・音声パスを追加
];

const totalAssets = assetsToLoad.length;

function updateProgress() {
    const percent = Math.round((loadedCount / totalAssets) * 100);
    const progressEl = document.getElementById('loadProgress');
    if (progressEl) {
        progressEl.textContent = percent + '%';
    }
    if (loadedCount >= totalAssets) {
        document.querySelector('.loader').style.display = 'none';
        const readyBtn = document.getElementById('readyBtn');
        if (readyBtn) readyBtn.style.display = 'block';
    }
}

function preloadAssets() {
    if (totalAssets === 0) {
        updateProgress();
        return;
    }
    assetsToLoad.forEach(url => {
        if (url.match(/\.(mp3|ogg|wav)$/i)) {
            const audio = new Audio();
            audio.src = url;
            audio.addEventListener('canplaythrough', () => {
                loadedCount++;
                updateProgress();
            });
            audio.addEventListener('error', () => {
                loadedCount++;
                updateProgress();
            });
            audio.load();
        } else {
            const img = new Image();
            img.src = url;
            img.addEventListener('load', () => {
                loadedCount++;
                updateProgress();
            });
            img.addEventListener('error', () => {
                loadedCount++;
                updateProgress();
            });
        }
    });
}

function startGame() {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.style.display = 'none';
}

/* ページ読み込み後すぐにプリロード開始 */
preloadAssets();

const strSound = new Audio('STR_Attack.mp3');
const wisSound = new Audio('WIS_Attack.mp3');
let currentCharIndex = 0;
let selectedMix1 = null;
let selectedMix2 = null;
let currentBattle = null;
let currentSelectingAdvId = null;
let draggedAdvId = null;  // ← Add this line
let currentNPCIndex = 0;
let currentQuestIndex = 0;

let currentFacility = null;  // null = 街の通り、それ以外 = 選択中の施設

// クエスト完了ダイアログを3者会話に拡張（Fランクのみ）
// 構造: QuestCompletionDialogue[questType][questStoryindex] = 対話シーケンスの配列
// 各対話: {speaker: "文字列", text: "セリフ"}
// speaker例:
// - "冒険者"     : クエストを受けた冒険者（名前は入れず固定。必要なら後でreplace拡張可能）
// - "ギルドマスター" : プレイヤー（あなた）
// - 依頼主       : クエスト内容に合わせて具体的な役職/人物（自然さを出すため）

const QuestCompletionDialogue = [
    // 0: STR - kill quests
    {
        'F': [
            // 0: スライム5匹討伐（依頼主: 農夫）
            [
                {speaker: "冒険者", text: "村周辺のスライム5匹をすべて倒してきました。……正直、跳ねまくって疲れました。"},
                {speaker: "カイト", text: "ははっ！スライムごときでヘトヘトかよ？俺なら一撃でゼリーみたいに潰してたぜ！"},
                {speaker: "ギルドマスター", text: "カイト、黙ってろ。依頼主の農夫が待ってるぞ。"},
                {speaker: "農夫", text: "スライムを5匹とも倒してくれたんだね！作物が溶けずに済んでほんと助かるよ……って、ゼリーって食べ物じゃないよね？怖い怖い！ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトを連れてったらスライム汁まみれになるかもな。"}
            ],
            // 1: 巨大ネズミ退治（依頼主: 酒場主人）
            [
                {speaker: "冒険者", text: "酒場の地下室の巨大ネズミを全部退治しました。……噛まれそうでヒヤヒヤしました。"},
                {speaker: "カイト", text: "巨大ネズミ！？でかかったんだろ？俺も行きたかったな～、剣でぶった斬ってやりたかったぜ！"},
                {speaker: "ギルドマスター", text: "カイト、お前がいると酒場が血の海になる。酒場主人に報告だ。"},
                {speaker: "酒場主人", text: "巨大ネズミを全部退治してくれたか！これで地下室がまた使えるよ。一杯おごるぜ……って、血の海は勘弁な！本当に感謝だ！"},
                {speaker: "ギルドマスター", text: "これが報酬だ。カイト、次はネズミ狩りお前に行かせてやるからな。"}
            ],
            // 2: 野犬3匹討伐（依頼主: 農夫）
            [
                {speaker: "冒険者", text: "農場を襲っていた野犬3匹を倒してきました。家畜は無事です。"},
                {speaker: "カイト", text: "野犬か！いいねえ、追いかけっこ楽しそうだぜ！次は俺に任せろよ！"},
                {speaker: "ギルドマスター", text: "お前が行ったら家畜まで追いかけそうだ。農夫に伝えてやろう。"},
                {speaker: "農夫", text: "野犬3匹を倒してくれて家畜が無事だよ！みんな感謝してる……って、追いかけっこって遊びじゃないよね？ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトは次回お留守番な。"}
            ]
        ],
        'F+': [
            // 0: ゴブリン8匹討伐（依頼主: 街道の衛兵）
            [
                {speaker: "冒険者", text: "街道で待ち伏せしていたゴブリン8匹をすべて討伐しました。……結構しつこくて疲れましたよ。"},
                {speaker: "カイト", text: "ゴブリン8匹！？いいじゃん、俺なら10匹でも余裕でぶった斬ってたぜ！次は絶対連れてけよ！"},
                {speaker: "ギルドマスター", text: "カイト、興奮しすぎ。衛兵に報告だ。"},
                {speaker: "衛兵", text: "ゴブリンを8匹も倒してくれたのか！これで街道が安全になったよ。……って、10匹は自慢しすぎだろ？ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。カイト、次は本当に連れてくから準備しとけ。"}
            ],
            // 1: 山賊5人排除（依頼主: 商人）
            [
                {speaker: "冒険者", text: "森に隠れていた山賊5人を排除しました。……人間相手はちょっと緊張しました。"},
                {speaker: "カイト", text: "山賊！？人間だろうが関係ねえ、俺の剣で一掃してやるぜ！次は俺の出番だな！"},
                {speaker: "ルナ", text: "カイト、ちょっと怖いわよ……でも確かに厄介よね。"},
                {speaker: "ギルドマスター", text: "二人とも静かに。商人に報告しよう。"},
                {speaker: "商人", text: "山賊5人を排除してくれたんだ！これで商売が安心してできるよ。本当に助かった、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイト、次は本当に怖がらせないでくれよ。"}
            ],
            // 2: 巨大蜘蛛1匹討伐（依頼主: 村人）
            [
                {speaker: "冒険者", text: "洞窟に潜む巨大蜘蛛を倒してきました。……糸が絡まって最悪でした。"},
                {speaker: "カイト", text: "巨大蜘蛛！？でかくて強そうだな！俺の剣で串刺しにしてやりたかったぜ！"},
                {speaker: "ルナ", text: "蜘蛛の糸は魔法素材になるのに……もったいないわね。"},
                {speaker: "ギルドマスター", text: "ルナ、素材は後で考えろ。村人に報告だ。"},
                {speaker: "村人", text: "巨大蜘蛛を倒してくれたんだ！もう洞窟が怖くなくなったよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は蜘蛛の糸回収も頼むか？"}
            ]
        ],
        'D': [
            // 0: オークの群れ10体（依頼主: 村長）
            [
                {speaker: "冒険者", text: "村を脅かしていたオークの群れ10体を倒してきました。……臭いがキツくて鼻が曲がりそうです。"},
                {speaker: "カイト", text: "オーク10体！？最高じゃん！俺の剣が鳴ってたぜ！次は俺を連れてけよ！"},
                {speaker: "ルナ", text: "カイト、オークの臭いは魔法でも消せないわよ……。"},
                {speaker: "ギルドマスター", text: "二人とも黙って。村長に報告だ。"},
                {speaker: "村長", text: "オークの群れを壊滅させてくれたのか！村が救われたよ……って、臭いは我慢するから大丈夫！本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトも連れてったら村中がオーク臭になるかもな。"}
            ],
            // 1: トロル1体（依頼主: 橋の番人）
            [
                {speaker: "冒険者", text: "橋を占拠していたトロルを討伐しました。……再生が早くて斬り甲斐ありました。"},
                {speaker: "カイト", text: "トロル！？再生する奴か！俺なら火で焼き払ってたぜ！次は俺の番だ！"},
                {speaker: "ギルドマスター", text: "カイト、火を使ったら橋も燃える。番人に報告だ。"},
                {speaker: "橋の番人", text: "トロルを倒してくれたのか！これで橋が安全になったよ……って、火は勘弁してくれ！ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は火を使わない方法でな。"}
            ],
            // 2: 狼王とその群れ（依頼主: ハンター）
            [
                {speaker: "冒険者", text: "森の奥にいる狼王とその群れを狩ってきました。……遠吠えが耳に残ってます。"},
                {speaker: "カイト", text: "狼王！？かっこいい！俺も群れと一緒に戦いたかったぜ！"},
                {speaker: "ルナ", text: "カイト、狼に噛まれたら大変よ。"},
                {speaker: "ギルドマスター", text: "二人とも静かに。ハンターに報告しよう。"},
                {speaker: "ハンター", text: "狼王と群れを狩ってくれたのか！これで森が平和になったよ。本当に感謝だ、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトを連れてったら狼の遠吠え合唱になるかもな。"}
            ]
        ],
        'D+': [
            // 0: 盗賊15人（依頼主: 貴族）
            [
                {speaker: "冒険者", text: "盗賊団の拠点を襲撃し、15人を倒してきました。……隠し金庫まで見つけましたよ。"},
                {speaker: "カイト", text: "盗賊15人！？大乱闘じゃん！俺なら全員まとめてぶった斬ってたぜ！"},
                {speaker: "ルナ", text: "カイト、隠し金庫は私が見つけたいわ～。"},
                {speaker: "ギルドマスター", text: "二人とも欲が出てるな。貴族に報告だ。"},
                {speaker: "貴族", text: "盗賊15人を倒してくれたのか！領地が安全になったよ……金庫はもちろん没収ね！ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。隠し金庫は貴族のおかげで空っぽだ。"}
            ],
            // 1: ミノタウロス（依頼主: 迷宮の管理者）
            [
                {speaker: "冒険者", text: "古代迷宮のミノタウロスを倒してきました。……角が危なかったです。"},
                {speaker: "カイト", text: "ミノタウロス！？角で突き刺す奴か！俺の剣で角をへし折ってやりたかったぜ！"},
                {speaker: "ルナ", text: "角は良い素材になるのに……もったいないわ。"},
                {speaker: "ギルドマスター", text: "ルナ、素材は後で。管理者に報告だ。"},
                {speaker: "迷宮管理者", text: "ミノタウロスを倒してくれたのか！迷宮がまた探索可能になったよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は角を回収してこい。"}
            ],
            // 2: ワイバーン1匹（依頼主: 山村の長老）
            [
                {speaker: "冒険者", text: "山に巣食うワイバーンを討伐しました。……空を飛ばれて苦戦しました。"},
                {speaker: "カイト", text: "ワイバーン！？空飛ぶドラゴンみたいな奴か！俺なら飛びついて首チョンパだぜ！"},
                {speaker: "ルナ", text: "カイト、落ちたら死ぬわよ……。"},
                {speaker: "ギルドマスター", text: "二人とも現実を見ろ。長老に報告だ。"},
                {speaker: "山村長老", text: "ワイバーンを倒してくれたのか！山が平和になったよ。本当に助かった、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトが落ちないよう祈っとく。"}
            ]
        ],
        'C': [
            // 0: オーク戦士20体（依頼主: 要塞司令官）
            [
                {speaker: "冒険者", text: "オーク部族の戦士20体を壊滅させました。……斧が重くて肩が痛いです。"},
                {speaker: "カイト", text: "オーク戦士20体！？最高の大乱戦じゃん！俺の剣が血に染まってたはずだぜ！"},
                {speaker: "ルナ", text: "カイト、血まみれは嫌よ……。"},
                {speaker: "ギルドマスター", text: "二人とも騒がしい。要塞司令官に報告だ。"},
                {speaker: "要塞司令官", text: "オーク戦士20体を壊滅させたのか！前線が持ちこたえられたよ。本当に感謝する、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイト、次は本当に血まみれになるぞ。"}
            ],
            // 1: サイクロプス1体（依頼主: 鉱山主）
            [
                {speaker: "冒険者", text: "巨人のサイクロプスを倒してきました。……一撃が来たら終わりでした。"},
                {speaker: "カイト", text: "サイクロプス！？でかい奴か！俺なら目ん玉をぶった斬ってたぜ！"},
                {speaker: "ルナ", text: "目玉は魔法素材になるのに……もったいないわね。"},
                {speaker: "ギルドマスター", text: "ルナ、また素材か。鉱山主に報告だ。"},
                {speaker: "鉱山主", text: "サイクロプスを倒してくれたのか！鉱山が再開できるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は目玉持って帰ってこい。"}
            ],
            // 2: グリフォン1匹（依頼主: 王都の貴族）
            [
                {speaker: "冒険者", text: "空を飛ぶグリフォンを討伐しました。……爪が鋭くて怖かったです。"},
                {speaker: "カイト", text: "グリフォン！？羽根生えたライオンか！俺なら飛び乗って首を落としてたぜ！"},
                {speaker: "ルナ", text: "グリフォンの羽根は飛翔魔法に使えるのに……惜しいわ。"},
                {speaker: "ギルドマスター", text: "二人とも欲深いな。王都の貴族に報告だ。"},
                {speaker: "王都貴族", text: "グリフォンを倒してくれたのか！空の脅威が消えたよ。本当に感謝する、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は羽根を回収してルナを飛ばすか？"}
            ]
        ],
'C+': [
        // 0: ヒドラ（依頼主: 沼地守護者）
        [
            {speaker: "冒険者", text: "沼地に潜むヒドラを倒しました。すべての頭を焼却……火傷だらけです。"},
            {speaker: "カイト", text: "ヒドラ！？頭が何個あっても俺の剣で一掃だぜ！次は俺が焼いてやる！"},
            {speaker: "ルナ", text: "頭の再生毒は貴重なのに……全部焼いちゃったの？もったいないわ！"},
            {speaker: "ギルドマスター", text: "二人とも後でな。沼地守護者に報告だ。"},
            {speaker: "沼地守護者", text: "ヒドラを完全に倒してくれたのか！沼が浄化されたよ……火傷は治してやる。本当にありがとう！"},
            {speaker: "ギルドマスター", text: "報酬だ。次はカイトの火遊び禁止な。"}
        ],
        // 1: バンシー（依頼主: 聖職者）
        [
            {speaker: "冒険者", text: "呪われたバンシーを鎮めました。……叫び声が耳に残ってます。"},
            {speaker: "カイト", text: "バンシー！？幽霊か！俺の剣で魂ごとぶった斬ってたぜ！"},
            {speaker: "ルナ", text: "バンシーの叫びは呪文の源……封印して研究したかったわ。"},
            {speaker: "ギルドマスター", text: "ルナ、耳栓しろ。聖職者に報告だ。"},
            {speaker: "聖職者", text: "バンシーを鎮めてくれたのか！静寂が戻ったよ。本当に感謝する、ありがとう！"},
            {speaker: "ギルドマスター", text: "報酬を受け取れ。次は叫び声耐性つけとけ。"}
        ],
        // 2: ケンタウロス軍勢12体（依頼主: 平原の将軍）
        [
            {speaker: "冒険者", text: "ケンタウロスの軍勢12体を撃破しました。……馬の蹄が地響きでした。"},
            {speaker: "カイト", text: "ケンタウロス！？馬半分人間半分か！俺なら騎乗して突撃だぜ！"},
            {speaker: "ギルドマスター", text: "カイト、お前が乗ったら暴走だ。将軍に報告だ。"},
            {speaker: "平原の将軍", text: "軍勢12体を撃破してくれたのか！平原が守られたよ。本当に頼もしい、ありがとう！"},
            {speaker: "ギルドマスター", text: "報酬だ。カイトの騎馬隊は夢のまた夢な。"}
        ]
    ],
    'B': [
        // 0: カルト指導者（依頼主: 聖堂騎士団長）
        [
            {speaker: "冒険者", text: "下級デーモンを召喚するカルト指導者を討伐しました。……儀式の魔力がヤバかったです。"},
            {speaker: "カイト", text: "デーモン召喚！？俺なら儀式中に乱入して全員ぶった斬りだぜ！"},
            {speaker: "ルナ", text: "召喚陣の知識……私の本に追加したいわ！"},
            {speaker: "ギルドマスター", text: "ルナ、悪魔本は作るな。騎士団長に報告だ。"},
            {speaker: "聖堂騎士団長", text: "カルト指導者を討伐してくれたのか！闇の脅威が去ったよ。本当にありがとう！"},
            {speaker: "ギルドマスター", text: "報酬を受け取れ。次は召喚陣で遊ぶなよ。"}
        ],
        // 1: 古代ゴーレム（依頼主: 古代遺跡守護者）
        [
            {speaker: "冒険者", text: "暴走した古代ゴーレムを破壊しました。……岩が硬すぎて武器が欠けました。"},
            {speaker: "カイト", text: "ゴーレム！？俺の剣で粉々にしてたぜ！次は俺だ！"},
            {speaker: "ルナ", text: "ゴーレムの核は魔力源……回収してほしかったわ。"},
            {speaker: "ギルドマスター", text: "ルナ、核爆発するぞ。守護者に報告だ。"},
            {speaker: "古代遺跡守護者", text: "ゴーレムを破壊してくれたのか！遺跡が安全になったよ。本当に感謝する！"},
            {speaker: "ギルドマスター", text: "報酬だ。カイトの剣は修理代出せ。"}
        ],
        // 2: アンデッド軍（依頼主: ネクロマンサー狩りの賞金首）
        [
            {speaker: "冒険者", text: "リッチの墓を守るアンデッド軍を一掃しました。……ゾンビ臭が染みつきました。"},
            {speaker: "カイト", text: "アンデッド軍！？俺なら聖剣で一網打尽だぜ！"},
            {speaker: "ルナ", text: "リッチの墓……禁断の知識が眠ってるのに！"},
            {speaker: "ギルドマスター", text: "ルナ、蘇生しないで。賞金首に報告だ。"},
            {speaker: "賞金首", text: "アンデッド軍を一掃してくれたのか！墓が浄化されたよ。本当にありがとう！"},
            {speaker: "ギルドマスター", text: "報酬だ。風呂入ってこい。"}
        ]
    ],'B+': [
        // 0: ヴァンパイア貴族（依頼主: ヴァンパイアハンター）
        [
            {speaker: "冒険者", text: "ヴァンパイア貴族を倒しました。夜の脅威が……日光で弱ってました。"},
            {speaker: "カイト", text: "ヴァンパイア！？俺なら杭で心臓貫通だぜ！血の海にしてた！"},
            {speaker: "ルナ", text: "貴族の血は永遠の命の秘薬かも……もったいないわ。"},
            {speaker: "ギルドマスター", text: "ルナ、吸血鬼になるな。ハンターに報告だ。"},
            {speaker: "ヴァンパイアハンター", text: "ヴァンパイア貴族を倒してくれたのか！夜が安全になったよ。本当に感謝する！"},
            {speaker: "ギルドマスター", text: "報酬だ。日光浴しとけ。"}
        ],
        // 1: フェニックス（依頼主: 鳳凰の守護者）
        [
            {speaker: "冒険者", text: "再生するフェニックスを狩りました。……灰から何度も蘇って疲れました。"},
            {speaker: "カイト", text: "フェニックス！？燃え上がる鳥か！俺なら炎ごとぶった斬りだぜ！"},
            {speaker: "ルナ", text: "再生の灰は不死の秘薬！全部集めた？"},
            {speaker: "ギルドマスター", text: "ルナ、不死は危ない。守護者に報告だ。"},
            {speaker: "鳳凰守護者", text: "フェニックスを狩ってくれたのか！均衡が保たれたよ。本当にありがとう！"},
            {speaker: "ギルドマスター", text: "報酬だ。灰は燃やしとけ。"}
        ],
        // 2: ビヒーモス（依頼主: 大地の守護者）
        [
            {speaker: "冒険者", text: "大地を揺るがすビヒーモスを討伐しました。……地響きで耳がキーンです。"},
            {speaker: "カイト", text: "ビヒーモス！？でかい獣か！俺なら一騎打ちでぶっ倒してたぜ！"},
            {speaker: "ルナ", text: "ビヒーモスの角や皮は最強の防具素材……回収してほしかったわ！"},
            {speaker: "ギルドマスター", text: "ルナ、重すぎて運べないだろ。大地の守護者に報告だ。"},
            {speaker: "大地の守護者", text: "ビヒーモスを討伐してくれたのか！大地の震えが止まったよ。本当に助かった、ありがとう！"},
            {speaker: "ギルドマスター", text: "報酬だ。次はカイトがビヒーモスに乗って暴れそうだな。"}
        ]
    ],
    'A': [
        // 0: 大デーモン（アークデーモン）（依頼主: 大聖堂総主教）
        [
            {speaker: "冒険者", text: "大デーモン、アークデーモンを地獄から引きずり出し、討伐しました。……その咆哮が、ヴォルガスの名を叫んでいました。"},
            {speaker: "ギルドマスター", text: "アークデーモンがヴォルガスの名を……これは彼の配下か。"},
            {speaker: "大聖堂総主教", text: "アークデーモンを倒してくれたのか……その名を聞いたというなら、深淵の王の復活がより近い。黒い鎧の軍勢は、彼の先兵に過ぎなかったのだ。君たちの故郷が破壊されたのは、封印を弱めるためだったのだろう。本当に感謝する。この勝利が、神の光を保つ。"},
            {speaker: "ギルドマスター", text: "報酬だ。深淵に挑む力を蓄えよう。"}
        ],
        // 1: 古代ドラゴン（依頼主: 竜殺しの伝説の騎士）
        [
            {speaker: "冒険者", text: "古代ドラゴンを討伐しました。……その息吹に、深淵の腐敗が混じっていました。"},
            {speaker: "ギルドマスター", text: "ドラゴンが腐敗……ヴォルガスの影響か。"},
            {speaker: "竜殺しの伝説の騎士", text: "古代ドラゴンを倒してくれたのか……その腐敗は、ヴォルガスの闇が古の竜すら蝕んでいた証だ。あの黒い軍勢は、竜の力を利用しようとしたのかもしれない。君たちの村が最初の標的だったのは、竜の守護がそこにあったからか。本当に感謝する。この剣が、君たちの復讐を支える。"},
            {speaker: "ギルドマスター", text: "報酬だ。竜に負けぬ力を。"}
        ],
        // 2: タイタンの巨人（依頼主: 大地の王）
        [
            {speaker: "冒険者", text: "タイタンの巨人を撃破しました。……その体に、ヴォルガスの刻印が刻まれていました。"},
            {speaker: "ギルドマスター", text: "タイタンにまで刻印……深淵の支配が広がっている。"},
            {speaker: "大地の王", text: "タイタンを倒してくれたのか……刻印は、ヴォルガスが古の巨人を操っていた証だ。あの軍勢は、大地の力を奪うために動いていた。君たちの故郷が破壊されたのは、大地の守りがそこにあったからだろう。本当に感謝する。この大地が、君たちを守る。"},
            {speaker: "ギルドマスター", text: "報酬だ。大地のように揺るがぬ力を。"}
        ]
    ],
    'A+': [
        // 0: ドラゴンの王（依頼主: 竜の盟約者）
        [
            {speaker: "冒険者", text: "ドラゴンの王を討伐しました。……その最期の言葉が、ヴォルガスの復活を喜んでいました。"},
            {speaker: "ギルドマスター", text: "ドラゴンの王がヴォルガスを……完全に支配されていたのか。"},
            {speaker: "竜の盟約者", text: "ドラゴンの王を倒してくれたのか……その喜びは、ヴォルガスの闇が竜の誇りを蝕んだ結果だ。あの黒い軍勢は、竜の軍を呼び寄せるためのものだったのかもしれない。君たちの村が狙われたのは、竜の盟約を断つためか。本当に感謝する。この翼が、君たちを支える。"},
            {speaker: "ギルドマスター", text: "報酬だ。王に挑む力を。"}
        ],
        // 1: リッチキングと不死軍（依頼主: 不死狩りの聖者）
        [
            {speaker: "冒険者", text: "リッチキングとその不死軍を壊滅させました。……王の魂が、ヴォルガスの名を呟いていました。"},
            {speaker: "ギルドマスター", text: "リッチキングがヴォルガスに……不死の軍勢が彼のものか。"},
            {speaker: "不死狩りの聖者", text: "リッチキングを壊滅させてくれたのか……その呟きは、ヴォルガスが不死を操っていた証だ。あの軍勢は、不死の軍を呼び起こすためのものだった。君たちの故郷が破壊されたのは、生の守りを弱めるためだろう。本当に感謝する。この聖なる光が、君たちを守る。"},
            {speaker: "ギルドマスター", text: "報酬だ。不死に抗う力を。"}
        ],
        // 2: 堕落した天使（依頼主: 天界の使者）
        [
            {speaker: "冒険者", text: "堕落した天使を倒しました。……その翼から、深淵の闇が滴り落ちていました。"},
            {speaker: "ギルドマスター", text: "天使が堕落……ヴォルガスの力が天にまで及んでいるのか。"},
            {speaker: "天界の使者", text: "堕落した天使を倒してくれたのか……その闇は、ヴォルガスが天界を蝕んでいた証だ。あの黒い軍勢は、天の守りを崩すためのものだった。君たちの村が狙われたのは、光の血統がそこにあったからか。本当に感謝する。この翼が、君たちを導く。"},
            {speaker: "ギルドマスター", text: "報酬だ。堕落に染まらぬ力を。"}
        ]
    ],
    'S': [
        // 0: 古の悪神（依頼主: 世界の守護者）
        [
            {speaker: "冒険者", text: "深淵から現れた古の悪神を討伐しました。……その存在が、世界を歪めていました。"},
            {speaker: "ギルドマスター", text: "古の悪神……ヴォルガスの本体の片鱗か。"},
            {speaker: "世界の守護者", text: "古の悪神を討伐してくれたのか……それはヴォルガスの分身の一つだ。あの黒い軍勢は、彼の復活のための儀式だった。君たちの故郷が破壊されたのは、世界の均衡を崩すため……だが、君たちがここにいるのは、均衡の反撃だ。本当に感謝する。この世界が、君たちに味方する。"},
            {speaker: "ギルドマスター", text: "報酬だ。世界を守る力を。"}
        ],
        // 1: エルダードラゴン（依頼主: 時を超えた賢者）
        [
            {speaker: "冒険者", text: "世界を焼き尽くすエルダードラゴンを倒しました。……その炎が、深淵の門を開こうとしていました。"},
            {speaker: "ギルドマスター", text: "エルダードラゴンが門を……ヴォルガスの最終段階か。"},
            {speaker: "時を超えた賢者", text: "エルダードラゴンを倒してくれたのか……その炎は、ヴォルガスの復活を加速させるものだった。あの軍勢は、ドラゴンを目覚めさせるためのもの。君たちの村が最初の犠牲だったのは、時の守りがそこにあったからだ。本当に感謝する。この時が、君たちを待っていた。"},
            {speaker: "ギルドマスター", text: "報酬だ。時を超える力を。"}
        ],
        // 2: レヴィアタン（依頼主: 海の女神）
        [
            {speaker: "冒険者", text: "神話の海獣レヴィアタンを討伐しました。……その咆哮が、海を深淵に変えようとしていました。"},
            {speaker: "ギルドマスター", text: "レヴィアタンが……ヴォルガスの海の化身か。"},
            {speaker: "海の女神", text: "レヴィアタンを討伐してくれたのか……それはヴォルガスの海を支配する力だった。あの軍勢は、海から上陸するためのもの。君たちの故郷が狙われたのは、海の守りがそこにあったからだ。本当に感謝する。この海が、君たちを支える。"},
            {speaker: "ギルドマスター", text: "報酬だ。海のように深い力を。"}
        ]
    ]

    },
    // 1: WIS - discovery quests
    {
        'F': [
            // 0: ペンダント探索
            [
                {speaker: "冒険者", text: "町で失くされた大切なペンダントを見つけました。"},
                {speaker: "ルナ", text: "ふふ、私ならもっと早く見つけてたかも。でもよく頑張ったわね。"},
                {speaker: "ギルドマスター", text: "ルナ、自慢は後にしろ。おばあさんに返してやれ。"},
                {speaker: "おばあさん", text: "失くしたペンダントを見つけてくれたのね……大事な思い出の品だったのよ。涙が出ちゃう……本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取ってくれ。ルナ、次は探し物競争でもするか？"}
            ],
            // 1: 隠し宝箱発見
            [
                {speaker: "冒険者", text: "近所の森に隠された小さな宝箱を発見しました。"},
                {speaker: "ルナ", text: "隠し場所のヒントは木の根元だったんでしょう？私の推理通りね～。"},
                {speaker: "ギルドマスター", text: "ルナ、後で解説しろ。まずは村人に報告だ。"},
                {speaker: "村人", text: "森の隠し宝箱を見つけてくれたんだ！よくそんなところに気づいたな。中身は君の報酬だよ、受け取ってくれ！"},
                {speaker: "ギルドマスター", text: "報酬はしっかりと。ルナの推理料は別料金だ。"}
            ],
            // 2: 井戸の秘密
            [
                {speaker: "冒険者", text: "古い井戸の底に隠された秘密を見つけました。"},
                {speaker: "ルナ", text: "井戸の秘密……もしかして古代の魔法陣？私の本に載ってたわ！"},
                {speaker: "ギルドマスター", text: "ルナ、興奮しすぎ。学者に伝えてやろう。"},
                {speaker: "学者", text: "井戸の底の秘密を暴いてくれたか！昔の謎が解けて最高に面白いよ。報告ありがとう！"},
                {speaker: "ギルドマスター", text: "これが報酬だ。ルナ、次は一緒に本読むか？"}
            ]
        ],
        'F+': [
            // 0: 滝の裏の洞窟発見（依頼主: 探検家）
            [
                {speaker: "冒険者", text: "森の奥の滝の裏に隠された洞窟を発見しました。……水しぶきでびしょ濡れです。"},
                {speaker: "ルナ", text: "滝の裏！？ロマンチックね～。きっと隠された遺跡よ！"},
                {speaker: "カイト", text: "水がかかるなら俺はパスだな……濡れるの嫌いだし。"},
                {speaker: "ギルドマスター", text: "二人とも黙ってろ。探検家に報告だ。"},
                {speaker: "探検家", text: "滝の裏の洞窟を見つけてくれたんだ！これで新しい冒険が始められるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトも濡れ覚悟で連れてくか。"}
            ],
            // 1: 古い家の隠し地下室（依頼主: 家主）
            [
                {speaker: "冒険者", text: "古い家の隠し地下室を探し当てました。……埃まみれでくしゃみ止まりません。"},
                {speaker: "ルナ", text: "隠し地下室！？きっと秘密の書庫か宝物庫ね！私の推理が当たってるわ！"},
                {speaker: "ギルドマスター", text: "ルナ、埃で本が傷まないよう気をつけろ。家主に報告しよう。"},
                {speaker: "家主", text: "隠し地下室を見つけてくれたのか！先祖の秘密がようやく解けるよ。ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬だ。ルナ、次は掃除当番な。"}
            ],
            // 2: 川沿いの隠された小屋（依頼主: 漁師）
            [
                {speaker: "冒険者", text: "川沿いに隠された小屋を見つけました。……虫が多くて大変でした。"},
                {speaker: "ルナ", text: "隠された小屋……もしかして密輸の隠れ家？面白そう！"},
                {speaker: "カイト", text: "虫！？俺なら全部踏み潰してたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも想像しすぎ。漁師に報告だ。"},
                {speaker: "漁師", text: "川沿いの隠された小屋を見つけてくれたんだ！昔の道具がまだ使えるよ。本当に助かる、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は虫除け持ってけ。"}
            ]
        ],


        'D': [
            // 0: 小さな遺跡の入り口（依頼主: 考古学者）
            [
                {speaker: "冒険者", text: "近くの丘にある小さな遺跡の入り口を発見しました。……罠が多かったです。"},
                {speaker: "ルナ", text: "遺跡の入り口！？私の本に載ってた模様ね！絶対に古代魔法よ！"},
                {speaker: "カイト", text: "罠か……俺なら全部ぶっ壊してたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも落ち着け。考古学者に報告だ。"},
                {speaker: "考古学者", text: "小さな遺跡の入り口を見つけてくれたのか！新たな発見が待ってるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はルナの魔法で罠を解除するか。"}
            ],
            // 1: 隠しキャンプ（依頼主: 衛兵隊長）
            [
                {speaker: "冒険者", text: "盗賊が使う隠しキャンプを探し当てました。……警戒が厳しかったです。"},
                {speaker: "ルナ", text: "隠しキャンプの位置……地形から推理してた通りね！"},
                {speaker: "ギルドマスター", text: "ルナ、自慢は後にしろ。衛兵隊長に報告だ。"},
                {speaker: "衛兵隊長", text: "盗賊の隠しキャンプを見つけてくれたのか！これで一網打尽にできるよ。ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナの推理で敵を全滅か？"}
            ],
            // 2: キャラバンの残骸（依頼主: 商会長）
            [
                {speaker: "冒険者", text: "行方不明のキャラバンの残骸を見つけました。……悲しい現場でした。"},
                {speaker: "ルナ", text: "キャラバンの残骸……荷物は無事？商会の記録が欲しいわ。"},
                {speaker: "ギルドマスター", text: "ルナ、遺族の気持ちも考えろ。商会長に報告だ。"},
                {speaker: "商会長", text: "キャラバンの残骸を見つけてくれたのか……真相がわかるよ。本当にありがとう。"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。少しは心が癒えるといいな。"}
            ]
        ],
        'D+': [
            // 0: 古代寺院（依頼主: 神官）
            [
                {speaker: "冒険者", text: "埋もれた古代寺院の場所を発見しました。……神聖な空気が漂ってました。"},
                {speaker: "ルナ", text: "古代寺院！？私の研究にぴったり！神聖魔法の痕跡ね！"},
                {speaker: "ギルドマスター", text: "ルナ、興奮しすぎ。神官に報告だ。"},
                {speaker: "神官", text: "古代寺院を見つけてくれたのか！信仰が復活するよ。本当に感謝する、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナも祈りに行け。"}
            ],
            // 1: 隠された鉱脈（依頼主: 鉱夫頭）
            [
                {speaker: "冒険者", text: "山の隠された鉱脈を探し当てました。……崩落が怖かったです。"},
                {speaker: "ルナ", text: "鉱脈の成分は……魔力結晶かも！研究したいわ～。"},
                {speaker: "カイト", text: "鉱脈なら俺が掘りまくってたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも静かに。鉱夫頭に報告だ。"},
                {speaker: "鉱夫頭", text: "隠された鉱脈を見つけてくれたのか！これで村が潤うよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は二人で採掘作業か？"}
            ],
            // 2: 湖底の村の痕跡（依頼主: 歴史家）
            [
                {speaker: "冒険者", text: "湖底に沈んだ村の痕跡を見つけました。……水中で息が苦しかったです。"},
                {speaker: "ルナ", text: "沈んだ村！？水没の呪いかも……興味深いわ！"},
                {speaker: "ギルドマスター", text: "ルナ、呪いはやめろ。歴史家に報告だ。"},
                {speaker: "歴史家", text: "湖底の村の痕跡を見つけてくれたのか！失われた歴史が蘇るよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナが水没しないよう祈っとく。"}
            ]
        ],
        'C': [
            // 0: 忘れられた城の秘密通路（依頼主: 王国騎士）
            [
                {speaker: "冒険者", text: "忘れられた城の秘密通路を発見しました。……幽霊が出そうで怖かったです。"},
                {speaker: "ルナ", text: "秘密通路！？城の隠し財宝か王族の逃げ道ね！私の推理が当たってるわ！"},
                {speaker: "カイト", text: "幽霊なら俺がぶった斬ってやるぜ！"},
                {speaker: "ギルドマスター", text: "二人とも落ち着け。王国騎士に報告だ。"},
                {speaker: "王国騎士", text: "忘れられた城の秘密通路を見つけてくれたのか！戦略が変わるよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は幽霊退治も頼むか？"}
            ],
            // 1: 魔法の泉（依頼主: 大魔導士）
            [
                {speaker: "冒険者", text: "魔法の泉の正確な位置をマッピングしました。……魔力が強すぎて頭がクラクラします。"},
                {speaker: "ルナ", text: "魔法の泉！？私が行きたかったわ～！魔力補給し放題ね！"},
                {speaker: "ギルドマスター", text: "ルナ、飲みすぎるな。大魔導士に報告だ。"},
                {speaker: "大魔導士", text: "魔法の泉の位置を特定してくれたのか！研究が捗るよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナを連れてったら泉が空になるかも。"}
            ],
            // 2: 呪われた森の祠（依頼主: 浄化師）
            [
                {speaker: "冒険者", text: "呪われた森の中心にある祠を探し出しました。……呪いが染みついてます。"},
                {speaker: "ルナ", text: "祠の呪い……古代の封印ね！解呪したいわ！"},
                {speaker: "ギルドマスター", text: "ルナ、呪われたら困る。浄化師に報告だ。"},
                {speaker: "浄化師", text: "呪われた森の祠を見つけてくれたのか！浄化が可能になったよ。本当に助かった！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はルナが呪われないよう見張っとく。"}
            ]

            
        ],
        'C+': [
            // 0: 失われた文明の遺跡（依頼主: 古代史学者）
            [
                {speaker: "冒険者", text: "失われた文明の遺跡を発見しました。……壁画が美しくて見とれてました。"},
                {speaker: "ルナ", text: "失われた文明！？私の本にない文字がいっぱいね！早く解読させて～！"},
                {speaker: "カイト", text: "遺跡なら宝物だろ！俺も掘りに行きたかったぜ！"},
                {speaker: "ギルドマスター", text: "二人とも遺跡を壊すな。古代史学者に報告だ。"},
                {speaker: "古代史学者", text: "失われた文明の遺跡を見つけてくれたのか！歴史が書き換えられるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。ルナの解読は夜通しになりそうだな。"}
            ],
            // 1: 雲の上に浮かぶ島（依頼主: 空の探検家）
            [
                {speaker: "冒険者", text: "雲の上に浮かぶ島への道を見つけました。……高所恐怖症が治りそうです。"},
                {speaker: "ルナ", text: "浮かぶ島！？重力魔法の極致ね！私も飛んで行きたかったわ～！"},
                {speaker: "カイト", text: "雲の上か！俺なら飛び乗って冒険だぜ！落ちても気合いで！"},
                {speaker: "ギルドマスター", text: "カイト、気合いで落ちるな。空の探検家に報告だ。"},
                {speaker: "空の探検家", text: "浮かぶ島への道を見つけてくれたのか！空の秘境が開かれたよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は二人でパラシュート持ってけ。"}
            ],
            // 2: 不安定な次元ポータル（依頼主: 次元魔導士）
            [
                {speaker: "冒険者", text: "不安定な次元ポータルの場所を発見しました。……空間が歪んで吐きそうでした。"},
                {speaker: "ルナ", text: "次元ポータル！？異世界の魔力が感じられるわ！私が行きたかった～！"},
                {speaker: "カイト", text: "異世界か！俺の剣で征服してくるぜ！"},
                {speaker: "ギルドマスター", text: "二人とも異世界で迷子になるな。次元魔導士に報告だ。"},
                {speaker: "次元魔導士", text: "次元ポータルの場所を見つけてくれたのか！新たな研究が始まるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナが異世界に飛ばされないよう祈っとく。"}
            ]
        ],
        'B': [
            // 0: 迷宮のような峡谷の隠された道（依頼主: 地図の賢者 エルドリン ※NPC関連）
            [
                {speaker: "冒険者", text: "迷宮のような峡谷の隠された道を地図化しました。……方向音痴になりかけました。"},
                {speaker: "ルナ", text: "峡谷の隠し道！？伝説の宝への近道ね！エルドリンさん喜ぶわ！"},
                {speaker: "カイト", text: "迷宮か！俺なら壁ぶち破って最短ルート作ってたぜ！"},
                {speaker: "ギルドマスター", text: "カイト、地図が台無しだ。エルドリンに報告だ。"},
                {speaker: "エルドリン", text: "峡谷の隠された道を地図化してくれたのか！私の地図が完成に近づいたよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は壁壊さないでな。"}
            ],
            // 1: 砂漠の砂丘の失われた星の神殿（依頼主: 星の観測者 アストリッド ※NPC関連）
            [
                {speaker: "冒険者", text: "砂漠の砂丘に失われた星の神殿を発掘しました。……砂嵐で目が開けられませんでした。"},
                {speaker: "ルナ", text: "星の神殿！？星座の秘密が解けるわ！アストリッドさん大興奮ね！"},
                {speaker: "カイト", text: "砂漠か！熱いけど俺なら剣で砂切り開いてたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも砂漠で遊ぶな。アストリッドに報告だ。"},
                {speaker: "アストリッド", text: "失われた星の神殿を発掘してくれたのか！星の謎が解けるよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は熱中症対策を。"}
            ],
            // 2: アジュール湖の下の沈んだ遺跡（依頼主: 深海の探求者 コルバト ※NPC関連）
            [
                {speaker: "冒険者", text: "アジュール湖の下の沈んだ遺跡を見つけました。……水圧で耳が痛かったです。"},
                {speaker: "ルナ", text: "沈んだ遺跡！？水文明の魔法が眠ってるわ！コルバトさん待ってるわね！"},
                {speaker: "カイト", text: "水中か！俺なら息止めて潜ってたぜ！"},
                {speaker: "ギルドマスター", text: "カイト、溺れるな。コルバトに報告だ。"},
                {speaker: "コルバト", text: "湖底の沈んだ遺跡を見つけてくれたのか！深海の謎に光が当たるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は酸素ボンベ持ってけ。"}
            ]
        ],
        'B+': [
            // 0: エコーケイブの秘密の間（依頼主: 反響の予見者 シララ ※NPC関連）
            [
                {speaker: "冒険者", text: "エコーケイブの秘密の間を発見しました。……ささやきが予言みたいで怖かったです。"},
                {speaker: "ルナ", text: "エコーの秘密の間！？予言の声が聞けるわ！シララさん大喜びね！"},
                {speaker: "カイト", text: "ささやき！？大声で叫んで反響楽しんでたぜ！"},
                {speaker: "ギルドマスター", text: "カイト、予言が台無しだ。シララに報告だ。"},
                {speaker: "シララ", text: "秘密の間を見つけてくれたのか！予言が鮮明になったよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は静かにしろよ。"}
            ],
            // 1: クラウドピークの忘れられた天文台（依頼主: 星の観測者 アストリッド ※重複だがOK）
            [
                {speaker: "冒険者", text: "クラウドピークの忘れられた天文台を位置づけました。……雲で視界ゼロでした。"},
                {speaker: "ルナ", text: "忘れられた天文台！？多宇宙が見えるかも！アストリッドさん興奮ね！"},
                {speaker: "カイト", text: "雲の上か！俺なら雲蹴散らしてたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも天文台壊すな。アストリッドに報告だ。"},
                {speaker: "アストリッド", text: "忘れられた天文台を見つけてくれたのか！宇宙の秘密が解けるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は雲を蹴るな。"}
            ],
            // 2: ウィスパリングウッドのハートツリー（依頼主: 森のドルイド リオラ ※NPC関連）
            [
                {speaker: "冒険者", text: "ウィスパリングウッドのハートツリーを探検しました。……木がささやいてました。"},
                {speaker: "ルナ", text: "森のハートツリー！？自然魔法の源ね！リオラさん待ってるわ！"},
                {speaker: "カイト", text: "木が喋る！？俺なら剣で会話してたぜ！"},
                {speaker: "ギルドマスター", text: "カイト、木を斬るな。リオラに報告だ。"},
                {speaker: "リオラ", text: "ハートツリーを見つけてくれたのか！森の力が蘇るよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。木との会話は控えめに。"}
            ]
        ],        'A': [
            // 0: アッシェンウェイストの埋もれた天文台を発掘せよ。火山の異常。（依頼主: 火山の観測者ヴォルカノス）
            [
                {speaker: "冒険者", text: "アッシェンウェイストの埋もれた天文台を発掘しました。……火山の異常活動が、深淵の魔力で引き起こされていました。"},
                {speaker: "ルナ", text: "深淵の魔力……ヴォルガスの仕業ね。星の動きまで歪めようとしてるなんて……。"},
                {speaker: "ギルドマスター", text: "ヴォルガスが火山の力を利用しようとしているのか。"},
                {speaker: "ヴォルカノス", text: "その天文台を……異常はヴォルガスが炎と破壊の領域を支配するための儀式だった。あの黒い軍勢は、火山のエネルギーを奪う先兵に過ぎない。君たちの故郷が狙われたのは、火の守護の血が流れていたからだろう。本当に感謝する。この炎が、君たちの復讐を燃やす。"},
                {speaker: "ギルドマスター", text: "報酬だ。炎のように燃える力を。"
                }
            ],
            // 1: エンドレスサンドのミラージュオアシスを見つけよ。幻か現実か？（依頼主: 幻影の賢者ミラージュ）
            [
                {speaker: "冒険者", text: "エンドレスサンドのミラージュオアシスを発見しました。……幻のオアシスは、ヴォルガスの幻惑魔法で作り出されたものでした。"},
                {speaker: "ルナ", text: "幻惑魔法の規模が凄すぎる……これ、私の魔法じゃ太刀打ちできないわ。"},
                {speaker: "ギルドマスター", text: "ヴォルガスが人心を操る力を持っているのか……。"},
                {speaker: "ミラージュ", text: "ミラージュオアシスを……それはヴォルガスが旅人を惑わせ、軍勢を無血で増やすための罠だった。あの軍勢は幻で数を増やし、実体で襲う策略。君たちの村が最初に狙われたのは、真実を見抜く清らかな心がそこにあったからだ。本当に感謝する。この幻が、君たちを惑わせぬよう祈る。"},
                {speaker: "ギルドマスター", text: "報酬だ。幻に惑われぬ力を。"
                }
            ],
            // 2: クリスタルカーブンの輝く鉱脈をチャートせよ。アーティファクトの力源。（依頼主: 結晶の守護者クリスタリア）
            [
                {speaker: "冒険者", text: "クリスタルカーブンの輝く鉱脈を完全にマッピングしました。……その魔力の源が、ヴォルガスの闇の結晶として汚染されていました。"},
                {speaker: "ルナ", text: "闇の結晶……あれほどの魔力濃度、私の研究でも見たことないわ。ヴォルガスの力の源の一つね……。"},
                {speaker: "ギルドマスター", text: "ヴォルガスがこんな力の源を複数持っているのか……。"},
                {speaker: "クリスタリア", text: "輝く鉱脈を……それはヴォルガスが無限の魔力を得るための鍵だった。あの黒い軍勢は結晶を奪い、永遠の支配を築くためのもの。君たちの故郷が破壊されたのは、純粋な光の結晶がそこに眠っていたからだ。本当に感謝する。この結晶の光が、君たちを導く。"},
                {speaker: "ギルドマスター", text: "報酬だ。結晶のように揺るがぬ力を。"
                }
            ]
        ],
        'A+': [
            // 0: ソーンウォールメイズの隠されたグローブを発見せよ。永遠の若さが咲く。（依頼主: 永遠の庭師エテルナ）
            [
                {speaker: "冒険者", text: "ソーンウォールメイズの隠されたグローブを発見しました。……永遠の若さの木が、ヴォルガスの不死の呪いで完全に支配されていました。"},
                {speaker: "ルナ", text: "不死の呪い……あれはヴォルガスが究極の目的とするものね。私たちも気をつけないと……。"},
                {speaker: "ギルドマスター", text: "ヴォルガス自身が不死を求めているのか……。"},
                {speaker: "エテルナ", text: "隠されたグローブを……それはヴォルガスが肉体を超えた永遠の存在になるための最後の鍵だった。あの軍勢は生命の源を奪い、不死の軍勢を築くため。君たちの村が最初の標的だったのは、生命の種——純粋な魂がそこにあったからだ。本当に感謝する。この生命の木が、君たちに新たな未来を与える。"},
                {speaker: "ギルドマスター", text: "報酬だ。不死に抗う、生の力を。"
                }
            ]
        ],
        'S': [
        // 0: 宇宙の果てに存在する禁断の神殿（S専用1）
        [
            {speaker: "冒険者", text: "宇宙の果ての禁断の神殿を発見しました。……神殿の中心に、ヴォルガスの真の姿が封じられていました。"},
            {speaker: "ギルドマスター", text: "真の姿……これがすべてのはじまりか。"},
            {speaker: "宇宙の観測者", text: "禁断の神殿を……ここにヴォルガスの本体が封じられている。あの黒い軍勢は、本体を解放するためのものだった。君たちの故郷が破壊されたのは、最後の封印がそこにあったからだ。本当に感謝する。この発見が、世界の終わりを防ぐ。"},
            {speaker: "ギルドマスター", text: "報酬だ。宇宙の終わりを止める力を。"}
        ],
        // 1: 世界の起源を記した究極の図書館（S専用2）
        [
            {speaker: "冒険者", text: "世界の起源を記した究極の図書館を見つけました。……起源の書に、ヴォルガスが世界の闇そのものであると記されていました。"},
            {speaker: "ギルドマスター", text: "世界の闇そのもの……我々の戦いは起源にまで及ぶのか。"},
            {speaker: "起源の守護者", text: "究極の図書館を……ヴォルガスは起源から存在する闇だ。あの軍勢は、起源を闇に染めるためのものだった。君たちの村が最初の標的だったのは、起源の光が生まれた場所だから。本当に感謝する。この起源が、新たな世界を生む。"},
            {speaker: "ギルドマスター", text: "報酬だ。起源を塗り替える力を。"}
        ],
        // 2: 神々が会議を行う隠された領域（S専用3）
        [
            {speaker: "冒険者", text: "神々が会議を行う隠された領域を発見しました。……神々は、ヴォルガスとの最終決戦を予見していました。"},
            {speaker: "ギルドマスター", text: "最終決戦……我々がその鍵か。"},
            {speaker: "神界の使者", text: "隠された領域を……神々は、ヴォルガスが神界を滅ぼすと恐れていた。あの軍勢は、神の力を弱めるためのものだった。君たちの故郷が破壊されたのは、神の意志がそこに宿っていたからだ。本当に感謝する。この神々が、君たちを選んだ。"},
            {speaker: "ギルドマスター", text: "報酬だ。神々に選ばれた力を。"}
        ]
    ]
    },
    // 2: DEX - escort quests
    {
        'F': [
            // 0: 農夫護衛
            [
                {speaker: "冒険者", text: "農夫さんを近くの市場まで無事に護衛しました。"},
                {speaker: "カイト", text: "道中何も起きなかったのか？つまんねーな！"},
                {speaker: "ルナ", text: "カイト、何も起きないのが一番良いのよ。"},
                {speaker: "ギルドマスター", text: "二人とも静かに。農夫さん、感想をどうぞ。"},
                {speaker: "農夫", text: "無事に市場まで着けたよ。怖い思いせずに済んで本当に助かった！ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトも護衛につけたら面白くなりそうだな……。"}
            ],
            // 1: 子供送迎
            [
                {speaker: "冒険者", text: "子供を危険な橋を渡って無事に家まで送りました。"},
                {speaker: "ルナ", text: "子供って可愛いわよね～。私もお菓子あげたくなっちゃう。"},
                {speaker: "カイト", text: "俺は一緒に剣の練習したかったけどな！"},
                {speaker: "ギルドマスター", text: "二人とも子供の前では大人しくしろ。親御さんに確認しよう。"},
                {speaker: "親", text: "子供を無事に送ってくれて本当にありがとう！心配で死にそうだったわ……感謝してもしきれないよ。"},
                {speaker: "ギルドマスター", text: "報酬だ。優しい心が伝わったな。"}
            ],
            // 2: 使者護衛
            [
                {speaker: "冒険者", text: "手紙を届ける使者を無事に守りきりました。"},
                {speaker: "カイト", text: "スパイとか出てこなかったのか？出てきたら俺がぶった斬ってたのに！"},
                {speaker: "ルナ", text: "カイト、平和が一番よ。"},
                {speaker: "ギルドマスター", text: "お前ら、たまには静かにしろ。村長に報告だ。"},
                {speaker: "村長", text: "使者を守って手紙を無事届けられたよ。重要な内容だったんだ、君のおかげで村が救われた。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "これが報酬だ。次はカイトとルナも同行させたらドラマになりそうだな。"}
            ]
        ],
        'F+': [
            // 0: 商人護衛（ゴブリン潜む道）
            [
                {speaker: "冒険者", text: "商人を次の町まで護衛しました。ゴブリンが潜む道でしたが無事です。"},
                {speaker: "カイト", text: "ゴブリンが出たなら俺の出番だったのに！なんで連れてってくれねえんだよ！"},
                {speaker: "ルナ", text: "カイトが行ったら商人が怖がって逃げちゃうわよ。"},
                {speaker: "ギルドマスター", text: "二人とも騒がしいな。商人に感想を聞こう。"},
                {speaker: "商人", text: "ゴブリンの潜む道を無事に通れたよ！本当に頼りになった、ありがとう冒険者さん！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトも連れてったら商人が値上げしそうだ。"}
            ],
            // 1: 旅行者グループ護衛
            [
                {speaker: "冒険者", text: "旅行者のグループを森の道で無事に守りました。"},
                {speaker: "ルナ", text: "旅行者さんたち、楽しそうだった？お土産話聞きたかったわ～。"},
                {speaker: "カイト", text: "森なら俺の守りで鉄壁だったぜ！次は絶対呼べよ！"},
                {speaker: "ギルドマスター", text: "お前ら、護衛じゃなくて観光客だろ。旅行者に報告だ。"},
                {speaker: "旅行者代表", text: "森の道を無事に通らせてくれてありがとう！怖かったけど君のおかげで楽しめたよ！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は観光ガイドも兼ねるか？"}
            ],
            // 2: キャラバン護衛
            [
                {speaker: "冒険者", text: "荷物を運ぶキャラバンを盗賊から無事に護衛しました。"},
                {speaker: "カイト", text: "盗賊が出たのか！？俺なら一網打尽にしてたのに！悔しいぜ！"},
                {speaker: "ルナ", text: "カイト、荷物が壊れたら大変よ。無事で何よりね。"},
                {speaker: "ギルドマスター", text: "二人とも静かに。キャラバン主に報告しよう。"},
                {speaker: "キャラバン主", text: "盗賊から荷物を守ってくれて本当に助かった！これで商売が続けられるよ、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。カイト、次は本当に盗賊狩りだ。"}
            ]
        ],
        'D': [
            // 0: 貴族護衛（依頼主: 貴族）
            [
                {speaker: "冒険者", text: "貴族を隣町まで無事に護衛しました。……暗殺者の気配があって緊張しっぱなしでした。"},
                {speaker: "カイト", text: "暗殺者！？出てきたら俺が一瞬でぶった斬ってたぜ！次は絶対連れてけよ！"},
                {speaker: "ルナ", text: "カイトが行ったら貴族様が怖がって逃げちゃうわよ……。"},
                {speaker: "ギルドマスター", text: "二人とも静かに。貴族に感想を聞こう。"},
                {speaker: "貴族", text: "無事に隣町まで着けたよ。暗殺者の噂があったのに怖い思いせずに済んだ。本当に感謝する、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトも連れてったら貴族が値下げ交渉しそうだ。"}
            ],
            // 1: 負傷兵士送還（依頼主: 軍医）
            [
                {speaker: "冒険者", text: "負傷した兵士を前線からキャンプまで送りました。……戦場の空気が重かったです。"},
                {speaker: "ルナ", text: "負傷兵……回復魔法をかけたかったわ。私も行けばよかったかも。"},
                {speaker: "カイト", text: "戦場か！俺なら敵を全部蹴散らしてたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも状況をわきまえろ。軍医に報告だ。"},
                {speaker: "軍医", text: "負傷兵を無事に送ってくれたのか！命が救われたよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナの魔法で全員完治か？"}
            ],
            // 2: 学者遺跡護衛（依頼主: 学者）
            [
                {speaker: "冒険者", text: "学者を危険な遺跡まで護衛しました。……罠が多すぎてヒヤヒヤしました。"},
                {speaker: "ルナ", text: "遺跡の罠！？私なら全部解除してたわ～。学者さんも喜んでたでしょ？"},
                {speaker: "カイト", text: "罠なら俺が壊して進むぜ！"},
                {speaker: "ギルドマスター", text: "二人とも学者を踏みつぶすな。学者に感想を聞こう。"},
                {speaker: "学者", text: "遺跡まで無事に着けたよ。君の護衛がなければ無理だった。本当に助かった、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はルナとカイトで遺跡崩壊しそうだ。"}
            ]
        ],
        'D+': [
            // 0: 外交官護衛（依頼主: 外交官）
            [
                {speaker: "冒険者", text: "外交官を敵の領土を抜けて無事に護衛しました。……スパイが多かったです。"},
                {speaker: "カイト", text: "スパイ！？全員捕まえてぶん殴ってたぜ！次は俺の出番だろ！"},
                {speaker: "ルナ", text: "カイト、外交官が怖がって交渉できなくなるわよ。"},
                {speaker: "ギルドマスター", text: "二人とも国際問題起こすな。外交官に報告だ。"},
                {speaker: "外交官", text: "敵領を無事に抜けられたよ。君のおかげで和平が保てた。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイト連れてったら戦争になるかもな。"}
            ],
            // 1: 難民家族ガイド（依頼主: 難民代表）
            [
                {speaker: "冒険者", text: "難民の家族を安全地帯までガイドしました。……子供たちが可愛かったです。"},
                {speaker: "ルナ", text: "子供たち！？私もお菓子持って行きたかったわ～。みんな無事でよかった！"},
                {speaker: "カイト", text: "難民か……俺なら敵を全部蹴散らして道を作ってたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも優しさと暴力のバランス取れ。難民代表に感想を。"},
                {speaker: "難民代表", text: "家族を無事に安全地帯まで導いてくれた。本当に命の恩人だ、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。心が温まるな。"}
            ],
            // 2: 魔獣調教師護衛（依頼主: 調教師）
            [
                {speaker: "冒険者", text: "珍しい魔獣と調教師を闘技場まで護衛しました。……魔獣が暴れそうで怖かったです。"},
                {speaker: "カイト", text: "魔獣！？俺なら一緒に戦ってたぜ！闘技場で対決したい！"},
                {speaker: "ルナ", text: "魔獣の生態……研究したいわ～。暴れないでくれてよかった。"},
                {speaker: "ギルドマスター", text: "二人とも魔獣を刺激するな。調教師に報告だ。"},
                {speaker: "調教師", text: "魔獣を無事に闘技場まで連れてこれたよ。君の護衛がなければ無理だった。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトと魔獣で対決か？"}
            ]
        ],
        'C': [
            // 0: 王子護衛（依頼主: 王子）
            [
                {speaker: "冒険者", text: "王子を隣国まで無事に護衛しました。……政略結婚の重圧が伝わってきました。"},
                {speaker: "ルナ", text: "王子様の政略結婚……ロマンチックだけど切ないわね。"},
                {speaker: "カイト", text: "王子か！俺なら敵国に乗り込んで戦争止めてたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも王族の前で失礼だぞ。王子に感想を。"},
                {speaker: "王子", text: "隣国まで無事に着けたよ。君の護衛がなければ危なかった。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイト連れてったら結婚破談になるかも。"}
            ],
            // 1: 聖女護衛（依頼主: 聖女）
            [
                {speaker: "冒険者", text: "聖女を聖地まで守り抜きました。……異端者が執拗に狙ってきました。"},
                {speaker: "ルナ", text: "聖女様！？神聖魔法を近くで見てみたかったわ～。"},
                {speaker: "カイト", text: "異端者！？全員ぶった斬って聖地まで突っ走ってたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも聖女の前で控えめに。王子に報告だ。"},
                {speaker: "聖女", text: "聖地まで無事に着けたよ。異端者の脅威から守ってくれて本当にありがとう。神のご加護を。"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。神のご加護はカイトには効かなそうだ。"}
            ],
            // 2: 神器運搬護衛（依頼主: 大司祭）
            [
                {speaker: "冒険者", text: "貴重な神器を運ぶ一行を無事に護衛しました。……盗賊団が狙ってきて大変でした。"},
                {speaker: "カイト", text: "神器か！俺なら盗賊全員まとめて蹴散らしてたぜ！"},
                {speaker: "ルナ", text: "神器……魔力がすごそう！私も触ってみたかったわ。"},
                {speaker: "ギルドマスター", text: "二人とも神器を壊すな。大司祭に報告だ。"},
                {speaker: "大司祭", text: "神器を無事に運べたよ。君の護衛がなければ失われていた。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナが神器で実験しそうだ。"}
            ]
        ],
        'C+': [
            // 0: 将軍護衛（依頼主: 将軍）
            [
                {speaker: "冒険者", text: "将軍を戦場まで無事に護衛しました。……敵のスパイがうじゃうじゃで緊張しました。"},
                {speaker: "カイト", text: "戦場護衛！？スパイなら俺が全員捕まえて拷問だぜ！次は俺を連れてけ！"},
                {speaker: "ルナ", text: "カイト、拷問は国際問題よ……将軍様も怖がるわ。"},
                {speaker: "ギルドマスター", text: "二人とも戦争起こすな。将軍に感想を聞こう。"},
                {speaker: "将軍", text: "戦場まで無事に着けたよ。スパイの脅威から守ってくれて本当に助かった。感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイト連れてったら敵が降伏しそうだ。"}
            ],
            // 1: 予言者護衛（依頼主: 予言者）
            [
                {speaker: "冒険者", text: "予言者を神託の場所まで送りました。……未来のビジョンがチラチラ見えて混乱しました。"},
                {speaker: "ルナ", text: "神託の場所！？予言を近くで聞きたかったわ～。私も護衛したかった！"},
                {speaker: "カイト", text: "予言か！俺の未来は最強の剣士だろ！教えてくれよ！"},
                {speaker: "ギルドマスター", text: "二人とも予言者を疲れさせるな。予言者に報告だ。"},
                {speaker: "予言者", text: "神託の場所まで無事に着けたよ。君の護衛がなければ道半ばだった。本当にありがとう。"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトの未来は留守番かもな。"}
            ],
            // 2: エルフ王女護衛（依頼主: エルフ王女）
            [
                {speaker: "冒険者", text: "最後のエルフ王女を隠れ里まで護衛しました。……森の精霊が味方してくれて助かりました。"},
                {speaker: "ルナ", text: "エルフ王女！？優雅で美しいわよね～。私もお茶会したかったわ！"},
                {speaker: "カイト", text: "エルフか！弓が上手いんだろ？俺と勝負したいぜ！"},
                {speaker: "ギルドマスター", text: "二人とも王女を疲れさせるな。王女に感想を。"},
                {speaker: "エルフ王女", text: "隠れ里まで無事に着けたわ。君の護衛がなければ捕らわれていた。本当に感謝する。"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はルナがお茶会、カイトが決闘か？"}
            ]
        ],
        'B': [
            // 0: 古代の賢者護衛（依頼主: 古代の賢者）
            [
                {speaker: "冒険者", text: "古代の賢者を禁断の図書館まで護衛しました。……知識の重みが肩にのしかかりました。"},
                {speaker: "ルナ", text: "禁断の図書館！？私の夢の場所よ！賢者様と一緒に本読みたかったわ～！"},
                {speaker: "カイト", text: "本ばっかりか！俺なら図書館の守護モンスターぶった斬ってたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも図書館で騒ぐな。賢者に報告だ。"},
                {speaker: "古代の賢者", text: "禁断の図書館まで無事に着けたよ。君の護衛がなければ知識は失われていた。本当にありがとう。"},
                {speaker: "ギルドマスター", text: "報酬だ。ルナの本読みは制限付きな。"}
            ],
            // 1: ドラゴンライダー護衛（依頼主: ドラゴンライダー）
            [
                {speaker: "冒険者", text: "ドラゴンライダーを巣まで守りました。……ドラゴンが近くて迫力ありすぎです。"},
                {speaker: "カイト", text: "ドラゴンライダー！？俺も乗りたかったぜ！ドラゴンと一緒に戦うんだろ！"},
                {speaker: "ルナ", text: "ドラゴンの生態……近くで観察したかったわ～。鱗触りたかった！"},
                {speaker: "ギルドマスター", text: "二人ともドラゴンを刺激するな。ライダーに感想を。"},
                {speaker: "ドラゴンライダー", text: "巣まで無事に着けたよ。君の護衛がなければドラゴンが暴れてた。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はカイトがドラゴンに乗ったら墜落だ。"}
            ],
            // 2: 神の化身護衛（依頼主: 神の化身）
            [
                {speaker: "冒険者", text: "神の化身を神殿まで護衛しました。……神聖オーラで目がくらみました。"},
                {speaker: "ルナ", text: "神の化身！？神聖魔法を間近で感じたかったわ～。奇跡見せてほしかった！"},
                {speaker: "カイト", text: "神か！俺の剣で神の試練受けてやるぜ！"},
                {speaker: "ギルドマスター", text: "二人とも神を試すな。化身に報告だ。"},
                {speaker: "神の化身", text: "神殿まで無事に着けたよ。君の護衛がなければ道を外れていた。本当にありがとう。"},
                {speaker: "ギルドマスター", text: "報酬だ。神のご加護はカイトには届かなそうだ。"}
            ]
        ],
        'B+': [
            // 0: 堕落した英雄護衛（依頼主: 堕落した英雄）
            [
                {speaker: "冒険者", text: "堕落した英雄を裁きの場まで護衛しました。……闇の力が重かったです。"},
                {speaker: "カイト", text: "堕落した英雄！？俺なら浄化の一撃だぜ！次は戦わせろ！"},
                {speaker: "ルナ", text: "堕落の原因……闇魔法の研究になるわ！興味深い～。"},
                {speaker: "ギルドマスター", text: "二人とも英雄を刺激するな。英雄に感想を。"},
                {speaker: "堕落した英雄", text: "裁きの場まで無事に着けたよ。君の護衛がなければ逃げていた。本当に感謝する……かもしれない。"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトが英雄と決闘しそうだ。"}
            ],
            // 1: 星の使者護衛（依頼主: 星の使者）
            [
                {speaker: "冒険者", text: "星の使者を天文台まで送りました。……星の力が体に染みました。"},
                {speaker: "ルナ", text: "星の使者！？宇宙の秘密を聞きたかったわ～。私も同行したかった！"},
                {speaker: "カイト", text: "星か！俺の剣で流星みたいに斬ってやるぜ！"},
                {speaker: "ギルドマスター", text: "二人とも宇宙を壊すな。使者に報告だ。"},
                {speaker: "星の使者", text: "天文台まで無事に着けたよ。星の導きが君にあった。本当にありがとう。"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。ルナの星読みは次回に。"}
            ],
            // 2: ユニコーン護衛（依頼主: 最後のユニコーン）
            [
                {speaker: "冒険者", text: "最後のユニコーンを聖域まで護衛しました。……純粋な光がまぶしかったです。"},
                {speaker: "ルナ", text: "ユニコーン！？角の魔法がすごいわ！触りたかった～！"},
                {speaker: "カイト", text: "ユニコーンか！俺なら騎乗して突撃だぜ！"},
                {speaker: "ギルドマスター", text: "カイト、ユニコーンが逃げるぞ。ユニコーンに感想を……って、喋らないか。"},
                {speaker: "ユニコーン守護者", text: "ユニコーンを聖域まで守ってくれたのか！純粋さが保たれたよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトが角で突かれないよう祈っとく。"}
            ]
        ],
        'A': [
        // 0: 王を亡命先まで護衛（依頼主: 王国の忠臣）
        [
            {speaker: "冒険者", text: "王を亡命先まで無事に護衛しました。……敵の追手が、王の血を求めていました。"},
            {speaker: "ギルドマスター", text: "王の血……ヴォルガスの儀式に必要だったのか。"},
            {speaker: "王国の忠臣", text: "王を無事に亡命させてくれたのか……国が滅びようとしているのは、ヴォルガスの復活のためだ。王の血統は、封印の最後の鍵だった。あの黒い軍勢は、王を捕らえて儀式を完成させるつもりだったのだろう。君たちの故郷が破壊されたのも、同じ理由か。本当に感謝する。この王が、復権の旗印となる。"},
            {speaker: "ギルドマスター", text: "報酬だ。王国を再興する力を。"}
        ],
        // 1: 大魔導士を禁呪の儀式場まで護衛（依頼主: 大魔導士の弟子）
        [
            {speaker: "冒険者", text: "大魔導士を禁呪の儀式場まで守りました。……闇の刺客が、儀式を妨げようとしていました。"},
            {speaker: "ギルドマスター", text: "禁呪……ヴォルガス封じの最後の手段か。"},
            {speaker: "大魔導士の弟子", text: "師を儀式場まで無事に導いてくれたのか……この禁呪は、ヴォルガスを再び封じるためのものだ。あの軍勢は、儀式を阻止するために動いていた。君たちの村が狙われたのは、魔導の血がそこにあったからかもしれない。本当に感謝する。この禁呪が、闇を封じる。"},
            {speaker: "ギルドマスター", text: "報酬だ。禁呪に耐える力を。"}
        ],
        // 2: 神の遺児を運命の場所まで護衛（依頼主: 神殿の預言者）
        [
            {speaker: "冒険者", text: "神の遺児を運命の場所まで護衛しました。……遺児の周りに、深淵の影が集まっていました。"},
            {speaker: "ギルドマスター", text: "神の遺児……ヴォルガスが最も恐れる存在か。"},
            {speaker: "神殿の預言者", text: "神の遺児を運命の場所まで守ってくれたのか……遺児は、ヴォルガスを滅ぼす運命の子だ。あの軍勢は、遺児を殺すために送られた。君たちの故郷が破壊されたのは、神の血がそこに流れていたから。本当に感謝する。この遺児が、闇を終わらせる。"},
            {speaker: "ギルドマスター", text: "報酬だ。運命を変える力を。"}
        ]
    ],
    'A+': [
        // 0: 光の女神の巫女を最終聖域まで護衛（依頼主: 女神の声）
        [
            {speaker: "冒険者", text: "光の女神の巫女を最終聖域まで護衛しました。……闇の軍勢が、巫女の光を消そうとしていました。"},
            {speaker: "ギルドマスター", text: "女神の巫女……ヴォルガスの最大の脅威か。"},
            {speaker: "女神の声", text: "巫女を聖域まで無事に導いてくれたのか……巫女の光は、ヴォルガスを浄化する唯一の力だ。あの黒い軍勢は、光を永遠に消すために動いていた。君たちの村が最初の標的だったのは、光の女神の加護がそこにあったから。本当に感謝する。この光が、君たちを照らす。"},
            {speaker: "ギルドマスター", text: "報酬だ。女神の光を宿す力を。"}
        ],
        // 1: 最後の希望である預言者を世界の中心まで護衛（依頼主: 預言者の守護霊）
        [
            {speaker: "冒険者", text: "最後の希望である預言者を世界の中心まで送りました。……預言者の言葉が、ヴォルガスの終わりを告げていました。"},
            {speaker: "ギルドマスター", text: "最後の希望……我々がそれを守ったのか。"},
            {speaker: "預言者の守護霊", text: "預言者を世界の中心まで守ってくれたのか……預言者は、ヴォルガスの終焉を予見している。あの軍勢は、希望を絶つために送られた。君たちの故郷が破壊されたのは、希望の種がそこに植えられていたからだ。本当に感謝する。この希望が、世界を救う。"},
            {speaker: "ギルドマスター", text: "報酬だ。最後の希望を叶える力を。"}
        ],
        // 2: 滅びゆく世界の救世主を神の座まで護衛（依頼主: 古の神々）
        [
            {speaker: "冒険者", text: "滅びゆく世界の救世主を神の座まで護衛しました。……深淵の軍勢が、全力で阻もうとしていました。"},
            {speaker: "ギルドマスター", text: "救世主……ヴォルガスとの最終決戦か。"},
            {speaker: "古の神々", text: "救世主を神の座まで守ってくれたのか……救世主は、ヴォルガスを滅ぼす存在だ。あの黒い軍勢は、神の座を汚すために来た。君たちの村が狙われたのは、救世主の血がそこにあったから。本当に感謝する。この神々が、君たちに力を貸す。"},
            {speaker: "ギルドマスター", text: "報酬だ。世界を救う力を。"}
        ]
    ],
    'S': [
        // 0: 世界の均衡を守る存在を深淵の門まで護衛（依頼主: 均衡の守護神）
        [
            {speaker: "冒険者", text: "世界の均衡を守る存在を深淵の門まで護衛しました。……門の向こうから、ヴォルガスの本体が睨んでいました。"},
            {speaker: "ギルドマスター", text: "深淵の門まで……これが最終局面だ。"},
            {speaker: "均衡の守護神", text: "均衡の存在を門まで守ってくれたのか……この存在は、ヴォルガスを永遠に封じる鍵だ。あの軍勢は、均衡を崩すためにすべてを破壊した。君たちの故郷が最初の犠牲だったのは、均衡の力がそこに宿っていたから。本当に感謝する。この均衡が、君たちを勝利に導く。"},
            {speaker: "ギルドマスター", text: "報酬だ。均衡を保つ力を。"}
        ],
        // 1: 時を司る神の使者を永遠の時計塔まで護衛（依頼主: 時の神）
        [
            {speaker: "冒険者", text: "時を司る神の使者を永遠の時計塔まで守りました。……時間が歪み、過去の惨劇が蘇りました。"},
            {speaker: "ギルドマスター", text: "時間が歪む……ヴォルガスが時すら操ろうとしているのか。"},
            {speaker: "時の神", text: "使者を時計塔まで無事に導いてくれたのか……この使者は、ヴォルガスの復活の時を止める存在だ。あの軍勢は、時間を改竄するために動いていた。君たちの故郷が破壊された瞬間を、永遠に繰り返すつもりだったのだろう。本当に感謝する。この時が、君たちに味方する。"},
            {speaker: "ギルドマスター", text: "報酬だ。時を超える力を。"}
        ],
        // 2: 全ての命の源を最終決戦の場まで護衛（依頼主: 命の母神）
        [
            {speaker: "冒険者", text: "全ての命の源を最終決戦の場まで護衛しました。……源の光が、ヴォルガスの闇を焼き払おうとしていました。"},
            {speaker: "ギルドマスター", text: "命の源……これがヴォルガスを滅ぼす最終の鍵か。"},
            {speaker: "命の母神", text: "命の源を決戦の場まで守ってくれたのか……この源は、ヴォルガスを生み出した闇を浄化する光だ。あの軍勢は、すべての命を闇に染めるために来た。君たちの故郷が狙われたのは、命の源の守りがそこにあったから。本当に感謝する。この命が、君たちと共に戦う。"},
            {speaker: "ギルドマスター", text: "報酬だ。すべての命を繋ぐ力を。"}
        ]
    ]
        
    },
    // 3: LUC - fetch quests
    {
        'F': [
            // 0: 薬草集め
            [
                {speaker: "冒険者", text: "錬金術師のために頼まれた薬草をしっかり集めてきました。"},
                {speaker: "ルナ", text: "この薬草、回復ポーションに最適ね！私も少し欲しいわ～。"},
                {speaker: "ギルドマスター", text: "ルナ、後で分けてやるから我慢しろ。錬金術師に見せてやろう。"},
                {speaker: "錬金術師", text: "薬草をちゃんと集めてきてくれたね！これで新しい薬が作れるよ。本当に助かる、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取ってくれ。ルナのポーション実験はまた今度な。"}
            ],
            // 1: キノコ集め
            [
                {speaker: "冒険者", text: "料理人に頼まれた新鮮なキノコを持ってきました。"},
                {speaker: "カイト", text: "キノコ！？今夜はキノコ鍋だろ！？俺、5杯はいけるぜ！"},
                {speaker: "ルナ", text: "カイト、食べすぎたらお腹壊すわよ。"},
                {speaker: "ギルドマスター", text: "二人とも食うことしか考えてないな。料理人に渡そう。"},
                {speaker: "料理人", text: "新鮮なキノコを持ってきてくれたか！今夜の料理が最高になるよ。みんな喜ぶぜ、感謝だ！"},
                {speaker: "ギルドマスター", text: "報酬だ。……夕飯はキノコ尽くしになりそうだな。"}
            ],
            // 2: 花集め
            [
                {speaker: "冒険者", text: "村人に頼まれたきれいな花を集めて届けました。"},
                {speaker: "ルナ", text: "この花、香りがとっても良いわ！ギルドに飾りましょうよ～。"},
                {speaker: "カイト", text: "花より団子だろ……って、ルナに怒られそうだから黙っとく。"},
                {speaker: "ギルドマスター", text: "たまには二人とも可愛いこと言うな。村人に感想を聞いてみよう。"},
                {speaker: "村人", text: "きれいな花を届けてくれたんだね！みんな笑顔になってるよ。君の優しさが伝わった、本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。ギルドが花畑みたいになりそうだ。"}
            ]
        ],
        'F+': [
            // 0: 鉄の欠片集め（依頼主: 鍛冶屋）
            [
                {speaker: "冒険者", text: "鍛冶屋のために鉄の欠片をしっかり集めてきました。……重かったです。"},
                {speaker: "カイト", text: "鉄！？いいねえ、俺の新しい剣作れるじゃん！少し分けてくれよ！"},
                {speaker: "ルナ", text: "カイト、また剣ばっかり……でも確かに良い素材ね。"},
                {speaker: "ギルドマスター", text: "二人とも後で分け前やるから我慢しろ。鍛冶屋に渡そう。"},
                {speaker: "鍛冶屋", text: "鉄の欠片をこんなに集めてくれたのか！これで良い武器が作れるよ。本当に助かる、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトの新剣はまた今度な。"}
            ],
            // 1: 川魚釣り（依頼主: 漁師）
            [
                {speaker: "冒険者", text: "漁師に頼まれた川魚を釣ってきました。……結構時間がかかりました。"},
                {speaker: "カイト", text: "魚！？今夜は焼き魚だろ！俺、10匹はいけるぜ！"},
                {speaker: "ルナ", text: "カイト、食べすぎ注意よ。でも新鮮そうで美味しそうね～。"},
                {speaker: "ギルドマスター", text: "二人とも夕飯の話ばっかりだな。漁師に渡そう。"},
                {speaker: "漁師", text: "川魚をこんなに釣ってきてくれたのか！今夜の食卓が豪華になるよ。感謝だ、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。……今夜は魚尽くしか。"}
            ],
            // 2: 普通の薬草集め（依頼主: 薬師）
            [
                {speaker: "冒険者", text: "薬師のために普通の薬草をたくさん集めてきました。"},
                {speaker: "ルナ", text: "普通の薬草でも調合次第で強力な薬になるのよ！私も研究したいわ～。"},
                {speaker: "カイト", text: "薬草より肉が欲しいぜ……って、ルナに睨まれた。"},
                {speaker: "ギルドマスター", text: "二人とも欲丸出しだな。薬師に見せてやろう。"},
                {speaker: "薬師", text: "普通の薬草をこんなに集めてくれたね！これで村の薬が十分になるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。ルナの実験台はカイトでいいな。"}
            ]
        ],
        'D': [
            // 0: 鉄鉱石（依頼主: 鉱夫）
            [
                {speaker: "冒険者", text: "鉱夫のために良質の鉄鉱石をたくさん採掘してきました。……腰が痛いです。"},
                {speaker: "カイト", text: "鉄鉱石！？俺なら岩ごとぶっ壊して全部持って帰ってたぜ！"},
                {speaker: "ルナ", text: "良質の鉱石なら魔法武器に使えるのに……少し欲しいわ。"},
                {speaker: "ギルドマスター", text: "二人とも後で分けてやる。鉱夫に渡そう。"},
                {speaker: "鉱夫", text: "良質の鉄鉱石をこんなに！これで村が潤うよ。本当に助かる、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトの破壊力は次回に取っとけ。"}
            ],
            // 1: 狼の毛皮（依頼主: ハンター）
            [
                {speaker: "冒険者", text: "ハンターに狼の毛皮をたくさん持ってきました。……狩りが大変でした。"},
                {speaker: "カイト", text: "狼の毛皮！？俺なら群れ全部狩って毛皮の山作ってたぜ！"},
                {speaker: "ルナ", text: "毛皮は防寒具に最適ね。私も一枚欲しいわ～。"},
                {speaker: "ギルドマスター", text: "二人とも欲深いな。ハンターに渡そう。"},
                {speaker: "ハンター", text: "狼の毛皮をこんなに！最高の防寒具が作れるよ。感謝だ、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は毛皮のコートでも作るか。"}
            ],
            // 2: 魔力の結晶（小）（依頼主: 魔術師）
            [
                {speaker: "冒険者", text: "魔術師に魔力の結晶（小）を集めてきました。……魔物が守ってて危なかったです。"},
                {speaker: "ルナ", text: "魔力の結晶！？私の魔法研究にぴったり！少し分けて～。"},
                {speaker: "カイト", text: "魔物なら俺が全部ぶった斬って結晶独り占めだぜ！"},
                {speaker: "ギルドマスター", text: "二人とも我慢しろ。魔術師に見せてやろう。"},
                {speaker: "魔術師", text: "魔力の結晶をこんなに集めてくれたのか！新しい魔法が開発できるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。ルナの実験はまた今度な。"}
            ]
        ],
        'D+': [
            // 0: オークの牙（依頼主: 武器商人）
            [
                {speaker: "冒険者", text: "オークの牙をたくさん持ってきました。……戦いが激しくて疲れました。"},
                {speaker: "カイト", text: "オークの牙！？俺なら全部引き抜いてトロフィーにしてたぜ！"},
                {speaker: "ルナ", text: "牙は毒抜きに使えるわ……研究したいわね。"},
                {speaker: "ギルドマスター", text: "二人とも後でな。武器商人に渡そう。"},
                {speaker: "武器商人", text: "オークの牙をこんなに！強力な武器が作れるよ。本当に助かる、ありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトのトロフィーは次回に。"}
            ],
            // 1: 古代の巻物断片（依頼主: 賢者）
            [
                {speaker: "冒険者", text: "古代の巻物断片を集めてきました。……遺跡の罠が厄介でした。"},
                {speaker: "ルナ", text: "古代巻物！？私の本にない知識かも！早く見せて～！"},
                {speaker: "ギルドマスター", text: "ルナ、興奮しすぎ。賢者に渡そう。"},
                {speaker: "賢者", text: "古代の巻物断片をこんなに！失われた知識が蘇るよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。ルナの読書会はまた今度。"}
            ],
            // 2: 希少スパイス（依頼主: 美食家）
            [
                {speaker: "冒険者", text: "希少スパイスを届けてきました。……遠くまで行って疲れました。"},
                {speaker: "カイト", text: "スパイス！？今夜は激辛料理だろ！俺、20皿いけるぜ！"},
                {speaker: "ルナ", text: "カイト、食べすぎて火を噴くわよ。でも香りが良さそうね。"},
                {speaker: "ギルドマスター", text: "二人とも夕飯の話ばっかり。美食家に渡そう。"},
                {speaker: "美食家", text: "希少スパイスを持ってきてくれたのか！究極の料理が作れるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。……今夜は辛い夕飯になりそうだ。"}
            ]
        ],
        'C': [
            // 0: グリフォンの羽（依頼主: 貴族）
            [
                {speaker: "冒険者", text: "グリフォンの羽をたくさん持ってきました。……空戦が怖かったです。"},
                {speaker: "ルナ", text: "グリフォンの羽！？飛翔魔法の素材に最高ね！私も欲しいわ～。"},
                {speaker: "カイト", text: "グリフォンか！俺なら乗りこなしてたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも落ち着け。貴族に渡そう。"},
                {speaker: "貴族", text: "グリフォンの羽をこんなに！豪華な装飾が作れるよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はルナが飛ぶかもな。"}
            ],
            // 1: ヒドラの毒袋（依頼主: 大魔導士）
            [
                {speaker: "冒険者", text: "ヒドラの毒袋を集めてきました。……再生が早くて大変でした。"},
                {speaker: "ルナ", text: "ヒドラの毒！？強力な毒薬が作れるわ！研究させて～。"},
                {speaker: "カイト", text: "ヒドラか！俺なら全部の頭をぶった斬ってたぜ！"},
                {speaker: "ギルドマスター", text: "二人とも毒は扱うな。大魔導士に渡そう。"},
                {speaker: "大魔導士", text: "ヒドラの毒袋をこんなに！禁断の魔法薬が完成するよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。毒実験はルナ禁止な。"}
            ],
            // 2: 聖水（依頼主: 神殿長）
            [
                {speaker: "冒険者", text: "神殿に聖水をたくさん届けてきました。……聖地が遠かったです。"},
                {speaker: "ルナ", text: "聖水！？浄化魔法に最適ね。私も少し欲しいわ～。"},
                {speaker: "カイト", text: "聖水なら俺の剣を聖剣にできるだろ！かけてくれよ！"},
                {speaker: "ギルドマスター", text: "二人とも神聖なものを遊び道具にするな。神殿長に渡そう。"},
                {speaker: "神殿長", text: "聖水をこんなに届けてくれたのか！神殿が救われたよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトの剣は普通のままでいい。"}
            ]
        ],
            // 3: LUC - fetch quests (C+ to B+)
    
        'C+': [
            // 0: ユニコーンの角（依頼主: 王宮錬金術師）
            [
                {speaker: "冒険者", text: "王宮のためにユニコーンの角を{qty}個持ってきました。……純粋な光がまぶしかったです。"},
                {speaker: "ルナ", text: "ユニコーンの角！？最強の浄化素材ね！私も少し欲しいわ～！"},
                {speaker: "カイト", text: "角か！俺なら剣の柄に使って最強の剣作るぜ！"},
                {speaker: "ギルドマスター", text: "二人とも角を欲しがるな。王宮錬金術師に渡そう。"},
                {speaker: "王宮錬金術師", text: "ユニコーンの角をこんなに集めてくれたのか！究極の薬が作れるよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は角で二人を突き刺さないでくれ。"}
            ],
            // 1: 禁断の魔導書頁（依頼主: 禁書庫管理人）
            [
                {speaker: "冒険者", text: "禁書庫に禁断の魔導書頁を{qty}枚集めてきました。……呪いが染みついて怖かったです。"},
                {speaker: "ルナ", text: "禁断の頁！？私の研究にぴったり！早く読ませて～！"},
                {speaker: "カイト", text: "禁断の本か！俺なら剣でページめくってたぜ！"},
                {speaker: "ギルドマスター", text: "ルナ、呪われるな。カイト、本は斬るな。管理人に渡そう。"},
                {speaker: "禁書庫管理人", text: "禁断の頁をこんなに！失われた知識が戻るよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次はルナの禁書読書は監視付きな。"}
            ],
            // 2: フェニックスの灰（依頼主: 錬金大师）
            [
                {speaker: "冒険者", text: "錬金大师にフェニックスの灰を{qty}握り持ってきました。……熱くて火傷しそうです。"},
                {speaker: "ルナ", text: "フェニックスの灰！？不死の秘薬の材料ね！研究させて～！"},
                {speaker: "カイト", text: "灰か！俺なら剣に塗って炎の剣作るぜ！"},
                {speaker: "ギルドマスター", text: "二人とも灰を遊び道具にするな。大师に渡そう。"},
                {speaker: "錬金大师", text: "フェニックスの灰をこんなに集めてくれたのか！伝説の錬金が完成するよ。本当に助かった！"},
                {speaker: "ギルドマスター", text: "報酬だ。次は火傷しないよう気をつけろ。"}
            ]
        ],
        'B': [
            // 0: 星の欠片（依頼主: 大賢者）
            [
                {speaker: "冒険者", text: "大賢者に星の欠片を{qty}個集めてきました。……星の力が体に染みました。"},
                {speaker: "ルナ", text: "星の欠片！？宇宙魔法の究極素材ね！私も触りたかったわ～！"},
                {speaker: "カイト", text: "星か！俺なら剣に埋めて星斬りだぜ！"},
                {speaker: "ギルドマスター", text: "二人とも星を壊すな。大賢者に渡そう。"},
                {speaker: "大賢者", text: "星の欠片をこんなに！星の叡智が蘇るよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は星を剣に埋めないでくれ。"}
            ],
            // 1: 天使の羽（依頼主: 神官）
            [
                {speaker: "冒険者", text: "神官に天使の羽を{qty}枚持ってきました。……神聖な光がまぶしかったです。"},
                {speaker: "ルナ", text: "天使の羽！？飛翔と浄化の両方ね！研究したいわ～！"},
                {speaker: "カイト", text: "羽か！俺なら背中に付けて空飛ぶぜ！"},
                {speaker: "ギルドマスター", text: "カイト、天使じゃないだろ。神官に渡そう。"},
                {speaker: "神官", text: "天使の羽をこんなに集めてくれたのか！神の奇跡が近づくよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬だ。次はカイトが飛ばないよう祈っとく。"}
            ],
            // 2: デーモンの心臓（依頼主: 闇市場の取引人）
            [
                {speaker: "冒険者", text: "闇市場にデーモンの心臓を{qty}個届けてきました。……闇の脈動が怖かったです。"},
                {speaker: "ルナ", text: "デーモンの心臓！？闇魔法の究極源ね！少しだけ研究させて……。"},
                {speaker: "カイト", text: "心臓か！俺なら剣で貫いて止めてたぜ！"},
                {speaker: "ギルドマスター", text: "ルナ、闇に染まるな。取引人に渡そう。"},
                {speaker: "闇市場取引人", text: "デーモンの心臓をこんなに！闇の取引が成立するよ。本当に助かった……ふふふ。"},
                {speaker: "ギルドマスター", text: "報酬だ。次は闇市場は控えめに。"}
            ]
        ],
        'B+': [
            // 0: 古代ドラゴンの鱗（依頼主: 王国鍛冶師）
            [
                {speaker: "冒険者", text: "王に古代ドラゴンの鱗を{qty}枚持ってきました。……硬くて運ぶの大変でした。"},
                {speaker: "カイト", text: "ドラゴンの鱗！？俺の剣より硬いのか！？次は俺が剥ぎ取るぜ！"},
                {speaker: "ルナ", text: "古代鱗は最強の防具素材ね！私も少し欲しいわ～。"},
                {speaker: "ギルドマスター", text: "二人とも鱗を欲しがるな。王国鍛冶師に渡そう。"},
                {speaker: "王国鍛冶師", text: "古代ドラゴンの鱗をこんなに！伝説の鎧が作れるよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。カイトの新鎧はまた今度な。"}
            ],
            // 1: エーテルの結晶（依頼主: 最高魔導士）
            [
                {speaker: "冒険者", text: "最高魔導士にエーテルの結晶を{qty}個集めてきました。……純粋な魔力が溢れてました。"},
                {speaker: "ルナ", text: "エーテルの結晶！？究極の魔力源ね！私の魔法が100倍になるわ～！"},
                {speaker: "カイト", text: "結晶か！俺なら剣に埋めて魔剣作るぜ！"},
                {speaker: "ギルドマスター", text: "二人とも結晶を私物化するな。最高魔導士に渡そう。"},
                {speaker: "最高魔導士", text: "エーテルの結晶をこんなに！禁断の魔法が解禁されるよ。本当にありがとう！"},
                {speaker: "ギルドマスター", text: "報酬を受け取れ。次は禁断魔法は禁止な。"}
            ],
            // 2: 神の涙（依頼主: 神殿大司教）
            [
                {speaker: "冒険者", text: "神殿に神の涙を{qty}滴届けてきました。……奇跡の力が感じられました。"},
                {speaker: "ルナ", text: "神の涙！？究極の浄化と再生ね！研究させてほしいわ～！"},
                {speaker: "カイト", text: "涙か！俺なら剣に塗って聖剣だぜ！"},
                {speaker: "ギルドマスター", text: "二人とも神聖なものを遊び道具にするな。大司教に渡そう。"},
                {speaker: "神殿大司教", text: "神の涙をこんなに届けてくれたのか！神の奇跡が降臨するよ。本当に感謝する！"},
                {speaker: "ギルドマスター", text: "報酬だ。神の涙で剣を洗うなよ。"}
            ]
        ],
        'A': [
        // 0: タイタンの骨（依頼主: 大地の古王）
        [
            {speaker: "冒険者", text: "伝説の英雄のためにタイタンの骨を{qty}本持ってきました。……骨に刻まれた呪文が、ヴォルガスの名を呪っていました。"},
            {speaker: "ギルドマスター", text: "タイタンの骨がヴォルガスを呪う……古の巨人が彼を知っていたのか。"},
            {speaker: "大地の古王", text: "タイタンの骨を……この骨は、ヴォルガスを封じた古の戦いの遺物だ。あの黒い軍勢は、大地の力を奪うために巨人を操っていた。君たちの故郷が破壊されたのは、大地の古き守りがそこにあったからだろう。本当に感謝する。この骨が、英雄の武器となり、闇を砕く。"},
            {speaker: "ギルドマスター", text: "報酬だ。大地のように不動の力を。"}
        ],
        // 1: 永遠の炎（依頼主: 炎の永遠なる守護者）
        [
            {speaker: "冒険者", text: "究極の錬金術師に永遠の炎を{qty}握り集めてきました。……炎の中に、深淵の影が揺らめいていました。"},
            {speaker: "ギルドマスター", text: "永遠の炎に影……ヴォルガスが炎すら蝕もうとしているのか。"},
            {speaker: "炎の永遠なる守護者", text: "永遠の炎を……この炎は、ヴォルガスの闇を焼く唯一の火だ。あの軍勢は、炎を消すために世界を焼き払おうとした。君たちの村が最初の炎の守りだったのかもしれない。本当に感謝する。この炎が、君たちの復讐を燃やす。"},
            {speaker: "ギルドマスター", text: "報酬だ。永遠に燃える力を。"}
        ],
        // 2: 神聖な遺物（依頼主: 神々の代弁者）
        [
            {speaker: "冒険者", text: "神々に神聖な遺物を{qty}個届けてきました。……遺物が、ヴォルガスの闇を拒絶していました。"},
            {speaker: "ギルドマスター", text: "神聖な遺物が闇を拒絶……神々がまだ戦っている証か。"},
            {speaker: "神々の代弁者", text: "神聖な遺物を……これは、ヴォルガスを封じた神々の力の欠片だ。あの軍勢は、神の遺物を破壊するために動いていた。君たちの故郷が狙われたのは、神の遺児の守りがそこにあったから。本当に感謝する。この遺物が、神々の意志を君たちに託す。"},
            {speaker: "ギルドマスター", text: "報酬だ。神々に選ばれた力を。"}
        ]
    ],
    'A+': [
        // 0: エルダードラゴンの心臓（依頼主: 世界の守護者）
        [
            {speaker: "冒険者", text: "世界の守護者にエルダードラゴンの心臓を{qty}個持ってきました。……心臓が、ヴォルガスの闇で脈打っていました。"},
            {speaker: "ギルドマスター", text: "エルダードラゴンの心臓が闇で……ヴォルガスが最古の竜すら支配したのか。"},
            {speaker: "世界の守護者", text: "エルダードラゴンの心臓を……この心臓は、ヴォルガスの闇を宿す最強の力だ。あの軍勢は、心臓を集めて完全復活を果たすつもりだった。君たちの村が破壊されたのは、心臓の守りの結界がそこにあったから。本当に感謝する。この心臓が、闇を滅ぼす鍵となる。"},
            {speaker: "ギルドマスター", text: "報酬だ。世界を守る力を。"}
        ],
        // 1: 深淵の核（依頼主: 禁断の研究者）
        [
            {speaker: "冒険者", text: "禁断の研究者に深淵の核を{qty}個集めてきました。……核が、ヴォルガスの本体の欠片のように感じられました。"},
            {speaker: "ギルドマスター", text: "深淵の核が本体の一部……これが復活の核心か。"},
            {speaker: "禁断の研究者", text: "深淵の核を……これは、ヴォルガス自身の欠片だ。あの軍勢は、核を集めて本体を再構築しようとしていた。君たちの故郷が最初の標的だったのは、核の封印がそこにあったから。本当に感謝する。この核が、ヴォルガスを内側から崩す。"},
            {speaker: "ギルドマスター", text: "報酬だ。深淵を内側から破壊する力を。"}
        ],
        // 2: 光の神器の欠片（依頼主: 最後の希望の守護者）
        [
            {speaker: "冒険者", text: "最後の希望に光の神器の欠片を{qty}個届けてきました。……欠片が、ヴォルガスの闇を浄化しようと輝いていました。"},
            {speaker: "ギルドマスター", text: "光の神器……これがヴォルガスを滅ぼす最終の武器か。"},
            {speaker: "最後の希望の守護者", text: "光の神器の欠片を……これは、ヴォルガスを永遠に封じる神器の欠片だ。あの軍勢は、神器を破壊するためにすべてを焼き払った。君たちの村が狙われたのは、神器の守りがそこにあったから。本当に感謝する。この欠片が、希望を再び灯す。"},
            {speaker: "ギルドマスター", text: "報酬だ。最後の希望を叶える力を。"}
        ]
    ],
    'S': [
        // 0: 世界の源石（依頼主: 運命の織り手）
        [
            {speaker: "冒険者", text: "運命に世界の源石を{qty}個持ってきました。……源石が、世界の終わりを予感させていました。"},
            {speaker: "ギルドマスター", text: "世界の源石……これがヴォルガスの起源か。"},
            {speaker: "運命の織り手", text: "世界の源石を……これは、ヴォルガスが生まれた世界の根源だ。あの軍勢は、源石を集めて世界を闇に染めようとした。君たちの故郷が破壊されたのは、源石の守りの糸がそこに紡がれていたから。本当に感謝する。この源石が、運命を書き換える。"},
            {speaker: "ギルドマスター", text: "報酬だ。運命を織り直す力を。"}
        ],
        // 1: 創世の欠片（依頼主: 神々に創世の守護者）
        [
            {speaker: "冒険者", text: "神々に創世の欠片を{qty}個集めてきました。……欠片が、ヴォルガスの闇を生んだ瞬間を映していました。"},
            {speaker: "ギルドマスター", text: "創世の欠片が闇を生んだ……すべてはここから始まったのか。"},
            {speaker: "創世の守護者", text: "創世の欠片を……これは、神々が世界を生んだ欠片であり、ヴォルガスが生まれた闇の欠片でもある。あの軍勢は、欠片を集めて創世を闇に塗り替えるつもりだった。君たちの村が最初の光だったから狙われた。本当に感謝する。この欠片が、新たな創世を始める。"},
            {speaker: "ギルドマスター", text: "報酬だ。創世を新たにする力を。"}
        ],
        // 2: 滅びの結晶（依頼主: 終焉の使者）
        [
            {speaker: "冒険者", text: "終焉の使者に滅びの結晶を{qty}個届けてきました。……結晶が、ヴォルガスの最終形態を示していました。"},
            {speaker: "ギルドマスター", text: "滅びの結晶……これがヴォルガスの終焉か、我々の終焉か。"},
            {speaker: "終焉の使者", text: "滅びの結晶を……これは、ヴォルガスがもたらす世界の終わりを結晶化したものだ。あの軍勢は、結晶を集めて終焉を早めようとした。君たちの村が破壊されたのは、終焉を遅らせる希望がそこにあったから。本当に感謝する。この結晶が、終焉をヴォルガス自身に返す。"},
            {speaker: "ギルドマスター", text: "報酬だ。終焉を終わらせる力を。"}
        ]
    ]
    
        
    }
];


const cities = [
    {name: "セントラルシティ", guild: true},
    {name: "鉱山の街ドラゴラ", items: [{name: "鉄鉱石", minPrice: 20, maxPrice: 40}]},
    {name: "農村エルグリーン", items: [{name: "薬草", minPrice: 10, maxPrice: 30}]},
    {name: "商人の街バザリア", items: [{name: "スパイス", minPrice: 40, maxPrice: 70}]},
    {name: "宝石の街クリスタリス", items: [{name: "宝石", minPrice: 80, maxPrice: 150}]}
];

// 修正版錬金レシピ：全outputに minPrice/maxPrice を追加（sellPrice削除）
// 計算基準：元sellPriceの平均値として min=avg*0.78, max=avg*1.22（fetchクエストspread~50-60%に一致）
// 手動微調整でnice number化（例:45→35-55, 80→60-100）
// ゲームsell logic: random(min, max) で変動売却（fetchアイテムと統一）
// チェイン利益: 低→高で1.5-2x 増加（クエスト報酬回転→爆益）

const alchemyRecipes = [
    // === 既存 + F/F+ (レベル1: 序盤基本合成) ===
    {level: 1, inputs: ["薬草", "鉄鉱石"], output: {name: "鋼のインゴット", type: "material", minPrice: 60, maxPrice: 100}},
    {level: 1, inputs: ["スパイス", "薬草"], output: {name: "活力の粉", type: "material", minPrice: 35, maxPrice: 55}},
    {level: 1, inputs: ["宝石", "活力の粉"], output: {name: "魔法の結晶", type: "material", minPrice: 140, maxPrice: 220}},
    {level: 1, inputs: ["鉄鉱石", "スパイス"], output: {name: "炎の粉", type: "material", minPrice: 50, maxPrice: 80}},
    {level: 1, inputs: ["薬草", "活力の粉"], output: {name: "上級HPポーション", type: "potion", restore: "hp", amount: 60, minPrice: 120, maxPrice: 180}},
    {level: 1, inputs: ["魔法の結晶", "スパイス"], output: {name: "上級MPポーション", type: "potion", restore: "mp", amount: 45, minPrice: 95, maxPrice: 145}},

    {level: 1, inputs: ["キノコ", "薬草"], output: {name: "キノコ回復薬", type: "potion", restore: "hp", amount: 25, minPrice: 35, maxPrice: 55}},
    {level: 1, inputs: ["花", "普通の薬草"], output: {name: "花の霊薬", type: "potion", restore: "mp", amount: 20, minPrice: 25, maxPrice: 45}},
    {level: 1, inputs: ["川魚", "キノコ"], output: {name: "魚介滋養スープ", type: "potion", restore: "hp", amount: 35, minPrice: 50, maxPrice: 80}},
    {level: 1, inputs: ["鉄の欠片", "薬草"], output: {name: "鉄草合金粉", type: "material", minPrice: 40, maxPrice: 70}},
    {level: 1, inputs: ["花", "キノコ"], output: {name: "森のエキス", type: "material", minPrice: 25, maxPrice: 45}},

    // === D/D+ (レベル2: 中盤強化) ===
    {level: 2, inputs: ["狼の毛皮", "活力の粉"], output: {name: "獣活力軟膏", type: "potion", restore: "hp", amount: 45, minPrice: 85, maxPrice: 135}},
    {level: 2, inputs: ["魔力の結晶（小）", "花の霊薬"], output: {name: "小魔力ポーション", type: "potion", restore: "mp", amount: 35, minPrice: 75, maxPrice: 115}},
    {level: 2, inputs: ["鉄の欠片", "鉄鉱石"], output: {name: "精鉄インゴット", type: "material", minPrice: 75, maxPrice: 115}},
    {level: 2, inputs: ["狼の毛皮", "森のエキス"], output: {name: "獣皮エキス", type: "material", minPrice: 80, maxPrice: 130}},

    {level: 2, inputs: ["オークの牙", "鋼のインゴット"], output: {name: "牙鋼インゴット", type: "material", minPrice: 170, maxPrice: 270}},
    {level: 2, inputs: ["古代の巻物断片", "魔力の結晶（小）"], output: {name: "古魔導粉", type: "material", minPrice: 150, maxPrice: 240}},
    {level: 2, inputs: ["希少スパイス", "上級HPポーション"], output: {name: "スパイシー超HP薬", type: "potion", restore: "hp", amount: 80, minPrice: 250, maxPrice: 390}},
    {level: 2, inputs: ["希少スパイス", "薬草"], output: {name: "希少活力粉", type: "material", minPrice: 105, maxPrice: 165}},

    // === C/C+ (レベル3: 後半高級合成) ===
    {level: 3, inputs: ["グリフォンの羽", "魔法の結晶"], output: {name: "風翼結晶", type: "material", minPrice: 380, maxPrice: 580}},
    {level: 3, inputs: ["ヒドラの毒袋", "聖水"], output: {name: "解毒聖水", type: "potion", restore: "hp", amount: 90, minPrice: 460, maxPrice: 700}},
    {level: 3, inputs: ["聖水", "古魔導粉"], output: {name: "聖魔導結晶", type: "material", minPrice: 410, maxPrice: 630}},
    {level: 3, inputs: ["グリフォンの羽", "森のエキス"], output: {name: "天空エキス", type: "potion", restore: "mp", amount: 70, minPrice: 245, maxPrice: 375}},

    {level: 3, inputs: ["ユニコーンの角", "聖水"], output: {name: "ユニコーン浄化薬", type: "potion", restore: "hp", amount: 120, minPrice: 650, maxPrice: 990}},
    {level: 3, inputs: ["禁断の魔導書頁", "聖魔導結晶"], output: {name: "禁断魔導晶", type: "material", minPrice: 860, maxPrice: 1300}},
    {level: 3, inputs: ["フェニックスの灰", "炎の粉"], output: {name: "不死鳥炎粉", type: "material", minPrice: 620, maxPrice: 940}},
    {level: 3, inputs: ["星の欠片", "風翼結晶"], output: {name: "星風ポーション", type: "potion", restore: "mp", amount: 100, minPrice: 890, maxPrice: 1350}},
    {level: 3, inputs: ["天使の羽", "解毒聖水"], output: {name: "天使癒薬", type: "potion", restore: "hp", amount: 140, minPrice: 1020, maxPrice: 1540}},
    {level: 3, inputs: ["デーモンの心臓", "希少活力粉"], output: {name: "魔心活力剤", type: "potion", restore: "mp", amount: 110, minPrice: 780, maxPrice: 1180}},

    // === B+/A + A+/S + 究極 (レベル4: エンドコンテンツ至高合成) ===
    {level: 4, inputs: ["古代ドラゴンの鱗", "牙鋼インゴット"], output: {name: "龍鋼装甲材", type: "material", minPrice: 1580, maxPrice: 2380}},
    {level: 4, inputs: ["エーテルの結晶", "禁断魔導晶"], output: {name: "エーテル魔晶", type: "material", minPrice: 1980, maxPrice: 2980}},
    {level: 4, inputs: ["神の涙", "天使癒薬"], output: {name: "神涙神薬", type: "potion", restore: "hp", amount: 200, minPrice: 1900, maxPrice: 2860}},
    {level: 4, inputs: ["タイタンの骨", "精鉄インゴット"], output: {name: "巨神骨鋼", type: "material", minPrice: 1740, maxPrice: 2620}},
    {level: 4, inputs: ["永遠の炎", "不死鳥炎粉"], output: {name: "永劫炎粉", type: "material", minPrice: 1660, maxPrice: 2500}},
    {level: 4, inputs: ["神聖な遺物", "聖魔導結晶"], output: {name: "神聖遺晶", type: "material", minPrice: 1820, maxPrice: 2740}},

    {level: 4, inputs: ["エルダードラゴンの心臓", "龍鋼装甲材"], output: {name: "古龍心鋼", type: "material", minPrice: 3660, maxPrice: 5500}},
    {level: 4, inputs: ["深淵の核", "エーテル魔晶"], output: {name: "深淵エーテル晶", type: "material", minPrice: 4220, maxPrice: 6340}},
    {level: 4, inputs: ["光の神器の欠片", "神聖遺晶"], output: {name: "光神器晶", type: "material", minPrice: 3980, maxPrice: 5980}},
    {level: 4, inputs: ["世界の源石", "神涙神薬"], output: {name: "世界源神薬", type: "potion", restore: "hp", amount: 500, minPrice: 5580, maxPrice: 8380}},
    {level: 4, inputs: ["創世の欠片", "星風ポーション"], output: {name: "創世魔力薬", type: "potion", restore: "mp", amount: 400, minPrice: 5020, maxPrice: 7540}},
    {level: 4, inputs: ["滅びの結晶", "永劫炎粉"], output: {name: "終焉破壊粉", type: "material", minPrice: 4700, maxPrice: 7060}},

    {level: 4, inputs: ["世界の源石", "創世の欠片"], output: {name: "創世源ポーション", type: "potion", restore: "hp", amount: 999, minPrice: 10240, maxPrice: 15360}},
    {level: 4, inputs: ["滅びの結晶", "深淵の核"], output: {name: "滅び深淵晶", type: "material", minPrice: 9440, maxPrice: 14160}}
];

const tavernRecipes = [
    // === 既存レシピ（保持・拡張） ===
    {level: 1, name: "力のスープ", buff: {stat: "strength", percent: true, bonus: 20, days: 5}, cost: 250, materials: []},
    {level: 2, name: "巨人の煮込み", buff: {stat: "strength", percent: true, bonus: 40, days: 7}, cost: 800, materials: [{name: "活力の粉", qty: 2}]},
    {level: 1, name: "知恵の茶", buff: {stat: "wisdom", percent: true, bonus: 20, days: 5}, cost: 250, materials: []},
    {level: 2, name: "予言者の飲料", buff: {stat: "wisdom", percent: true, bonus: 40, days: 7}, cost: 800, materials: [{name: "魔法の結晶", qty: 1}]},
    {level: 1, name: "回復のパン", buff: {type: "hpRegen", bonus: 15, days: 3}, cost: 200, materials: []},

    // === STR料理（肉/骨/ドラゴン系）：活力・獣・龍素材チェイン ===
    {level: 3, name: "獣肉の活力シチュー", buff: {stat: "strength", percent: true, bonus: 60, days: 10}, cost: 1800, materials: [{name: "獣皮エキス", qty: 2}, {name: "狼の毛皮", qty: 1}]},
    {level: 5, name: "牙鋼の力強煮込み", buff: {stat: "strength", percent: true, bonus: 90, days: 14}, cost: 4200, materials: [{name: "牙鋼インゴット", qty: 2}, {name: "オークの牙", qty: 2}]},
    {level: 7, name: "龍鋼の巨竜ステーキ", buff: {stat: "strength", percent: true, bonus: 130, days: 20}, cost: 7800, materials: [{name: "龍鋼装甲材", qty: 3}, {name: "古代ドラゴンの鱗", qty: 2}]},
    {level: 9, name: "巨神骨の力の饗宴", buff: {stat: "strength", percent: true, bonus: 180, days: 25}, cost: 12800, materials: [{name: "巨神骨鋼", qty: 3}, {name: "タイタンの骨", qty: 2}]},
    {level: 11, name: "古龍心の覇王料理", buff: {stat: "strength", percent: true, bonus: 260, days: 30}, cost: 24800, materials: [{name: "古龍心鋼", qty: 4}, {name: "エルダードラゴンの心臓", qty: 1}]},

    // === WIS料理（魔法/聖水系）：結晶・禁断・エーテル素材チェイン ===
    {level: 3, name: "森の霊薬ティー", buff: {stat: "wisdom", percent: true, bonus: 60, days: 10}, cost: 1800, materials: [{name: "森のエキス", qty: 3}]},
    {level: 5, name: "聖魔導の浄化茶", buff: {stat: "wisdom", percent: true, bonus: 90, days: 14}, cost: 4200, materials: [{name: "聖魔導結晶", qty: 3}, {name: "聖水", qty: 2}]},
    {level: 7, name: "禁断魔導の秘酒", buff: {stat: "wisdom", percent: true, bonus: 130, days: 20}, cost: 7800, materials: [{name: "禁断魔導晶", qty: 3}, {name: "禁断の魔導書頁", qty: 2}]},
    {level: 9, name: "エーテル魔晶の神酒", buff: {stat: "wisdom", percent: true, bonus: 180, days: 25}, cost: 12800, materials: [{name: "エーテル魔晶", qty: 4}, {name: "エーテルの結晶", qty: 2}]},
    {level: 11, name: "深淵の叡智スープ", buff: {stat: "wisdom", percent: true, bonus: 260, days: 30}, cost: 24800, materials: [{name: "深淵エーテル晶", qty: 4}, {name: "深淵の核", qty: 1}]},

    // === DEX料理（魚/羽/風系）：敏捷・天空素材チェイン ===
    {level: 1, name: "川魚の軽やか焼き", buff: {stat: "dexterity", percent: true, bonus: 20, days: 5}, cost: 250, materials: [{name: "川魚", qty: 2}]},
    {level: 3, name: "風翼の迅鳥シチュー", buff: {stat: "dexterity", percent: true, bonus: 60, days: 10}, cost: 1800, materials: [{name: "風翼結晶", qty: 2}, {name: "グリフォンの羽", qty: 2}]},
    {level: 5, name: "ユニコーンの敏捷サラダ", buff: {stat: "dexterity", percent: true, bonus: 90, days: 14}, cost: 4200, materials: [{name: "ユニコーンの角", qty: 2}, {name: "花", qty: 3}]},
    {level: 7, name: "天使の軽羽パイ", buff: {stat: "dexterity", percent: true, bonus: 130, days: 20}, cost: 7800, materials: [{name: "天使の羽", qty: 3}, {name: "天空エキス", qty: 2}]},
    {level: 9, name: "神聖迅撃の料理", buff: {stat: "dexterity", percent: true, bonus: 180, days: 25}, cost: 12800, materials: [{name: "神聖遺晶", qty: 3}, {name: "神聖な遺物", qty: 2}]},
    {level: 11, name: "創世の風神料理", buff: {stat: "dexterity", percent: true, bonus: 260, days: 30}, cost: 24800, materials: [{name: "創世の欠片", qty: 2}, {name: "風翼結晶", qty: 4}]},

    // === LUC料理（スパイス/星/不死鳥系）：幸運・炎・神涙素材チェイン ===
    {level: 1, name: "希少スパイスの幸運煮", buff: {stat: "luck", percent: true, bonus: 20, days: 5}, cost: 250, materials: [{name: "希少スパイス", qty: 1}]},
    {level: 3, name: "星の幸運デザート", buff: {stat: "luck", percent: true, bonus: 60, days: 10}, cost: 1800, materials: [{name: "星の欠片", qty: 2}]},
    {level: 5, name: "不死鳥の再生ケーキ", buff: {stat: "luck", percent: true, bonus: 90, days: 14}, cost: 4200, materials: [{name: "不死鳥炎粉", qty: 3}, {name: "フェニックスの灰", qty: 2}]},
    {level: 7, name: "神涙の福運スープ", buff: {stat: "luck", percent: true, bonus: 130, days: 20}, cost: 7800, materials: [{name: "神の涙", qty: 2}, {name: "永劫炎粉", qty: 2}]},
    {level: 9, name: "終焉の幸運饗宴", buff: {stat: "luck", percent: true, bonus: 180, days: 25}, cost: 12800, materials: [{name: "終焉破壊粉", qty: 3}, {name: "滅びの結晶", qty: 2}]},
    {level: 11, name: "滅び深淵の神運料理", buff: {stat: "luck", percent: true, bonus: 260, days: 30}, cost: 24800, materials: [{name: "滅び深淵晶", qty: 4}, {name: "世界の源石", qty: 1}]},

    // === 回復/再生系（HP/MP再生強化） ===
    {level: 2, name: "キノコの活力パン", buff: {type: "hpRegen", bonus: 30, days: 5}, cost: 600, materials: [{name: "キノコ", qty: 3}]},
    {level: 4, name: "解毒聖水の癒しスープ", buff: {type: "hpRegen", bonus: 60, days: 10}, cost: 2500, materials: [{name: "解毒聖水", qty: 2}]},
    {level: 6, name: "天使癒薬の神パン", buff: {type: "hpRegen", bonus: 100, days: 15}, cost: 5500, materials: [{name: "天使癒薬", qty: 2}]},
    {level: 8, name: "神涙神薬の至高スープ", buff: {type: "hpRegen", bonus: 150, days: 20}, cost: 9800, materials: [{name: "神涙神薬", qty: 1}]},
    {level: 10, name: "世界源神薬の永遠パン", buff: {type: "hpRegen", bonus: 250, days: 30}, cost: 16800, materials: [{name: "世界源神薬", qty: 1}]},

    {level: 3, name: "小魔力ポーションの魔茶", buff: {type: "mpRegen", bonus: 30, days: 8}, cost: 1500, materials: [{name: "小魔力ポーション", qty: 2}]},
    {level: 6, name: "星風ポーションの星茶", buff: {type: "mpRegen", bonus: 80, days: 15}, cost: 5200, materials: [{name: "星風ポーション", qty: 2}]},
    {level: 9, name: "創世魔力薬の神酒", buff: {type: "mpRegen", bonus: 150, days: 25}, cost: 11800, materials: [{name: "創世魔力薬", qty: 1}]},

    // === 究極バフ料理（エンドコンテンツ） ===
    {level: 12, name: "創世源の神饗宴", buff: {stat: "strength", percent: true, bonus: 400, days: 60}, cost: 45000, materials: [{name: "創世源ポーション", qty: 1}, {name: "古龍心鋼", qty: 4}]},
    {level: 12, name: "世界源の叡智宴", buff: {stat: "wisdom", percent: true, bonus: 400, days: 60}, cost: 45000, materials: [{name: "世界源神薬", qty: 1}, {name: "光神器晶", qty: 4}]},
    {level: 12, name: "終焉の迅神料理", buff: {stat: "dexterity", percent: true, bonus: 400, days: 60}, cost: 45000, materials: [{name: "創世魔力薬", qty: 1}, {name: "神聖遺晶", qty: 4}]},
    {level: 12, name: "源石の永運饗宴", buff: {stat: "luck", percent: true, bonus: 400, days: 60}, cost: 45000, materials: [{name: "世界源神薬", qty: 1}, {name: "滅び深淵晶", qty: 4}]}
];

const blacksmithRecipes = [
    // === 既存レシピ（保持・拡張） ===
    {level: 1, name: "上級の剣", stat: "strength", bonus: 12, cost: 400, materials: []},
    {level: 2, name: "鋼鉄の剣", stat: "strength", bonus: 25, cost: 1200, materials: [{name: "鋼のインゴット", qty: 3}]},
    {level: 4, name: "ドラゴンスレイヤー", stat: "strength", bonus: 45, cost: 3000, materials: [{name: "魔法の結晶", qty: 2}, {name: "鋼のインゴット", qty: 5}]},
    {level: 1, name: "賢者の杖", stat: "wisdom", bonus: 12, cost: 400, materials: []},
    {level: 2, name: "神秘の杖", stat: "wisdom", bonus: 25, cost: 1200, materials: [{name: "魔法の結晶", qty: 2}]},

    // === STR武器（剣/斧系）：金属・骨・ドラゴン素材チェイン ===
    {level: 3, name: "精鉄の大剣", stat: "strength", bonus: 38, cost: 2200, materials: [{name: "精鉄インゴット", qty: 4}]},
    {level: 5, name: "牙鋼の両手斧", stat: "strength", bonus: 65, cost: 4800, materials: [{name: "牙鋼インゴット", qty: 3}, {name: "オークの牙", qty: 2}]},
    {level: 7, name: "龍鋼の滅殺剣", stat: "strength", bonus: 95, cost: 8500, materials: [{name: "龍鋼装甲材", qty: 4}, {name: "古代ドラゴンの鱗", qty: 2}]},
    {level: 9, name: "巨神の戦斧", stat: "strength", bonus: 140, cost: 14500, materials: [{name: "巨神骨鋼", qty: 3}, {name: "タイタンの骨", qty: 3}]},
    {level: 11, name: "古龍心滅剣", stat: "strength", bonus: 220, cost: 28500, materials: [{name: "古龍心鋼", qty: 4}, {name: "エルダードラゴンの心臓", qty: 1}]},

    // === WIS杖（魔法系）：結晶・聖・禁断素材チェイン ===
    {level: 3, name: "聖魔導の杖", stat: "wisdom", bonus: 38, cost: 2200, materials: [{name: "聖魔導結晶", qty: 3}]},
    {level: 5, name: "禁断魔導のロッド", stat: "wisdom", bonus: 65, cost: 4800, materials: [{name: "禁断魔導晶", qty: 3}, {name: "禁断の魔導書頁", qty: 2}]},
    {level: 7, name: "エーテル魔晶杖", stat: "wisdom", bonus: 95, cost: 8500, materials: [{name: "エーテル魔晶", qty: 4}, {name: "エーテルの結晶", qty: 2}]},
    {level: 9, name: "深淵の魔導杖", stat: "wisdom", bonus: 140, cost: 14500, materials: [{name: "深淵エーテル晶", qty: 3}, {name: "深淵の核", qty: 2}]},
    {level: 11, name: "光神器の神杖", stat: "wisdom", bonus: 220, cost: 28500, materials: [{name: "光神器晶", qty: 4}, {name: "光の神器の欠片", qty: 1}]},

    // === DEX武器（弓/短剣系）：獣皮・羽・風素材チェイン ===
    {level: 1, name: "獣皮の短剣", stat: "dexterity", bonus: 12, cost: 400, materials: [{name: "獣皮エキス", qty: 2}]},
    {level: 3, name: "風翼の弓", stat: "dexterity", bonus: 38, cost: 2200, materials: [{name: "風翼結晶", qty: 3}, {name: "グリフォンの羽", qty: 2}]},
    {level: 5, name: "ユニコーンのダガー", stat: "dexterity", bonus: 65, cost: 4800, materials: [{name: "ユニコーンの角", qty: 2}, {name: "獣皮エキス", qty: 3}]},
    {level: 7, name: "天使の迅弓", stat: "dexterity", bonus: 95, cost: 8500, materials: [{name: "天使の羽", qty: 3}, {name: "風翼結晶", qty: 2}]},
    {level: 9, name: "神聖迅撃短剣", stat: "dexterity", bonus: 140, cost: 14500, materials: [{name: "神聖遺晶", qty: 3}, {name: "神聖な遺物", qty: 2}]},
    {level: 11, name: "創世の神弓", stat: "dexterity", bonus: 220, cost: 28500, materials: [{name: "創世の欠片", qty: 2}, {name: "風翼結晶", qty: 4}]},

    // === LUC武器（幸運系）：希少・星・神涙素材チェイン ===
    {level: 1, name: "希少スパイスの短棍", stat: "luck", bonus: 12, cost: 400, materials: [{name: "希少活力粉", qty: 2}]},
    {level: 3, name: "星の幸運棍", stat: "luck", bonus: 38, cost: 2200, materials: [{name: "星の欠片", qty: 2}]},
    {level: 5, name: "不死鳥の幸運斧", stat: "luck", bonus: 65, cost: 4800, materials: [{name: "不死鳥炎粉", qty: 3}, {name: "フェニックスの灰", qty: 2}]},
    {level: 7, name: "神涙の福杖", stat: "luck", bonus: 95, cost: 8500, materials: [{name: "神の涙", qty: 2}, {name: "永劫炎粉", qty: 2}]},
    {level: 9, name: "終焉の幸運剣", stat: "luck", bonus: 140, cost: 14500, materials: [{name: "終焉破壊粉", qty: 3}, {name: "滅びの結晶", qty: 2}]},
    {level: 11, name: "滅び深淵の神器棍", stat: "luck", bonus: 220, cost: 28500, materials: [{name: "滅び深淵晶", qty: 4}, {name: "世界の源石", qty: 1}]},

    // === 究極汎用武器（全ステータス対応、エンドコンテンツ） ===
    {level: 12, name: "創世源の神剣", stat: "strength", bonus: 350, cost: 50000, materials: [{name: "創世源ポーション", qty: 1}, {name: "古龍心鋼", qty: 5}]},
    {level: 12, name: "世界源の神杖", stat: "wisdom", bonus: 350, cost: 50000, materials: [{name: "世界源神薬", qty: 1}, {name: "光神器晶", qty: 5}]},
    {level: 12, name: "終焉の神弓", stat: "dexterity", bonus: 350, cost: 50000, materials: [{name: "創世魔力薬", qty: 1}, {name: "神聖遺晶", qty: 5}]},
    {level: 12, name: "源石の幸運神器", stat: "luck", bonus: 350, cost: 50000, materials: [{name: "世界源神薬", qty: 1}, {name: "滅び深淵晶", qty: 5}]}
];

const mainQuests = [
    {
        desc: "ギルドの名声を高める最初の試練 - 地域の盗賊団を壊滅せよ。近年、盗賊団の動きが異常に組織的だという噂がある。",
        difficulty: 35,
        reward: 2000,
        minStrength: 40, minWisdom: 25, minDexterity: 30, minLuck: 15,
        focusStat: "strength",
        minFocus: 50,
        repRequired: 0
    },
    {
        desc: "古代の遺跡を守る守護者が暴走した。遺跡の封印が弱まっている兆候だ。守護者を倒し、封印石を調査せよ。",
        difficulty: 70,
        reward: 5000,
        minStrength: 60, minWisdom: 55, minDexterity: 50, minLuck: 30,
        focusStat: "wisdom",
        minFocus: 70,
        repRequired: 0
    },
    {
        desc: "伝説のドラゴンが覚醒し、周辺を焼き払っている。ドラゴンを討伐し、その心臓を持ち帰れ。心臓には異常な闇の力が宿っているようだ。",
        difficulty: 120,
        reward: 15000,
        minStrength: 100, minWisdom: 90, minDexterity: 85, minLuck: 70,
        focusStat: "all",
        minFocus: 100,
        repRequired: 0
    },
    {
        desc: "森全体が腐敗し、動植物が狂暴化している。原因は深部の『腐敗の核』らしい。核を破壊し、森のドルイドに報告せよ。（成功時：森のドルイド リオラを発見しやすくなる）",
        difficulty: 160,
        reward: 22000,
        minStrength: 120, minWisdom: 110, minDexterity: 100, minLuck: 80,
        focusStat: "wisdom",
        minFocus: 140,
        repRequired: 50
    },
    {
        desc: "闇のカルト集団が各地で儀式を行っている。彼らの指導者を捕らえ、深淵の王ヴォルガスの復活計画を暴け。",
        difficulty: 200,
        reward: 30000,
        minStrength: 140, minWisdom: 140, minDexterity: 120, minLuck: 100,
        focusStat: "all",
        minFocus: 160,
        repRequired: 100
    },
    {
        desc: "失われた『光の神器』が深淵の迷宮に眠っている。神器を回収し、星の観測者アストリッドに届けて解析させよ。（成功時：星の観測者 アストリッドを発見しやすくなる）",
        difficulty: 250,
        reward: 40000,
        minStrength: 160, minWisdom: 160, minDexterity: 150, minLuck: 120,
        focusStat: "dexterity",
        minFocus: 180,
        repRequired: 150
    },
    {
        desc: "深淵の軍勢が王都へ進軍を開始した。王都防衛戦を指揮し、敵の先鋒を壊滅させよ。施設で準備を整える時だ。",
        difficulty: 300,
        reward: 55000,
        minStrength: 190, minWisdom: 180, minDexterity: 170, minLuck: 140,
        focusStat: "strength",
        minFocus: 210,
        repRequired: 200
    },
    {
        desc: "古代の賢者たちが残した封印陣を修復せよ。地図の賢者エルドリンと歴史の語り部タリアの助言が必要だ。（成功時：上記2人の発見確率大幅アップ）",
        difficulty: 350,
        reward: 70000,
        minStrength: 210, minWisdom: 220, minDexterity: 190, minLuck: 160,
        focusStat: "wisdom",
        minFocus: 240,
        repRequired: 250
    },
    {
        desc: "深淵の要塞が顕現した。要塞内部に侵入し、ヴォルガスの四天王をすべて倒せ。すべての施設と装備を最大限に活用せよ。",
        difficulty: 420,
        reward: 90000,
        minStrength: 240, minWisdom: 240, minDexterity: 220, minLuck: 190,
        focusStat: "all",
        minFocus: 280,
        repRequired: 300
    },
    {
        desc: "深淵の王ヴォルガスが完全に復活した。すべての冒険者と発見したNPCの力を結集し、最終決戦に挑め。世界の命運がギルドにかかっている。",
        difficulty: 500,
        reward: 150000,
        minStrength: 280, minWisdom: 280, minDexterity: 260, minLuck: 240,
        focusStat: "all",
        minFocus: 350,
        repRequired: 350
    }
];

let gameState = {
    day: 1,
    gold: 1000,
    reputation: 20,
    adventurers: [],
    quests: [],
    inventory: [],
    sellables: [],
    recruitPending: [],
    eventHistory: [],
    nextId: 1,
    maxPermanentSlots: 4,
    gameOver: false,
    discoveredNPCs: [],
    receivedNPCs: [],
    discoveryMultiplier: 10,
    facilities: {blacksmith: 0, tavern: 0, alchemy: 0},
    dailyPrices: {},
    mainProgress: 0,
    dailyMaterials: [],
    // 新規追加：クエスト完了ダイアログの既視フラグ（同じ内容は1回だけ再生）
    seenCompletionDialogues: new Set()
};

// gameState の定義直後（let gameState = { ... }; の次）に以下のコードを挿入
// 新規ゲーム開始時のみ開始永久冒険者を追加（ロード時はスキップ）


const statIcons = {
    strength: 'STR',
    wisdom: 'WIS',
    dexterity: 'DEX',
    luck: 'LUC'
};

const statFull = {
    strength: '筋力',
    wisdom: '知恵',
    dexterity: '敏捷',
    luck: '運'
};


if (gameState.adventurers.length === 0 && gameState.day === 1) {
    // カイト (STR/DEX 特化の二刀流騎士)
    const kaito = {
        id: gameState.nextId++,
        name: 'カイト',
        gender: 'male',
        image: 'Images/カイト.png',
        strength: 30,
        wisdom: 10,
        dexterity: 25,
        luck: 10,
        level: 1,
        exp: 0,
        hp: 100,
        maxHp: 100,
        mp: 130,
        maxMp: 130,
        equipment: [],
        buffs: [],
        temp: false,
        busy: false
    };

    gameState.adventurers.push(kaito);

    // ルナ (WIS 特化の魔法使い)
    const luna = {
        id: gameState.nextId++,
        name: 'ルナ',
        gender: 'female',
        image: 'Images/ルナ.png',
        strength: 10,
        wisdom: 30,
        dexterity: 10,
        luck: 25,
        level: 1,
        exp: 0,
        hp: 100,
        maxHp: 100,
        mp: 130,
        maxMp: 130,
        equipment: [],
        buffs: [],
        temp: false,
        busy: false
    };

    gameState.adventurers.push(luna);
}

const statColors = {
    0: '#ff0000',
    1: '#0000ff',
    2: '#00ff00',
    3: '#ffff00'
};

const maleNames = [
    'アキラ', 'ハルト', 'ケン', 'リュウ', 'ソラ',
    'タイチ', 'ユウト', 'カズキ', 'リョウ', 'ショウ',
    'トモヤ', 'ダイキ', 'ヒロ', 'マサト', 'ナオキ',
    'ユウキ', 'レイ', 'セイジ', 'タカシ', 'ノブ',
    'ミナト', 'レン', 'アオト', 'リク', 'ソウタ',
    'ユイト', 'ハヤト', 'ショウタ', 'コウタ', 'タクミ',
    'ヒロト', 'レオ', 'イオリ', 'アサヒ', 'ヤマト',
    'エイジ', 'トア', 'カイト' /* 使わないので削除 */, 'ユウマ',
    'ラン', 'ジン', 'シン', 'トウヤ', 'ケント',
    'ハルキ', 'ソウスケ', 'リョウタ', 'ナツメ', 'コウキ',
    'タイガ', 'リュウセイ', 'カケル', 'テツヤ', 'マヒロ'
];

const femaleNames = [
    'アヤカ', 'ハルカ', 'ミカ', 'サクラ', 'ユイ',
    'リナ', 'モモ', 'ナナ', 'ユナ', 'アカリ',
    'ヒナタ', 'ソラ', 'ミユ', 'リコ', 'サヤ',
    'マユ', 'ノゾミ', /* 'ルナ' 使わないので削除 */ 'エマ', 'キラ',
    'ツムギ', 'ミオ', 'スイ', 'リン', 'ヒマリ',
    'エイ', 'ユイナ', 'アオイ', 'メイ', 'ハナ',
    'リオ', 'チヒロ', 'アイ', 'ミズキ', 'カナ',
    'サキ', 'ホノカ', 'アミ', 'レナ', 'マオ',
    'ユズキ', 'コハル', 'スズ', 'ミナ', 'ヒカリ',
    'ナツキ', 'サトミ', 'ユカリ', 'レイナ', 'ミサキ',
    'アンナ', 'ハナカ', 'サナ', 'マナ'
];

const discoveryNPCs = [
    '地図の賢者 エルドリン',
    '歴史の語り部 タリア',
    '深海の探求者 コルバト',
    '反響の予見者 シララ',
    '星の観測者 アストリッド',
    '森のドルイド リオラ',
    '灰の学者 ボルカン',
    '幻の舞姫 ザラ',
    '宝石の彫刻師 トーン',
    '永遠の守護者 フェイ'
];

const enemyConfigs = [
    {ja: '暗殺者（男）', en: 'Assassin(M)'},
    {ja: '暗殺者（女）', en: 'Assassin(F)'},
    {ja: 'ハンター（男）', en: 'Hunter(M)'},
    {ja: 'ハンター（女）', en: 'Hunter(F)'}
];


// 既存のこれらの定数をすべて削除または置き換え
// const killDescs = [...];
// const discoveryDescs = [...];
// const escortDescs = [...];
// const fetchDescs = [...];
// const fetchItems = [...];

// 新しく追加（javascript.js の他の const の近くに貼り付け）

function getQuestRank(difficulty) {
    if (difficulty <= 10) return 'F';
    if (difficulty <= 20) return 'F+';
    if (difficulty <= 30) return 'D';
    if (difficulty <= 40) return 'D+';
    if (difficulty <= 50) return 'C';
    if (difficulty <= 60) return 'C+';
    if (difficulty <= 70) return 'B';
    if (difficulty <= 80) return 'B+';
    if (difficulty <= 90) return 'A';
    if (difficulty <= 100) return 'A+';
    return 'S';
}

// 新しく追加（他のconstの近く、例えばquestDescs系の下に貼り付け）
// クエスト初回完了時の専用ストーリー対話データ（F/F+のみサンプル実装）
// 構造: type -> rank -> index (0~2) -> 対話配列
// タイプ: 'kill', 'discovery', 'escort', 'fetch'
// {player} はプレイヤー名に置換（導入で入力した名前）
// ナレーターで締めくくり、世界観や3人の絆を少しずつ深める




const discoveryDescs = [
    '迷宮のような峡谷の隠された道を地図化せよ。伝説の宝の噂。',
    '砂漠の砂丘の失われた星の神殿を発掘せよ。星座に一致する。',
    'アジュール湖の下の沈んだ遺跡を見つけよ。古代の水生文明。',
    'エコーケイブの秘密の間を発見せよ。ささやきが予言を明らかにする。',
    'クラウドピークの忘れられた天文台を位置づけよ。多宇宙を眺める。',
    'ウィスパリングウッドのハートツリーを探検せよ。すべての森の魔法の源。',
    'アッシェンウェイストの埋もれた天文台を発掘せよ。火山の異常。',
    'エンドレスサンドのミラージュオアシスを見つけよ。幻か現実か？',
    'クリスタルカーブンの輝く鉱脈をチャートせよ。アーティファクトの力源。',
    'ソーンウォールメイズの隠されたグローブを発見せよ。永遠の若さが咲く。'
];



const killDescsByRank = {
    'F': [
        '村の周辺をうろつくスライム5匹を討伐せよ。作物が溶けている。',
        '酒場の地下室に巣食う巨大ネズミをすべて退治せよ。',
        '農場を襲う野犬3匹を倒せ。家畜が危ない。'
    ],
    'F+': [
        '街道で待ち伏せするゴブリン8匹を討伐せよ。',
        '森に隠れる山賊5人を排除せよ。',
        '洞窟に潜む巨大蜘蛛1匹を殺せ。'
    ],
    'D': [
        '村を脅かすオークの群れ10体を倒せ。',
        '橋を占拠するトロル1体を討伐せよ。',
        '森の奥にいる狼王とその群れを狩れ。'
    ],
    'D+': [
        '盗賊団の拠点を襲撃し、盗賊15人を殺せ。',
        '古代迷宮に潜むミノタウロスを倒せ。',
        '山に巣食うワイバーン1匹を討伐せよ。'
    ],
    'C': [
        'オーク部族の戦士20体を壊滅せよ。',
        '巨人のサイクロプス1体を倒せ。',
        '空を飛ぶグリフォン1匹を討伐せよ。'
    ],
    'C+': [
        '沼地に潜むヒドラを倒せ。すべての頭を焼却せよ。',
        '呪われたバンシーを鎮めよ。',
        'ケンタウロスの軍勢12体を撃破せよ。'
    ],
    'B': [
        '下級デーモンを召喚するカルト指導者を討伐せよ。',
        '暴走した古代ゴーレムを破壊せよ。',
        'リッチの墓を守るアンデッド軍を一掃せよ。'
    ],
    'B+': [
        'ヴァンパイア貴族を倒せ。夜の脅威を終わらせよ。',
        '再生するフェニックスを狩れ。',
        '大地を揺るがすビヒーモスを討伐せよ。'
    ],
    'A': [
        '大デーモン（アークデーモン）を地獄から引きずり出して倒せ。',
        '古代ドラゴン1体を討伐せよ。',
        'タイタンの巨人を撃破せよ。'
    ],
    'A+': [
        'ドラゴンの王を討伐せよ。',
        'リッチキングとその不死軍を壊滅せよ。',
        '堕落した天使を倒せ。'
    ],
    'S': [
        '深淵から現れた古の悪神を討伐せよ。',
        '世界を焼き尽くすエルダードラゴンを倒せ。',
        '神話の海獣レヴィアタンを討伐せよ。'
    ]
};

const discoveryDescsByRank = {
    'F': [
        '町で失くされた大切なペンダントを探せ。',
        '近所の森に隠された小さな宝箱を発見せよ。',
        '古い井戸の底に隠された秘密を見つけよ。'
    ],
    'F+': [
        '森の奥に隠された滝の裏の洞窟を発見せよ。',
        '古い家の隠し地下室を探せ。',
        '川沿いの隠された小屋を見つけよ。'
    ],
    'D': [
        '近くの丘にある小さな遺跡の入り口を発見せよ。',
        '盗賊が使う隠しキャンプを探せ。',
        '行方不明のキャラバンの残骸を見つけよ。'
    ],
    'D+': [
        '埋もれた古代寺院の場所を発見せよ。',
        '山の隠された鉱脈を探せ。',
        '湖底に沈んだ村の痕跡を見つけよ。'
    ],
    'C': [
        '忘れられた城の秘密通路を発見せよ。',
        '魔法の泉の正確な位置をマッピングせよ。',
        '呪われた森の中心にある祠を探せ。'
    ],
    'C+': [
        '失われた文明の遺跡を発見せよ。',
        '雲の上に浮かぶ島への道を見つけよ。',
        '不安定な次元ポータルの場所を発見せよ。'
    ],
    // B 以上は元の壮大な発見クエストを使用（NPC発見可能）
    'B': [discoveryDescs[0], discoveryDescs[1], discoveryDescs[2]],
    'B+': [discoveryDescs[3], discoveryDescs[4], discoveryDescs[5]],
    'A': [discoveryDescs[6], discoveryDescs[7]],
    'A+': [discoveryDescs[8], discoveryDescs[9]],
    'S': [
        '宇宙の果てに存在する禁断の神殿を発見せよ。',
        '世界の起源を記した究極の図書館を見つけよ。',
        '神々が会議を行う隠された領域を発見せよ。'
    ]
};

const escortDescsByRank = {
    'F': [
        '農夫を近くの市場まで安全に護衛せよ。',
        '子供を危険な橋を渡って家まで送れ。',
        '村への手紙を届ける使者を守れ。'
    ],
    'F+': [
        '商人を次の町まで護衛せよ。ゴブリンが潜む道だ。',
        '旅行者のグループを森の道で守れ。',
        '荷物を運ぶキャラバンを盗賊から護衛せよ。'
    ],
    'D': [
        '貴族を隣町まで護衛せよ。暗殺者の噂がある。',
        '負傷した兵士を前線からキャンプまで送れ。',
        '学者を危険な遺跡まで護衛せよ。'
    ],
    'D+': [
        '外交官を敵の領土を抜けて護衛せよ。',
        '難民の家族を安全地帯までガイドせよ。',
        '珍しい魔獣と調教師を闘技場まで護衛せよ。'
    ],
    'C': [
        '王子を隣国まで護衛せよ。政略結婚のためだ。',
        '聖女を聖地まで守れ。異端者が狙っている。',
        '貴重な神器を運ぶ一行を護衛せよ。'
    ],
    'C+': [
        '将軍を戦場まで護衛せよ。敵のスパイが暗躍中。',
        '予言者を神託の場所まで送れ。',
        '最後のエルフ王女を隠れ里まで護衛せよ。'
    ],
    'B': [
        '古代の賢者を禁断の図書館まで護衛せよ。',
        'ドラゴンライダーを巣まで守れ。',
        '神の化身を神殿まで護衛せよ。'
    ],
    'B+': [
        '堕落した英雄を裁きの場まで護衛せよ。',
        '星の使者を天文台まで送れ。',
        '最後のユニコーンを聖域まで護衛せよ。'
    ],
    'A': [
        '王を亡命先まで護衛せよ。国が滅びようとしている。',
        '大魔導士を禁呪の儀式場まで守れ。',
        '神の遺児を運命の場所まで護衛せよ。'
    ],
    'A+': [
        '光の女神の巫女を最終聖域まで護衛せよ。',
        '最後の希望である預言者を世界の中心まで送れ。',
        '滅びゆく世界の救世主を神の座まで護衛せよ。'
    ],
    'S': [
        '世界の均衡を守る存在を深淵の門まで護衛せよ。',
        '時を司る神の使者を永遠の時計塔まで守れ。',
        '全ての命の源を最終決戦の場まで護衛せよ。'
    ]
};



const fetchQuestsByRank = {
    'F': [
        {desc: '錬金術師のために野原から薬草を{qty}個集めてきてくれ。', itemName: '薬草', minPrice: 10, maxPrice: 30},
        {desc: '料理人に新鮮なキノコを{qty}個持ってきてほしい。', itemName: 'キノコ', minPrice: 15, maxPrice: 25},
        {desc: '村人にきれいな花を{qty}個届けてきて。', itemName: '花', minPrice: 5, maxPrice: 15}
    ],
    'F+': [
        {desc: '鍛冶屋のために鉄の欠片を{qty}個集めてきて。', itemName: '鉄の欠片', minPrice: 20, maxPrice: 40},
        {desc: '漁師に川魚を{qty}匹釣ってきてほしい。', itemName: '川魚', minPrice: 20, maxPrice: 35},
        {desc: '薬師のために普通の薬草を{qty}個持ってきて。', itemName: '普通の薬草', minPrice: 15, maxPrice: 30}
    ],
    'D': [
        {desc: '鉱夫のために良質の鉄鉱石を{qty}個採掘してきて。', itemName: '鉄鉱石', minPrice: 30, maxPrice: 60},
        {desc: 'ハンターに狼の毛皮を{qty}枚持ってきてほしい。', itemName: '狼の毛皮', minPrice: 40, maxPrice: 70},
        {desc: '魔術師に魔力の結晶（小）を{qty}個集めてきて。', itemName: '魔力の結晶（小）', minPrice: 50, maxPrice: 80}
    ],
    'D+': [
        {desc: '冒険者にオークの牙を{qty}個持ってきてほしい。', itemName: 'オークの牙', minPrice: 60, maxPrice: 100},
        {desc: '賢者に古代の巻物断片を{qty}個集めてきて。', itemName: '古代の巻物断片', minPrice: 80, maxPrice: 120},
        {desc: '商人に希少スパイスを{qty}個届けてきて。', itemName: '希少スパイス', minPrice: 70, maxPrice: 110}
    ],
    'C': [
        {desc: '貴族にグリフォンの羽を{qty}枚持ってきてほしい。', itemName: 'グリフォンの羽', minPrice: 150, maxPrice: 250},
        {desc: '大魔導士にヒドラの毒袋を{qty}個集めてきて。', itemName: 'ヒドラの毒袋', minPrice: 200, maxPrice: 300},
        {desc: '神殿に聖水を{qty}瓶届けてきて。', itemName: '聖水', minPrice: 180, maxPrice: 280}
    ],
    'C+': [
        {desc: '王宮にユニコーンの角を{qty}個持ってきてほしい。', itemName: 'ユニコーンの角', minPrice: 400, maxPrice: 600},
        {desc: '禁書庫に禁断の魔導書頁を{qty}枚集めてきて。', itemName: '禁断の魔導書頁', minPrice: 500, maxPrice: 700},
        {desc: '錬金大师にフェニックスの灰を{qty}握り持ってきて。', itemName: 'フェニックスの灰', minPrice: 450, maxPrice: 650}
    ],
    'B': [
        {desc: '大賢者に星の欠片を{qty}個集めてきてほしい。', itemName: '星の欠片', minPrice: 1000, maxPrice: 1500},
        {desc: '神官に天使の羽を{qty}枚持ってきて。', itemName: '天使の羽', minPrice: 1200, maxPrice: 1800},
        {desc: '闇市場にデーモンの心臓を{qty}個届けてきて。', itemName: 'デーモンの心臓', minPrice: 1100, maxPrice: 1600}
    ],
    'B+': [
        {desc: '王に古代ドラゴンの鱗を{qty}枚持ってきてほしい。', itemName: '古代ドラゴンの鱗', minPrice: 2000, maxPrice: 3000},
        {desc: '最高魔導士にエーテルの結晶を{qty}個集めてきて。', itemName: 'エーテルの結晶', minPrice: 2500, maxPrice: 3500},
        {desc: '神殿に神の涙を{qty}滴届けてきて。', itemName: '神の涙', minPrice: 2200, maxPrice: 3200}
    ],
    'A': [
        {desc: '伝説の英雄にタイタンの骨を{qty}本持ってきてほしい。', itemName: 'タイタンの骨', minPrice: 4000, maxPrice: 6000},
        {desc: '究極の錬金術師に永遠の炎を{qty}握り集めてきて。', itemName: '永遠の炎', minPrice: 4500, maxPrice: 6500},
        {desc: '神々に神聖な遺物を{qty}個届けてきて。', itemName: '神聖な遺物', minPrice: 4200, maxPrice: 6200}
    ],
    'A+': [
        {desc: '世界の守護者にエルダードラゴンの心臓を{qty}個持ってきてほしい。', itemName: 'エルダードラゴンの心臓', minPrice: 8000, maxPrice: 12000},
        {desc: '禁断の研究者に深淵の核を{qty}個集めてきて。', itemName: '深淵の核', minPrice: 9000, maxPrice: 13000},
        {desc: '最後の希望に光の神器の欠片を{qty}個届けてきて。', itemName: '光の神器の欠片', minPrice: 8500, maxPrice: 12500}
    ],
    'S': [
        {desc: '運命に世界の源石を{qty}個持ってきてほしい。', itemName: '世界の源石', minPrice: 15000, maxPrice: 25000},
        {desc: '神々に創世の欠片を{qty}個集めてきて。', itemName: '創世の欠片', minPrice: 20000, maxPrice: 30000},
        {desc: '終焉の使者に滅びの結晶を{qty}個届けてきて。', itemName: '滅びの結晶', minPrice: 18000, maxPrice: 28000}
    ]
};



const defenseDescs = [
    'ギルドが謎の侵略者に襲われています！急いで防衛を！',
    '敵の軍勢がギルドの門を叩いています。冒険者たちよ、立ち上がれ！',
    '闇の勢力がギルドを包囲。防衛戦が始まる！',
    '野蛮なモンスターの群れがギルドを急襲！防衛せよ！',
    'スパイと暗殺者がギルドに侵入。迎え撃て！'
];



const questTypeDescs = [killDescsByRank, discoveryDescsByRank, escortDescsByRank, fetchQuestsByRank];
const questTypeClasses = ['kill', 'discovery', 'escort', 'fetch', 'defense', 'training', 'main', 'dungeon', 'trade'];

const shopItems = [

    {name:'HPポーション', cost:25, type:'potion', restore:'hp', amount:30},
    {name:'MPポーション', cost:35, type:'potion', restore:'mp', amount:20},    
    {name:'基本の剣', cost:50, stat:'strength', bonus:3},
    {name:'鉄の剣', cost:100, stat:'strength', bonus:5},
    {name:'鋼の剣', cost:200, stat:'strength', bonus:8},
    {name:'見習いの書物', cost:40, stat:'wisdom', bonus:3},
    {name:'賢者の巻物', cost:90, stat:'wisdom', bonus:5},
    {name:'古代のグリモア', cost:180, stat:'wisdom', bonus:8},
    {name:'革の手袋', cost:30, stat:'dexterity', bonus:2},
    {name:'鎖のブラサー', cost:80, stat:'dexterity', bonus:4},
    {name:'エルフのブーツ', cost:150, stat:'dexterity', bonus:7},
    {name:'幸運のコイン', cost:60, stat:'luck', bonus:4},
    {name:'兎の足', cost:120, stat:'luck', bonus:6},
    {name:'四つ葉のクローバー', cost:240, stat:'luck', bonus:9},

];

const materialShop = [
    {name: "鉄鉱石", basePrice: 30, variance: 1.5},
    {name: "薬草", basePrice: 20, variance: 1.5},
    {name: "スパイス", basePrice: 55, variance: 1.8},
    {name: "宝石", basePrice: 115, variance: 2.0}
];

function cleanupAdventurers() {
    gameState.adventurers = gameState.adventurers.filter(a => !(a.temp && !a.busy && a.generatedDay < gameState.day));
    gameState.quests.forEach(q => {
        q.assigned = q.assigned.filter(id => {
            const adv = findAdv(id);
            if (!adv) return false;
            if (adv.temp && !adv.busy && adv.generatedDay < gameState.day) {
                const idx = gameState.adventurers.findIndex(a => a.id === id);
                if (idx > -1) gameState.adventurers.splice(idx, 1);
                return false;
            }
            return true;
        });
    });
    gameState.recruitPending = gameState.recruitPending.filter(adv => adv.generatedDay >= gameState.day - 2);
}

function saveGame() {
    // Set は JSON に直接シリアライズできないので、Array に変換したコピーを作成
    const savableState = {
        ...gameState,
        seenCompletionDialogues: Array.from(gameState.seenCompletionDialogues || new Set())
    };

    localStorage.setItem('guildMasterSave', JSON.stringify(savableState));
    alert('ゲームを保存しました！');
}

function loadGame() {
    const saved = localStorage.getItem('guildMasterSave');
    if (saved) {
        const loadedState = JSON.parse(saved);

        // 既存の gameState にマージ
        Object.assign(gameState, loadedState);

        // 旧セーブ互換性 & 初期化
        if (!gameState.facilities) gameState.facilities = {blacksmith: 0, tavern: 0, alchemy: 0};
        if (!gameState.dailyPrices) gameState.dailyPrices = {};
        if (gameState.mainProgress === undefined) gameState.mainProgress = 0;

        // seenCompletionDialogues を Array → Set に復元（旧セーブでは undefined もあり得る）
        if (Array.isArray(gameState.seenCompletionDialogues)) {
            gameState.seenCompletionDialogues = new Set(gameState.seenCompletionDialogues);
        } else if (!gameState.seenCompletionDialogues) {
            gameState.seenCompletionDialogues = new Set();
        }

        // 冒険者関連の後方互換処理（既存のまま）
        gameState.adventurers.forEach(a => {
            if (!a.buffs) a.buffs = [];
        });

        cleanupAdventurers();
        checkGameOver();
        updateDisplays();
        ensureTrainingQuest();
        alert('ゲームを読み込みました！');
    } else {
        alert('セーブデータが見つかりません！');
    }
}

// Counts total quantity of an item by name (handles stacks)
function countItem(name) {
    const stack = gameState.inventory.find(i => i.name === name);
    return stack ? (stack.qty || 0) : 0;
}

// Removes up to `count` from stack by name
function removeItems(name, count) {
    const stackIdx = gameState.inventory.findIndex(i => i.name === name);
    if (stackIdx === -1) return 0;
    const avail = gameState.inventory[stackIdx].qty || 0;
    const consume = Math.min(avail, count);
    gameState.inventory[stackIdx].qty -= consume;
    if (gameState.inventory[stackIdx].qty <= 0) {
        gameState.inventory.splice(stackIdx, 1);
    }
    return consume;
}

// Adds `qty` of item, stacking if identical name (stacks consumables/materials; individual for equip if qty>1)
function addToInventory(template, qty = 1) {
    if (qty <= 0) return;
    const name = template.name;

    if (template.stat) {
        // Equipment: add individually (each gets a unique ID, no stacking)
        for (let i = 0; i < qty; i++) {
            const newItem = { ...template, id: gameState.nextId++ };
            gameState.inventory.push(newItem);
        }
    } else {
        // Stackables (potions, materials, consumables): stack by name
        let stack = gameState.inventory.find(i => i.name === name);
        if (stack) {
            // Existing stack – just increase the quantity
            stack.qty = (stack.qty || 1) + qty;
        } else {
            // No existing stack – create a new stacked item
            const newItem = { ...template, id: gameState.nextId++, qty: qty };
            gameState.inventory.push(newItem);
        }
    }
}









function spendGold(amount) {
    if (gameState.gold < amount) {
        alert("ゴールドが不足しています");
        return false;
    }
    gameState.gold -= amount;
    checkGameOver();
    return true;
}

function addBattleLog(msg) {
    const log = document.getElementById('battleLog');
    if (log) {
        const line = document.createElement('div');
        line.textContent = msg;
        log.appendChild(line);
        log.scrollTop = log.scrollHeight;  // Auto-scroll to bottom
    } else {
        console.warn('battleLog not found - cannot add:', msg);
    }
}

function showDamagePopup(parentElement, amount, isHeal = false, isCritical = false) {
    if (!parentElement) return;
    console.log(parentElement)
    const popup = document.createElement('div');
    popup.className = 'damage-popup';
    popup.textContent = `-${amount}`;



    parentElement.appendChild(popup);
    console.log(parentElement)
    setTimeout(() => {
        if (popup.parentNode) popup.remove();
    }, 800);
}

function corrupt() {
    if (gameState.reputation < 10) {
        alert("評判が不足しています");
        return;
    }
    gameState.reputation -= 10;
    gameState.gold += 100;
    checkGameOver();
    updateDisplays();
}

function checkGameOver() {
    if (gameState.gameOver) return;
    if (gameState.gold <= 0 || gameState.reputation <= 0) {
        const reason = gameState.gold <= 0 ? "資金不足" : "評判ゼロ";
        alert(`ゲームオーバー！ギルドは${reason}により崩壊しました。`);
        gameState.gameOver = true;
        const endBtn = document.querySelector('button[onclick="playDay()"]');
        if (endBtn) endBtn.disabled = true;
        updateDisplays();
    }
}

function buyExpansion() {
    const current = gameState.maxPermanentSlots;
    if (current >= 12) {
        alert('最大拡張に達しました');
        return;
    }
    const next = current + 1;
    const level = next - 4;
    const cost = 500 + 250 * (level - 1);
    if (!spendGold(cost)) return;
    gameState.maxPermanentSlots = next;
    updateDisplays();
}

function randomName(gender){
    const names = gender === 'M' ? maleNames : femaleNames;
    return names[Math.floor(Math.random()*names.length)];
}

// generateQuest 関数を以下のものに完全に置き換え
function generateQuest(){
    const repFactor = Math.max(0, gameState.reputation);
    const minDiff = 1;
    const maxDiff = Math.min(150, Math.floor(repFactor / 5.0) + 10); // 上限を少し上げてSランクも出やすく
    const difficulty = minDiff + Math.floor(Math.random() * (maxDiff - minDiff + 1));
    const rank = getQuestRank(difficulty);

    

    const primary = Math.floor(Math.random()*4);
    let minStrength=0,minWisdom=0,minDexterity=0,minLuck=0;
    if(primary===0){minStrength = Math.floor(Math.random()*10 + difficulty*5); minWisdom = Math.floor(Math.random()*5 + difficulty*2); minDexterity = Math.floor(Math.random()*5 + difficulty*2); minLuck = Math.floor(Math.random()*3 + difficulty);}
    else if(primary===1){minWisdom = Math.floor(Math.random()*10 + difficulty*5); minStrength = Math.floor(Math.random()*5 + difficulty*2); minDexterity = Math.floor(Math.random()*5 + difficulty*2); minLuck = Math.floor(Math.random()*3 + difficulty);}
    else if(primary===2){minDexterity = Math.floor(Math.random()*10 + difficulty*5); minStrength = Math.floor(Math.random()*5 + difficulty*2); minWisdom = Math.floor(Math.random()*5 + difficulty*2); minLuck = Math.floor(Math.random()*3 + difficulty);}
    else{minLuck = Math.floor(Math.random()*10 + difficulty*5); minStrength = Math.floor(Math.random()*3 + difficulty); minWisdom = Math.floor(Math.random()*3 + difficulty); minDexterity = Math.floor(Math.random()*5 + difficulty*2);}

    let desc, item = null, npcIdx = null;
    let qType = 5

    if (primary === 0) { // kill (STR)
        const pool = killDescsByRank[rank];
        qType = 0;
        storyindex = Math.floor(Math.random() * pool.length); 
        desc = pool[storyindex];
    } else if (primary === 1) { // discovery (WIS)
    let pool = discoveryDescsByRank[rank] || discoveryDescsByRank['F']; // 通常ランクは通常プール
    let useEpic = false;

    // Bランク以上はepic discoveryDescsを使用（NPC発見可能）
    if (['B','B+','A','A+','S'].includes(rank)) {
        useEpic = true;
        if (rank === 'B') pool = discoveryDescs.slice(0, 3);
        else if (rank === 'B+') pool = discoveryDescs.slice(3, 6);
        else if (rank === 'A') pool = discoveryDescs.slice(6, 8);
        else if (rank === 'A+') pool = discoveryDescs.slice(8, 10);
        else pool = discoveryDescsByRank['S']; // Sランクは専用
    }

    qType = 1;
    const storyindex = Math.floor(Math.random() * pool.length);
    const selectedDesc = pool[storyindex];
    desc = selectedDesc;
    if (useEpic) {
        // epicプールの場合、discoveryDescs全体でのインデックスを取得してNPC発見に使用
        const originalIndex = discoveryDescs.indexOf(selectedDesc);
        if (originalIndex !== -1) {
            npcIdx = originalIndex;
        }
    }

    // qオブジェクトに割り当て（generateQuest内のqに設定）
    // q.desc = desc;
    // q.storyindex = storyindex;
    // if (npcIdx !== null) q.npcIdx = npcIdx; // NPC発見可能性フラグ

    } else if (primary === 2) { // escort (DEX)
        const pool = escortDescsByRank[rank];
        qType = 2;
        storyindex = Math.floor(Math.random() * pool.length); 
        desc = pool[storyindex];
    } else { // fetch (LUC)
        const pool = fetchQuestsByRank[rank];
        qType = 3;
        storyindex = Math.floor(Math.random() * pool.length); 
        entry = pool[storyindex];
        const qty = Math.floor(Math.random() * 3) + 1;
        desc = entry.desc.replace('{qty}', qty);
        item = {name: entry.itemName, minPrice: entry.minPrice, maxPrice: entry.maxPrice};
    }

    const focusStat = ['strength', 'wisdom', 'dexterity', 'luck'][primary];
    const minFocus = primary === 0 ? minStrength : primary === 1 ? minWisdom : primary === 2 ? minDexterity : minLuck;


    return {
        id: gameState.nextId++,
        desc: desc,
        difficulty,
        minStrength, minWisdom, minDexterity, minLuck,
        focusStat: focusStat,
        minFocus: minFocus,
        type: primary,
        item: item,
        npcIdx: npcIdx,
        daysLeft: 7 + Math.floor(Math.random() * 8),
        reward: difficulty*100,
        assigned:[],
        inProgress: false,
        questType: qType,
        questStoryindex: storyindex,
        rank: rank,
    };
}

let currentDayEvents = [];
let currentPage = 0;

function showModal(day) {
    currentDayEvents = gameState.eventHistory.filter(e => e.day === day);
    if (currentDayEvents.length === 0) {
        startDay();
        return;
    }
    currentPage = 0;
    document.getElementById('eventModal').style.display = 'flex';
    updateModal();
}





const allAlchemyMaterials = [
    // === 元の生素材 + クラフト素材（8種） ===
    "鉄鉱石", "薬草", "スパイス", "宝石",
    "鋼のインゴット", "活力の粉", "炎の粉", "魔法の結晶",

    // === fetch生素材（recipesで使用される全種） ===
    // F/F+
    "キノコ", "花", "普通の薬草", "川魚", "鉄の欠片",

    // D/D+
    "狼の毛皮", "魔力の結晶（小）",

    // D+/C
    "オークの牙", "古代の巻物断片", "希少スパイス",

    // C/C+
    "グリフォンの羽", "ヒドラの毒袋", "聖水",

    // C+/B
    "ユニコーンの角", "禁断の魔導書頁", "フェニックスの灰",
    "星の欠片", "天使の羽", "デーモンの心臓",

    // B+/A
    "古代ドラゴンの鱗", "エーテルの結晶", "神の涙",
    "タイタンの骨", "永遠の炎", "神聖な遺物",

    // A+/S
    "エルダードラゴンの心臓", "深淵の核", "光の神器の欠片",
    "世界の源石", "創世の欠片", "滅びの結晶",

    // === 新規クラフト素材（チェイン用、30種） ===
    "鉄草合金粉", "森のエキス",
    "精鉄インゴット", "獣皮エキス",
    "牙鋼インゴット", "古魔導粉", "希少活力粉",
    "風翼結晶", "聖魔導結晶",
    "禁断魔導晶", "不死鳥炎粉",
    "龍鋼装甲材", "エーテル魔晶",
    "巨神骨鋼", "永劫炎粉", "神聖遺晶",
    "古龍心鋼", "深淵エーテル晶", "光神器晶", "終焉破壊粉",
    "滅び深淵晶"
]

function getAlchemyMaterialOptions() {
    let html = '<option value="">材料を選択</option>';
    allAlchemyMaterials.forEach(mat => {
        const cnt = countItem(mat);
        if (cnt > 0) {
            html += `<option value="${mat}">${mat} (在庫: ${cnt})</option>`;
        }
    });
    return html;
}

function updateAlchemyPreview() {
    const ing1 = document.getElementById('alchemyIng1')?.value || '';
    const ing2 = document.getElementById('alchemyIng2')?.value || '';
    const qtySel = document.getElementById('alchemyQty');
    const qty = parseInt(qtySel?.value) || 1;
    const preview = document.getElementById('alchemyPreview');
    if (!preview) return;

    if (!ing1 || !ing2 || ing1 === ing2) {
        preview.innerHTML = '';
        return;
    }

    const sortedInputs = [ing1, ing2].sort();
    const recipe = alchemyRecipes.find(r => {
        const rInputs = [...r.inputs].sort();
        return rInputs[0] === sortedInputs[0] && rInputs[1] === sortedInputs[1];
    });

    if (!recipe) {
        preview.innerHTML = '<span style="color: red;">有効なレシピがありません</span>';
        return;
    }

    const cnt1 = countItem(ing1);
    const cnt2 = countItem(ing2);
    const color1 = cnt1 >= qty ? 'green' : 'red';
    const color2 = cnt2 >= qty ? 'green' : 'red';

    preview.innerHTML = `
        <strong>出力:</strong> ${recipe.output.name} × ${qty}<br>
        <strong>必要:</strong><br>
        ${ing1} × ${qty} <span style="color:${color1};">(在庫 ${cnt1})</span><br>
        ${ing2} × ${qty} <span style="color:${color2};">(在庫 ${cnt2})</span>
    `;
}



function updateModal() {
    const modalTitle = document.getElementById('modalTitle');
    const modalContent = document.getElementById('modalContent');
    const pageInfo = document.getElementById('pageInfo');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    if (currentDayEvents.length === 0) {
        closeModal();
        return;
    }
    modalTitle.innerHTML = `日 ${currentDayEvents[0].day} のイベント`;
    modalContent.innerHTML = `<p><strong>${currentDayEvents[currentPage].message}</strong></p>`;
    pageInfo.innerHTML = `ページ ${currentPage + 1} / ${currentDayEvents.length}`;
    prevBtn.style.display = currentPage > 0 ? 'inline-block' : 'none';
    nextBtn.style.display = currentPage < currentDayEvents.length - 1 ? 'inline-block' : 'none';
}

function prevPage() {
    if (currentPage > 0) {
        currentPage--;
        updateModal();
    }
}

function nextPage() {
    if (currentPage < currentDayEvents.length - 1) {
        currentPage++;
        updateModal();
    }
}

function closeModal() {
    document.getElementById('eventModal').style.display = 'none';
    if (!gameState.gameOver) {
        startDay();
    }
}

function generateDefenseQuest() {
    const difficulty = 1;
    let minDexterity = Math.floor(Math.random() * 10 + difficulty * 5);
    const desc = defenseDescs[Math.floor(Math.random() * defenseDescs.length)];
    const numEnemies = 1 + Math.floor(Math.random() * 4);
    return {
        id: gameState.nextId++,
        desc: desc,
        difficulty: difficulty,
        minStrength: 0, minWisdom: 0, minDexterity: minDexterity, minLuck: 0,
        focusStat: 'dexterity',
        minFocus: minDexterity,
        type: 4,
        daysLeft: 1,
        reward: 0,
        assigned: [],
        inProgress: false,
        defense: true,
        numEnemies: numEnemies,
        enemies: []
    };
}

function generateTrainingQuest() {
    return {
        id: gameState.nextId++,
        desc: 'トレーニングクエスト',
        difficulty: 1,
        minStrength: 0,
        minWisdom: 0,
        minDexterity: 0,
        minLuck: 0,
        focusStat: 'strength',
        minFocus: 0,
        type: 5,
        training: true,
        daysLeft: 99999,
        reward: 0,
        assigned: [],
        inProgress: false
    };
}

function ensureTrainingQuest() {
    if (!gameState.quests.some(q => q.training)) {
        const tq = generateTrainingQuest();
        gameState.quests.unshift(tq);
    }
}
ensureTrainingQuest()

// NPC固有のサイドクエストデータ（discoveryNPCsの順番に厳密対応）
const sideQuestData = [
    // 0: 地図の賢者 エルドリン - discovery (WIS重点、地図関連の探索)
    {
        desc: '失われた「永遠の航路図」の断片が散らばっている古代遺跡を探し、正確な位置を地図化せよ。エルドリンの研究に不可欠だ。',
        type: 6, // discovery
        focusStat: 'wisdom',
        difficulty: 80,
        rank: 'B+',
        minWisdom: 800,
        minStrength: 30,
        minDexterity: 40,
        minLuck: 30,
        minFocus: 110,
        reward: 8000,
        daysLeft: 40
    },
    // 1: 歴史の語り部 タリア - fetch (LUC重点、歴史資料集め)
    {
        desc: '忘れられた時代を記した「古の石碑の拓本」を各地の遺跡から5枚集めてきてほしい。タリアの語りに新たな章を加えるために。',
        type: 3, // fetch
        focusStat: 'luck',
        difficulty: 75,
        rank: 'B+',
        item: { name: '古の石碑拓本', qty: 5 },
        minLuck: 700,
        minStrength: 25,
        minWisdom: 45,
        minDexterity: 35,
        minFocus: 100,
        reward: 7500,
        daysLeft: 35
    },
    // 2: 深海の探求者 コルバト - discovery (DEX重点、深海探査)
    {
        desc: '深海に沈む「アビス・クリスタル」の輝く洞窟を発見し、安全な潜水ルートを記録せよ。コルバトの探査に道を開く。',
        type: 1, // discovery
        focusStat: 'dexterity',
        difficulty: 85,
        rank: 'A',
        minDexterity: 850,
        minStrength: 40,
        minWisdom: 35,
        minLuck: 30,
        minFocus: 115,
        reward: 8500,
        daysLeft: 45
    },
    // 3: 反響の予見者 シララ - discovery (WIS重点、予言関連)
    {
        desc: '響き渡る予言の声が聞こえる「エコー・チャンバー」の隠された場所を探し出せ。シララの予見をより鮮明にするために。',
        type: 1, // discovery
        focusStat: 'wisdom',
        difficulty: 90,
        rank: 'A',
        minWisdom: 1000,
        minStrength: 25,
        minDexterity: 35,
        minLuck: 40,
        minFocus: 125,
        reward: 9000,
        daysLeft: 40
    },
    // 4: 星の観測者 アストリッド - discovery (WIS重点、天文関連)
    {
        desc: '星の運行が異常を示す「スターフォール高原」の隠された観測点を特定せよ。アストリッドの星読みに新たな発見をもたらす。',
        type: 1, // discovery
        focusStat: 'wisdom',
        difficulty: 95,
        rank: 'A+',
        minWisdom: 1100,
        minStrength: 20,
        minDexterity: 30,
        minLuck: 45,
        minFocus: 130,
        reward: 9500,
        daysLeft: 50
    },
    // 5: 森のドルイド リオラ - kill (STR重点、森の脅威除去)
    {
        desc: '森を腐敗させる「毒のマンドラゴラ」の群れを根絶やしにせよ。リオラの自然調和を取り戻すために。',
        type: 0, // kill
        focusStat: 'strength',
        difficulty: 80,
        rank: 'B+',
        minStrength: 1000,
        minWisdom: 40,
        minDexterity: 35,
        minLuck: 25,
        minFocus: 120,
        reward: 8000,
        daysLeft: 35
    },
    // 6: 灰の学者 ボルカン - fetch (LUC重点、火山素材)
    {
        desc: '火山地帯から「エターナル・アッシュ」を8個集めてきてくれ。ボルカンの灰の魔術研究に必要だ。',
        type: 3, // fetch
        focusStat: 'luck',
        difficulty: 85,
        rank: 'A',
        item: { name: 'エターナル・アッシュ', qty: 8 },
        minLuck: 9,
        minStrength: 40,
        minWisdom: 35,
        minDexterity: 45,
        minFocus: 110,
        reward: 8500,
        daysLeft: 40
    },
    // 7: 幻の舞姫 ザラ - escort (DEX重点、舞姫護衛)
    {
        desc: '幻の舞を披露するザラを、呪われた劇場まで安全に護衛せよ。観客の幻影が襲いかかる危険な道だ。',
        type: 2, // escort
        focusStat: 'dexterity',
        difficulty: 90,
        rank: 'A',
        minDexterity: 1000,
        minStrength: 35,
        minWisdom: 30,
        minLuck: 40,
        minFocus: 125,
        reward: 9000,
        daysLeft: 30
    },
    // 8: 宝石の彫刻師 トーン - fetch (LUC重点、宝石集め)
    {
        desc: '完璧な彫刻のための「スターレム・ジェム」を6個集めてきてほしい。トーンの究極の作品を完成させるために。',
        type: 3, // fetch
        focusStat: 'luck',
        difficulty: 80,
        rank: 'B+',
        item: { name: 'スターレム・ジェム', qty: 6 },
        minLuck: 950,
        minStrength: 30,
        minWisdom: 40,
        minDexterity: 35,
        minFocus: 115,
        reward: 8000,
        daysLeft: 45
    },
    // 9: 永遠の守護者 フェイ - kill (STR重点、強敵討伐)
    {
        desc: '永遠の領域を脅かす「シャドウ・タイタン」を討伐せよ。フェイの守護の負担を軽減するために。',
        type: 0, // kill
        focusStat: 'strength',
        difficulty: 100,
        rank: 'A+',
        minStrength: 1200,
        minWisdom: 45,
        minDexterity: 50,
        minLuck: 35,
        minFocus: 140,
        reward: 12000,
        daysLeft: 50
    }
];

const sideQuestCompletionDialogue = [
    // 0: 地図の賢者 エルドリン - discovery (永遠の航路図)
    [
        {speaker: "冒険者", text: "失われた「永遠の航路図」の断片をすべて集め、正確な地図を完成させました。……古代の道標が、忘れられた大陸を示していました。"},
        {speaker: "ギルドマスター", text: "よくやった。エルドリン、この地図が我々の故郷を襲った軍勢の起源に繋がるかもしれない。"},
        {speaker: "エルドリン", text: "……この航路は、深淵の彼方から来る者たちの古い道だ。黒い鎧の軍勢が通った痕跡が、ここに残っている。君たちの村が狙われた理由……おそらく、封印の鍵がそこにあったのだろう。本当に感謝する。この地図が、真実への一歩となる。"},
        {speaker: "ギルドマスター", text: "EXPオーブだ。これで力を蓄え、深淵に立ち向かおう。"}
    ],
    // 1: 歴史の語り部 タリア - fetch (古の石碑拓本)
    [
        {speaker: "冒険者", text: "忘れられた時代の「古の石碑の拓本」を5枚すべて集めてきました。……石碑の文字が、闇の王の名を繰り返していました。"},
        {speaker: "ギルドマスター", text: "タリア、これがヴォルガスの復活に関する記録か？"},
        {speaker: "タリア", text: "……そうだ。この石碑は、かつて深淵の王ヴォルガスを封じた者たちの警告だ。黒い鎧の軍勢は、彼の先兵に違いない。君たちの故郷は、封印の守りの要だったのかもしれない。私の語りが、君たちの復讐に力を貸すことになるだろう。心から感謝する。"},
        {speaker: "ギルドマスター", text: "EXPオーブを受け取ってくれ。真実が近づいている。"}
    ],
    // 2: 深海の探求者 コルバト - discovery (アビス・クリスタル洞窟)
    [
        {speaker: "冒険者", text: "深海の「アビス・クリスタル」の洞窟を発見し、潜水ルートを記録しました。……洞窟の壁に、黒い鎧の軍勢の紋章が刻まれていました。"},
        {speaker: "ギルドマスター", text: "深海にまで……コルバト、これは何を意味する？"},
        {speaker: "コルバト", text: "アビスクリスタルは深淵のエネルギーを吸収する……この洞窟は、ヴォルガスの力が地上に漏れ出る通路だったのかもしれない。あの軍勢は、海底から上陸した可能性がある。君たちの村が最初の標的だった理由が、少し見えてきた。本当にありがとう。この発見が、希望の光となる。"},
        {speaker: "ギルドマスター", text: "EXPオーブだ。深淵の脅威に備えよう。"}
    ],
    // 3: 反響の予見者 シララ - discovery (エコー・チャンバー)
    [
        {speaker: "冒険者", text: "「エコー・チャンバー」の隠された場所を探し出しました。……響く声が、ヴォルガスの復活を告げていました。"},
        {speaker: "ギルドマスター", text: "シララ、予言の詳細を教えてくれ。"},
        {speaker: "シララ", text: "……『黒い鎧が村を焼き、封印の鍵を奪うとき、王は目覚める』。君たちの故郷が鍵だったのだ。あの夜の襲撃は、ヴォルガスの復活の始まり……だが、君たちが生き延びたことも、予言の一部だ。希望はまだ残っている。本当に感謝する。この声が、君たちを導くだろう。"},
        {speaker: "ギルドマスター", text: "EXPオーブを受け取ってくれ。予言に抗う力を。"}
    ],
    // 4: 星の観測者 アストリッド - discovery (スターフォール高原観測点)
    [
        {speaker: "冒険者", text: "「スターフォール高原」の隠された観測点を特定しました。……星の配列が、深淵の門の開く日を示していました。"},
        {speaker: "ギルドマスター", text: "アストリッド、いつだ？"},
        {speaker: "アストリッド", text: "星は告げている……ヴォルガスの完全復活は近い。あの黒い軍勢は、門を開くための布石だった。君たちの村が破壊されたのは、守りの結界を壊すためだ。だが、星はまた、希望の光も示している。君たちがその光だ。本当にありがとう。この観測が、運命を変える鍵となる。"},
        {speaker: "ギルドマスター", text: "EXPオーブだ。星の導きに従おう。"}
    ],
    // 5: 森のドルイド リオラ - kill (毒のマンドラゴラ)
    [
        {speaker: "冒険者", text: "森を腐敗させる「毒のマンドラゴラ」の群れを根絶やしにしました。……根の奥に、深淵の魔力が残っていました。"},
        {speaker: "ギルドマスター", text: "リオラ、これはヴォルガスの影響か？"},
        {speaker: "リオラ", text: "……そうだ。深淵の腐敗が、自然にまで広がっていた。君たちの村が襲われたのも、同じ力の仕業だろう。森を浄化してくれてありがとう。この勝利が、大地全体の希望となる。自然は君たちを祝福する。"},
        {speaker: "ギルドマスター", text: "EXPオーブを受け取ってくれ。腐敗に負けない力を。"}
    ],
    // 6: 灰の学者 ボルカン - fetch (エターナル・アッシュ)
    [
        {speaker: "冒険者", text: "火山地帯から「エターナル・アッシュ」を8個集めてきました。……灰の中に、闇の炎が混じっていました。"},
        {speaker: "ギルドマスター", text: "ボルカン、これは何を意味する？"},
        {speaker: "ボルカン", text: "エターナル・アッシュに闇の炎……ヴォルガスの力が、地底から噴出しようとしている。あの黒い軍勢は、火山の道を通って地上に出たのかもしれない。君たちの故郷が最初だった理由が、少しわかる。本当に感謝する。この灰が、対抗の鍵となるだろう。"},
        {speaker: "ギルドマスター", text: "EXPオーブだ。炎に焼かれぬ力を。"}
    ],
    // 7: 幻の舞姫 ザラ - escort (呪われた劇場)
    [
        {speaker: "冒険者", text: "ザラを呪われた劇場まで無事に護衛しました。……舞の最中、幻影がヴォルガスの姿を見せました。"},
        {speaker: "ギルドマスター", text: "ザラ、その幻影は何を語った？"},
        {speaker: "ザラ", text: "私の舞が、幻影を呼び出した……ヴォルガスの復活が近いこと、そして封印の鍵が君たちの故郷にあったこと。あの襲撃は、鍵を奪うためのものだったわ。君たちが生き延びたのは、運命だ。本当にありがとう。この舞が、君たちの復讐を祝福する。"},
        {speaker: "ギルドマスター", text: "EXPオーブを受け取ってくれ。幻に惑わされぬ力を。"}
    ],
    // 8: 宝石の彫刻師 トーン - fetch (スターレム・ジェム)
    [
        {speaker: "冒険者", text: "「スターレム・ジェム」を6個集めてきました。……宝石の中に、闇の影が映っていました。"},
        {speaker: "ギルドマスター", text: "トーン、これはヴォルガスの力か？"},
        {speaker: "トーン", text: "スターレム・ジェムは光を映す……だが今は闇を映している。ヴォルガスの復活が近い証だ。あの黒い軍勢は、光を奪うために動いたのだろう。君たちの村が標的だったのは、純粋な光を守っていたからだ。本当に感謝する。この宝石が、闇を打ち砕く武器となる。"},
        {speaker: "ギルドマスター", text: "EXPオーブだ。光を守る力を。"}
    ],
    // 9: 永遠の守護者 フェイ - kill (シャドウ・タイタン)
    [
        {speaker: "冒険者", text: "「シャドウ・タイタン」を討伐しました。……その核に、ヴォルガスの刻印がありました。"},
        {speaker: "ギルドマスター", text: "フェイ、これは……"},
        {speaker: "フェイ", text: "シャドウ・タイタンは、ヴォルガスの分身の一つ……私の守護の領域まで侵食していた。あの黒い軍勢は、彼の意志そのものだ。君たちの故郷が破壊されたのは、永遠の守護を弱めるためだったのだろう。君たちがここにいるのは、運命の反撃だ。本当に、心から感謝する。この勝利が、永遠の均衡を取り戻す。"},
        {speaker: "ギルドマスター", text: "EXPオーブを受け取ってくれ。永遠の守りを破らぬ力を。"}
    ]
];

function generateSideQuest(npcIdx) {
    if (npcIdx < 0 || npcIdx >= sideQuestData.length) {
        console.error('Invalid NPC index for side quest');
        return null;
    }

    const data = sideQuestData[npcIdx];

    // 既存の同じNPCのサイドクエストが進行中なら生成しない（1人1クエスト限定）
    const existing = gameState.quests.find(q => q.side && q.npcIdx === npcIdx);
    if (existing) {
        return null; // またはalertで通知（呼び出し側で処理）
    }

    return {
        id: gameState.nextId++,
        desc: data.desc,
        difficulty: data.difficulty,
        rank: data.rank,
        minStrength: data.minStrength || 0,
        minWisdom: data.minWisdom || 0,
        minDexterity: data.minDexterity || 0,
        minLuck: data.minLuck || 0,
        focusStat: data.focusStat,
        minFocus: data.minFocus,
        type: data.type, // 0:kill, 1:discovery, 2:escort, 3:fetch
        item: data.item || null, // fetchの場合のみ
        npcIdx: npcIdx,
        daysLeft: data.daysLeft,
        reward: data.reward,
        assigned: [],
        inProgress: false,
        side: true,
        // 特別報酬：EXP Orb（レベル+5）
        specialReward: { name: 'EXP Orb', type: 'consumable', effect: 'level_up', amount: 5 }
    };
}

function generateTempAdventurer(){
    const repFactor = Math.max(0.1, (gameState.reputation + 50) / 100);
    const primary = Math.floor(Math.random()*4);
    let s=Math.max(1, Math.floor((1+Math.random()*5) * repFactor)), w=Math.max(1, Math.floor((1+Math.random()*5) * repFactor)), d=Math.max(1, Math.floor((1+Math.random()*5) * repFactor)), l=Math.max(1, Math.floor((1+Math.random()*5) * repFactor));
    if(primary===0) s=Math.floor(20 * repFactor + Math.random()*(20 * repFactor)) + Math.floor(gameState.reputation / 20);
    else if(primary===1) w=Math.floor(20 * repFactor + Math.random()*(20 * repFactor)) + Math.floor(gameState.reputation / 20);
    else if(primary===2) d=Math.floor(20 * repFactor + Math.random()*(20 * repFactor)) + Math.floor(gameState.reputation / 20);
    else l=Math.floor(20 * repFactor + Math.random()*(20 * repFactor)) + Math.floor(gameState.reputation / 20);
    const total = s+w+d+l;
    const gender = Math.random() < 0.5 ? 'M' : 'F';
    const name = randomName(gender);
    const statAbbr = ['STR','WIS','DEX','LUC'][primary];
    const image = `${statAbbr}_${gender}.png`;
    return {
        id: gameState.nextId++,
        name: name,
        level:1, exp:0,
        strength:s, wisdom:w, dexterity:d, luck:l,
        hp:100, maxHp:100, mp:50, maxMp:50,
        equipment:[],
        buffs: [],
        image: image,
        hiringCost:Math.floor(20+total),
        recruitingCost:Math.floor(100+total*3),
        temp:true, busy:false, generatedDay:0,
        primary: primary
    };
}

function showQuestCompletionStory(story) {
    let page = 0;
    const total = story.length;

    const renderPage = () => {
        const line = story[page];
        let html = '';

        if (line.image) {
            html += `<img src="${line.image}" alt="${line.speaker}" style="float:left; margin:0 20px 20px 0; width:160px; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.4);">`;
        }

        html += `<div style="overflow:hidden;">`;
        html += `<p style="font-size:1.5em; margin:0 0 10px;"><strong>${line.speaker}:</strong></p>`;
        html += `<p style="font-size:1.3em; line-height:1.7;">${line.text.replace(/{player}/g, playerName || 'あなた')}</p>`;
        html += `</div>`;

        document.getElementById('modalContent').innerHTML = html;
        document.getElementById('modalTitle').innerText = 'クエスト完了 — 特別な一幕';
        document.getElementById('pageInfo').innerText = `${page + 1} / ${total}`;

        document.getElementById('prevBtn').style.display = page > 0 ? 'inline-block' : 'none';
        document.getElementById('nextBtn').style.display = page < total - 1 ? 'inline-block' : 'none';
    };

    document.getElementById('prevBtn').onclick = () => { page--; renderPage(); };
    document.getElementById('nextBtn').onclick = () => { page++; renderPage(); };

    renderPage();
    document.getElementById('eventModal').style.display = 'flex';
}

// Use 1 potion from stack on character
function usePotionOnChar(charIdx, potionName) {
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[charIdx];
    if (!adv) return;
    const stackIdx = gameState.inventory.findIndex(i => i.name === potionName);
    if (stackIdx === -1) {
        alert('ポーションが見つかりません');
        return;
    }
    const potion = gameState.inventory[stackIdx];
    if ((potion.qty || 1) <= 0) {
        gameState.inventory.splice(stackIdx, 1);
        return;
    }
    if (potion.restore === 'hp') {
        adv.hp = Math.min(adv.maxHp, adv.hp + potion.amount);
    } else if (potion.restore === 'mp') {
        adv.mp = Math.min(adv.maxMp, adv.mp + potion.amount);
    }
    potion.qty--;
    if (potion.qty <= 0) {
        gameState.inventory.splice(stackIdx, 1);
    }
    renderCurrentCharacter();
}



function generateKillRecruit(difficulty) {
    const primary = Math.floor(Math.random()*4);
    const repFactor = Math.max(0.1, (gameState.reputation + difficulty * 20 + 50) / 100);
    let s = Math.max(1, Math.floor((1 + Math.random() * 2) * repFactor)), w = Math.max(1, Math.floor((1 + Math.random() * 2) * repFactor)), d = Math.max(1, Math.floor((1 + Math.random() * 2) * repFactor)), l = Math.max(1, Math.floor((1 + Math.random() * 2) * repFactor));
    if (primary === 0) s = Math.floor(5 * repFactor + Math.random() * (5 * repFactor)) + Math.floor(gameState.reputation / 20) + Math.floor(difficulty / 2);
    else if (primary === 1) w = Math.floor(5 * repFactor + Math.random() * (5 * repFactor)) + Math.floor(gameState.reputation / 20) + Math.floor(difficulty / 2);
    else if (primary === 2) d = Math.floor(5 * repFactor + Math.random() * (5 * repFactor)) + Math.floor(gameState.reputation / 20) + Math.floor(difficulty / 2);
    else l = Math.floor(5 * repFactor + Math.random() * (5 * repFactor)) + Math.floor(gameState.reputation / 20) + Math.floor(difficulty / 2);
    const gender = Math.random() < 0.5 ? 'M' : 'F';
    const name = randomName(gender);
    const statAbbr = ['STR','WIS','DEX','LUC'][primary];
    const image = `${statAbbr}_${gender}.png`;
    let adv = {
        id: gameState.nextId++,
        name: name,
        level: 1, exp: 0,
        strength: s, wisdom: w, dexterity: d, luck: l,
        hp: 100, maxHp: 100, mp: 50, maxMp: 50,
        equipment: [],
        buffs: [],
        image: image,
        busy: false,
        primary: primary
    };
    const startLevel = Math.max(1, Math.floor(difficulty / 2));
    for (let lv = 1; lv < startLevel; lv++) {
        const r = Math.random();
        let sb = 1, wb = 1, db = 1, lb = 1;
        if (r < 0.4) wb += 1;
        else if (r < 0.6) sb += 1;
        else if (r < 0.8) db += 1;
        else lb += 1;
        adv.strength += sb;
        adv.wisdom += wb;
        adv.dexterity += db;
        adv.luck += lb;
        adv.maxHp += 20;
        adv.maxMp += 10;
    }
    adv.level = startLevel;
    adv.hp = adv.maxHp;
    adv.mp = adv.maxMp;
    adv.exp = 0;
    return adv;
}

function generateEnemies(q) {
    q.enemies = [];
    for (let i = 0; i < q.numEnemies; i++) {
        const config = enemyConfigs[Math.floor(Math.random() * enemyConfigs.length)];
        const baseStat = Math.floor((Math.floor(gameState.reputation) + 1) * 0.6 + Math.random() * 10);
        const e = {
            id: `enemy_${q.id}_${i}`,
            name: config.ja + ` ${i + 1}`,
            image: `${config.en}_enemy.png`,
            hp: Math.floor(60 + baseStat * 1.5 + Math.random() * 30),
            maxHp: 0,
            mp: Math.floor(20 + baseStat * 0.5 + Math.random() * 10),
            maxMp: 0,
            strength: Math.max(1, Math.floor(baseStat * 0.8 + Math.random() * 5)),
            wisdom: Math.max(1, Math.floor(baseStat * 0.8 + Math.random() * 5)),
            dexterity: Math.max(1, Math.floor(baseStat * 0.8 + Math.random() * 5)),
            luck: Math.max(1, Math.floor(baseStat * 0.5 + Math.random() * 3)),
            defending: false,
            action: null,
            target: null
        };
        e.maxHp = e.hp;
        e.maxMp = e.mp;
        q.enemies.push(e);
    }
}

function rollStat(adv, statName) {
    if (!adv) return 0;
    const base = getEffectiveStat(adv, statName);
    const variance = 0.25;
    const minMod = base * (1 - variance);
    const maxMod = base * (1 + variance);
    const final = Math.max(Math.round(minMod + Math.random() * (maxMod - minMod)), 1);
    return final;
}

function getEffectiveStat(obj, stat) {
    if (!obj) return 0;
    const base = obj[stat];
    let equipmentBonus = obj.equipment ? obj.equipment.reduce((sum, e) => e.stat === stat ? sum + e.bonus : sum, 0) : 0;
    let buffBonus = 0;
    if (obj.buffs) {
        obj.buffs.forEach(b => {
            if (b.stat === stat) buffBonus += b.bonus;
        });
    }
    const mpPct = obj && typeof obj.mp === 'number' && typeof obj.maxMp === 'number' && obj.maxMp > 0 ? obj.mp / obj.maxMp : 1;
    let mpBonus;
    if (mpPct >= 0.5) {
        mpBonus = 0.20 * (mpPct - 0.5) / 0.5;
    } else {
        mpBonus = -0.20 * (0.5 - mpPct) / 0.5;
    }
    const totalPctBonus = equipmentBonus + buffBonus + (mpBonus * 100);
    return Math.max(1, Math.floor(base * (1 + totalPctBonus / 100)));
}

function calcSumStats(adv){
    return ['strength','wisdom','dexterity','luck'].reduce((sum, st) => sum + getEffectiveStat(adv, st), 0);
}

function levelUp(adv, forceLevels = 0) {
    let levelsGained = forceLevels;
    
    // Normal EXP-based leveling (only if no forceLevels)
    if (forceLevels === 0) {
        while (adv.exp >= adv.level * 100) {
            adv.exp -= adv.level * 100;
            levelsGained++;
        }
    }

    // Apply growth for each level gained
    for (let i = 0; i < levelsGained; i++) {
        adv.level++;

        const r = Math.random();
        let sb = 1, wb = 1, db = 1, lb = 1;
        if (r < 0.4) wb += 4;
        else if (r < 0.6) sb += 4;
        else if (r < 0.8) db += 4;
        else lb += 4;

        adv.strength += sb;
        adv.wisdom += wb;
        adv.dexterity += db;
        adv.luck += lb;

        adv.maxHp += 20;
        adv.maxMp += 10;
        adv.hp = adv.maxHp;  // Full heal on each level up
        adv.mp = adv.maxMp;
    }
}
function findAdv(id){return gameState.adventurers.find(a=>a.id===id);}

function assign(questId, advId){
    const q=gameState.quests.find(q=>q.id===questId);
    if(!q) return;
    if (q.inProgress && !q.training && q.type !== 8) {
        alert("クエスト進行中は冒険者を追加できません");
        return;
    }
    const maxSlots = q.training ? 2 : 4;
    if(q.assigned.length >= maxSlots){
        alert(q.training ? "トレーニングクエストは最大2人までです。" : "クエストは満員です");
        return;
    }
    const adv=findAdv(advId);
    if(!adv) return;
    if(adv.mp <= 0){ alert(`${adv.name}のMPがありません！ポーションで回復するか、回復を待ってください。`); return; }
    const cost=adv.temp?adv.hiringCost:0;
    if(cost > 0 && !spendGold(cost)) return;
    q.assigned.push(advId);
    adv.busy=true;
    updateDisplays();
}

function unassign(questId, advId){
    const q=gameState.quests.find(q=>q.id===questId);
    if(!q || q.inProgress) return;
    const idx = q.assigned.indexOf(advId);
    if(idx === -1) return;
    q.assigned.splice(idx, 1);
    const adv = findAdv(advId);
    if(adv){
        adv.busy = false;
        if(adv.temp){
            gameState.gold += adv.hiringCost;
        }
    }
    updateDisplays();
}

function rejectQuest(qId) {
    const q = gameState.quests.find(qq => qq.id === qId);
    if (!q) return;
    if (q.assigned.length > 0 || q.inProgress || q.defense || q.training || q.playerPosted) return;
    const penalty = 0.1 * q.difficulty;
    gameState.reputation -= penalty;
    gameState.eventHistory.unshift({day: gameState.day, message: `クエスト "${q.desc}" を拒否。評判 -${penalty.toFixed(1)}。`});
    const idx = gameState.quests.findIndex(qq => qq.id === qId);
    if (idx !== -1) {
        gameState.quests.splice(idx, 1);
    }
    alert(`クエストを拒否しました！評判 -${penalty.toFixed(1)}`);
    updateDisplays();
}

function buy(i){
    const it=shopItems[i];
    if(!spendGold(it.cost)) return;
    addToInventory(it, 1);
    updateDisplays();
}



function recruit(i){
    const numPerms = gameState.adventurers.filter(a => !a.temp).length;
    if(numPerms >= gameState.maxPermanentSlots){
        alert('ギルドは満杯です！拡張を購入してさらに募集してください。');
        return;
    }
    const adv=gameState.recruitPending[i];
    if(!spendGold(adv.recruitingCost)) return;
    const newAdv={...adv};
    delete newAdv.temp; delete newAdv.generatedDay;
    newAdv.hp = newAdv.maxHp;
    newAdv.mp = newAdv.maxMp;
    newAdv.busy=false;
    newAdv.buffs = [];
    gameState.adventurers.push(newAdv);
    gameState.recruitPending.splice(i,1);
    updateDisplays();
}

function firePerm(pIdx){
    const perms=gameState.adventurers.filter(a=>!a.temp);
    const adv=perms[pIdx];
    if (!adv) return;
    if (adv.busy) {
        alert("現在クエスト中の冒険者を解雇できません！");
        return;
    }
    if(confirm(`${adv.name}を解雇しますか？取り消せません。`)){
        gameState.quests.forEach(q => {
            const idx = q.assigned.indexOf(adv.id);
            if (idx > -1) {
                q.assigned.splice(idx, 1);
            }
        });
        const idx = gameState.adventurers.findIndex(a=>a.id===adv.id);
        if(idx > -1){
            gameState.adventurers.splice(idx,1);
        }
        currentCharIndex = Math.max(0, currentCharIndex - 1);
        renderCurrentCharacter();
        updateDisplays();
    }
}

function equipToChar(pIdx, itemId) {
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[pIdx];
    if (!adv) return;
    if (adv.equipment.length >= 2) {
        alert('最大2つまで装備可能です');
        return;
    }
    const itemIdx = gameState.inventory.findIndex(it => it.id === itemId);
    if (itemIdx === -1) return;
    const item = gameState.inventory[itemIdx];
    if (!item || !item.stat) return;
    adv.equipment.push(item);
    gameState.inventory.splice(itemIdx, 1);
    renderCurrentCharacter();
}

function removeFromChar(pIdx, eqIdx){
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[pIdx];
    const item = adv.equipment[eqIdx];
    adv.equipment.splice(eqIdx,1);
    addToInventory(item,1);
    renderCurrentCharacter();
}



function useConsumable(pIdx, itemId) {
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[pIdx];
    if (!adv) return;
    const itemIdx = gameState.inventory.findIndex(it => it.id === itemId);
    if (itemIdx === -1) return;
    const item = gameState.inventory[itemIdx];
    if (!item || !item.buff) return;
    adv.buffs = adv.buffs || [];
    adv.buffs.push({
        stat: item.buff.stat,
        bonus: item.buff.bonus,
        daysLeft: item.buff.days,
        percent: item.buff.percent || false,
        type: item.buff.type
    });
    gameState.inventory.splice(itemIdx, 1);
    renderCurrentCharacter();
}

function buyMaterial(idx) {
    if (idx >= gameState.dailyMaterials.length) return;
    const mat = gameState.dailyMaterials[idx];
    if (!spendGold(mat.price)) return;
    addToInventory(mat, 1);
    gameState.dailyMaterials.splice(idx, 1);
    document.getElementById('shopContent').innerHTML = renderCurrentShopPage();
    updateDisplays();
}

let currentShopPage = 0;

const shopSections = [
    { title: "アイテム購入", render: renderShopPurchase },
    { title: "今日の素材", render: renderDailyMaterials },
    { title: "ギルド拡張", render: renderGuildExpansion },
    { title: "商人を脅す", render: renderCorruption },
    { title: "アイテム売却", render: renderSellItems }
];

function renderShopPurchase() {
    let html = '<ul class="shop-list">';
    shopItems.forEach((it, i) => {
        html += `<li class="shop-item">`;
        html += `<strong>${it.name}</strong> - ${it.cost}g`;
        if (it.stat) html += ` <span class="bonus">(+${it.bonus} ${statFull[it.stat]})</span>`;
        if (it.type === 'potion') html += ` <span class="bonus">(${it.restore.toUpperCase()} +${it.amount})</span>`;
        html += ` <button class="buy-btn" onclick="buy(${i})">購入</button>`;
        html += `</li>`;
    });
    html += '</ul>';
    return html;
}

function renderDailyMaterials() {
    if (gameState.dailyMaterials && gameState.dailyMaterials.length > 0) {
        let html = '<ul class="shop-list">';
        gameState.dailyMaterials.forEach((mat, i) => {
            html += `<li class="shop-item">`;
            html += `<strong>${mat.name}</strong> - ${mat.price}g`;
            html += ` <button class="buy-btn" onclick="buyMaterial(${i})">購入</button>`;
            html += `</li>`;
        });
        html += '</ul>';
        return html;
    }
    return '<p class="empty-msg">今日の素材はありません。</p>';
}

function renderGuildExpansion() {
    const currentSlots = gameState.maxPermanentSlots || 4;
    if (currentSlots < 12) {
        const nextSlots = currentSlots + 1;
        const level = nextSlots - 4;
        const cost = 500 + 250 * (level - 1);
        return `<div class="expansion-section">
            <p>現在の恒久冒険者スロット: <strong>${currentSlots}</strong></p>
            <p>次のスロット: <strong>${nextSlots}</strong> - ${cost}g でアップグレード</p>
            <button class="buy-btn large" onclick="buyExpansion()">拡張購入</button>
        </div>`;
    }
    return '<p class="empty-msg">ギルドは最大まで拡張されています。</p>';
}

function renderCorruption() {
    return `<div class="corruption-section">
        <p>10 評判を消費して 100g を得る</p>
        <button class="buy-btn warn" onclick="corrupt()">商人を脅す</button>
    </div>`;
}

function renderSellItems() {
    let html = '';
    const allItems = [];
    if (gameState.sellables) {
        gameState.sellables.forEach(item => allItems.push({...item, source: 'sellables'}));
    }
    gameState.inventory.forEach(item => allItems.push({...item, source: 'inventory'}));

    if (allItems.length === 0) {
        return '<p class="empty-msg">売却可能なアイテムがありません。</p>';
    }

    const grouped = {};
    allItems.forEach((item, origIndex) => {
        const key = item.name;
        if (!grouped[key]) {
            grouped[key] = { ...item, items: [] };
        }
        grouped[key].items.push({source: item.source, index: origIndex});
    });

    html += '<ul class="shop-list sell-list">';
    Object.values(grouped).forEach(group => {
        let count = 0;
        group.items.forEach(entry => {
            const actualItem = entry.source === 'inventory' 
                ? gameState.inventory[entry.index] 
                : gameState.sellables?.[entry.index];
            if (actualItem) count += (actualItem.qty || 1);
        });

        const randMinMax = getDailyRandomFraction(group.name);
        const randVariance = getDailyRandomFraction(group.name + 'var');

        let basePrice = 0;
        if (group.stat) basePrice = Math.floor((shopItems.find(s => s.name === group.name)?.cost || 100) * 0.7);
        else if (group.type === 'potion') basePrice = Math.floor((shopItems.find(s => s.name === group.name)?.cost || 30) * 0.5);
        else if (group.type === 'consumable') basePrice = Math.floor((group.buff?.bonus || 100) * 5);
        else if (group.minPrice !== undefined && group.maxPrice !== undefined) {
            basePrice = Math.floor(group.minPrice + randMinMax * (group.maxPrice - group.minPrice + 1));
        } else {
            const materialBases = { "鉄鉱石": 30, "薬草": 20, "スパイス": 55, "宝石": 115, "鋼のインゴット": 80, "活力の粉": 60, "魔法の結晶": 150, "炎の粉": 70 };
            basePrice = materialBases[group.name] || 50;
        }

        const variance = Math.floor(basePrice * 0.4);
        const singlePrice = Math.max(5, basePrice + Math.floor(randVariance * (variance * 2 + 1) - variance));
        const totalPrice = singlePrice * count;

        html += `<li class="shop-item">`;
        html += `<strong>${group.name}</strong>`;
        if (group.stat) html += ` <span class="bonus">(+${group.bonus} ${statFull[group.stat]})</span>`;
        if (group.type === 'potion') html += ` <span class="bonus">(${group.restore?.toUpperCase()} +${group.amount})</span>`;
        html += ` <em>x${count}</em> - ${singlePrice}g/個 (合計 ${totalPrice}g)`;
        if (count === 1) {
            html += ` <button class="sell-btn" onclick="sellStackedItem('${group.name}', 1)">売却</button>`;
        } else {
            html += ` <button class="sell-btn" onclick="sellStackedItem('${group.name}', 1)">1つ売却</button>`;
            html += ` <button class="sell-btn all" onclick="sellStackedItem('${group.name}', ${count})">すべて売却</button>`;
        }
        html += `</li>`;
    });
    html += '</ul>';
    return html;
}

function renderCurrentShopPage() {
    const section = shopSections[currentShopPage];
    let html = `<h2 class="shop-title">${section.title}</h2>`;
    html += `<div class="char-nav shop-nav">`;
    html += `<button onclick="prevShopPage()">前</button>`;
    html += `<span class="page-counter">${currentShopPage + 1} / ${shopSections.length}</span>`;
    html += `<button onclick="nextShopPage()">次</button>`;
    html += `</div>`;
    html += section.render();  // Each render function returns a string
    
    // Directly update the DOM
    const contentElement = document.getElementById('shopContent');
    if (contentElement) {
        contentElement.innerHTML = html;
    }
    
    // Also return the html for flexibility (in case any old code expects it)
    return html;
}
function prevShopPage() {
    currentShopPage = (currentShopPage - 1 + shopSections.length) % shopSections.length;
    renderCurrentShopPage();
}

function nextShopPage() {
    currentShopPage = (currentShopPage + 1) % shopSections.length;
    renderCurrentShopPage();
}

function toggleShop() {
    const modal = document.getElementById('shopModal');
    if (modal.style.display === 'block') {
        modal.style.display = 'none';
    } else {
        currentShopPage = 0;
        renderCurrentShopPage();
        modal.style.display = 'block';
    }
}

function sellStackedItem(name, amount) {
    let remaining = amount;
    let totalGold = 0;

    // サンプルアイテムを探す
    const sampleItem = gameState.inventory.find(i => i.name === name) ||
                       (gameState.sellables ? gameState.sellables.find(i => i.name === name) : null);

    if (!sampleItem) {
        alert('売却するアイテムが見つかりません。');
        return;
    }

    // 日付固定の擬似乱数を取得（表示価格と完全に一致させるため）
    const randMinMax   = getDailyRandomFraction(name);           // minPrice/maxPrice 用
    const randVariance = getDailyRandomFraction(name + 'var');   // 変動幅用

    let basePrice = 0;
    if (sampleItem.stat) {  // 装備品
        basePrice = Math.floor((shopItems.find(s => s.name === name)?.cost || 100) * 0.7);
    } else if (sampleItem.type === 'potion') {  // ポーション（固定価格）
        basePrice = Math.floor((shopItems.find(s => s.name === name)?.cost || 30) * 0.5);
    } else if (sampleItem.type === 'consumable') {
        basePrice = Math.floor((sampleItem.buff?.bonus || 100) * 5);
    } else if (sampleItem.minPrice !== undefined && sampleItem.maxPrice !== undefined) {
        // 日固定乱数で価格決定（ショップ表示と一致）
        basePrice = Math.floor(sampleItem.minPrice + randMinMax * (sampleItem.maxPrice - sampleItem.minPrice + 1));
    } else {
        const materialBases = { "鉄鉱石": 30, "薬草": 20, "スパイス": 55, "宝石": 115, "鋼のインゴット": 80, "活力の粉": 60, "魔法の結晶": 150, "炎の粉": 70 };
        basePrice = materialBases[name] || 50;
    }

    const variance = Math.floor(basePrice * 0.4);
    // 日固定乱数で変動幅を決定（ショップ表示と一致）
    const singlePrice = Math.max(5, basePrice + Math.floor(randVariance * (variance * 2 + 1) - variance));

    // inventoryから売却
    for (let i = gameState.inventory.length - 1; i >= 0 && remaining > 0; i--) {
        const item = gameState.inventory[i];
        if (item.name === name) {
            const available = item.qty || 1;
            const sellNow = Math.min(remaining, available);

            if (item.qty) {  // スタックアイテム（ポーション・素材など）
                item.qty -= sellNow;
                if (item.qty <= 0) {
                    gameState.inventory.splice(i, 1);
                }
            } else {  // 個別アイテム（装備品など）
                gameState.inventory.splice(i, 1);
            }

            remaining -= sellNow;
            totalGold += singlePrice * sellNow;
        }
    }

    // sellablesからも売却（必要に応じて）
    if (gameState.sellables && remaining > 0) {
        for (let i = gameState.sellables.length - 1; i >= 0 && remaining > 0; i--) {
            const item = gameState.sellables[i];
            if (item.name === name) {
                gameState.sellables.splice(i, 1);
                remaining--;
                totalGold += singlePrice;
            }
        }
    }

    if (remaining > 0) {
        alert('在庫が不足しています。');
        return;
    }

    gameState.gold += totalGold;
    alert(`${name} を ${amount}個 売却しました！ +${totalGold}g`);

    // ショップモーダルを更新（価格が日固定なので再計算しても同じ値になる）
    document.getElementById('shopContent').innerHTML = renderCurrentShopPage();

    // 他の表示も更新
    updateDisplays();
}

// この関数をコードのどこかに追加してください（他の関数の外、グローバルスコープに）
function getDailyRandomFraction(str) {
    let hash = gameState.day * 7919;  // 日付をシードに
    for (let i = 0; i < str.length; i++) {
        hash = (hash * 31 + str.charCodeAt(i)) & 0xFFFFFFFF;
    }
    // 0.0 ~ 1.0 の範囲の擬似乱数（同じ日・同じ文字列なら常に同じ値）
    return ((hash >>> 0) % 1000000) / 1000000;
}

function getRecruitsHtml(){
    const numPerms = gameState.adventurers.filter(a => !a.temp).length;
    const full = numPerms >= gameState.maxPermanentSlots;
    if(!gameState.recruitPending.length) return '<h3>募集保留</h3><p>なし</p>';
    let html='<h3>募集保留</h3>';
    gameState.recruitPending.forEach((adv,i)=>{
        const baseStr = adv.strength;
        const baseWis = adv.wisdom;
        const baseDex = adv.dexterity;
        const baseLuk = adv.luck;
        const effStr = getEffectiveStat(adv, 'strength');
        const effWis = getEffectiveStat(adv, 'wisdom');
        const effDex = getEffectiveStat(adv, 'dexterity');
        const effLuk = getEffectiveStat(adv, 'luck');
        const equipStr = effStr - baseStr;
        const equipWis = effWis - baseWis;
        const equipDex = effDex - baseDex;
        const equipLuk = effLuk - baseLuk;
        const stats=`Lv ${adv.level} | <img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${effStr} (${baseStr}+${equipStr}) <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${effWis} (${baseWis}+${equipWis}) <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${effDex} (${baseDex}+${equipDex}) <img src="LUC.png" class="stat-icon" title="運"> 運 ${effLuk} (${baseLuk}+${equipLuk})`;
        const expNeeded = adv.level * 100;
        const expPct = Math.min(100, (adv.exp / expNeeded) * 100);
        const img=`<img src="${adv.image}" class="adventurer-img" alt="${adv.name}">`;
        const nameHtml = getNameHtml(adv);
        const btnHtml = full ? '<button disabled>ギルド満杯</button>' : `<button onclick="recruit(${i})">募集する</button>`;
        html+=`<div class="adventurer-card" draggable="true" data-adv-id="${adv.id}">
            ${img}${nameHtml}<br><small class="stats">${stats}</small><br>
            <div class="progress-bar"><div class="progress-fill exp-fill" style="width:${expPct}%"></div></div> 経験値 ${adv.exp}/${expNeeded}<br>
            コスト: ${adv.recruitingCost}g ${btnHtml}
        </div>`;
    });
    return html;
}

function getAvailableHtml(){
    const avail=gameState.adventurers.filter(a=>!a.busy);
    let html='';
    avail.forEach(adv=>{
        const baseStr = adv.strength;
        const baseWis = adv.wisdom;
        const baseDex = adv.dexterity;
        const baseLuk = adv.luck;
        const effStr = getEffectiveStat(adv, 'strength');
        const effWis = getEffectiveStat(adv, 'wisdom');
        const effDex = getEffectiveStat(adv, 'dexterity');
        const effLuk = getEffectiveStat(adv, 'luck');
        const equipStr = effStr - baseStr;
        const equipWis = effWis - baseWis;
        const equipDex = effDex - baseDex;
        const equipLuk = effLuk - baseLuk;
        const stats=`Lv ${adv.level} | <img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${effStr} (${baseStr}+${equipStr}) <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${effWis} (${baseWis}+${equipWis}) <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${effDex} (${baseDex}+${equipDex}) <img src="LUC.png" class="stat-icon" title="運"> 運 ${effLuk} (${baseLuk}+${equipLuk})`;
        const expNeeded = adv.level * 100;
        const expPct = Math.min(100, (adv.exp / expNeeded) * 100);
        const hpPct = adv && typeof adv.hp === 'number' && typeof adv.maxHp === 'number' && adv.maxHp > 0 ? Math.max(0, Math.min(100, (adv.hp / adv.maxHp) * 100)) : 0;
        const mpPct = adv && typeof adv.mp === 'number' && typeof adv.maxMp === 'number' && adv.maxMp > 0 ? Math.max(0, Math.min(100, (adv.mp / adv.maxMp) * 100)) : 0;
        const hpDisplay = Number(adv.hp) || 0;
        const maxHpDisplay = Number(adv.maxHp) || 0;
        const mpDisplay = Number(adv.mp) || 0;
        const maxMpDisplay = Number(adv.maxMp) || 0;
        const img=`<img src="${adv.image}" class="adventurer-img" alt="${adv.name}">`;
        const nameHtml = getNameHtml(adv);
        const cost=adv.temp?`雇用: ${adv.hiringCost}g`:'恒久的';
        html+=`<div class="adventurer-card" draggable="true" data-adv-id="${adv.id}">
            ${img}${nameHtml}<br>
            <small class="stats">${stats}</small><br>
            <div class="progress-bar"><div class="progress-fill exp-fill" style="width:${expPct}%"></div></div> 経験値 ${adv.exp}/${expNeeded}<br>
            <div class="progress-bar"><div class="progress-fill hp-fill" style="width:${hpPct}%"></div></div> HP ${hpDisplay}/${maxHpDisplay}<br>
            <div class="progress-bar"><div class="progress-fill mp-fill" style="width:${mpPct}%"></div></div> MP ${mpDisplay}/${maxMpDisplay}<br>
            ${cost}
        </div>`;
    });
    if(!avail.length) html+='<p>今日利用可能な冒険者なし。</p>';
    return html;
}

function getQuestsHtml(){
    let html='<h3>利用可能クエスト</h3>';
    gameState.quests.forEach(q=>{
        let typeClass = questTypeClasses[q.type] || '';
        if (q.side) typeClass += ' side';
        if (q.training) typeClass = 'training';
        if (q.playerPosted) {
            if (q.type === 6) typeClass = 'main';
            else if (q.type === 7) typeClass = 'dungeon';
            else if (q.type === 8) typeClass = 'trade';
        }
        const teamStr=q.assigned.reduce((s,id)=>s + getEffectiveStat(findAdv(id), 'strength'), 0);
        const teamWis=q.assigned.reduce((s,id)=>s + getEffectiveStat(findAdv(id), 'wisdom'), 0);
        const teamDex=q.assigned.reduce((s,id)=>s + getEffectiveStat(findAdv(id), 'dexterity'), 0);
        const teamLuk=q.assigned.reduce((s,id)=>s + getEffectiveStat(findAdv(id), 'luck'), 0);
        let estDays = 'N/A';
        let chance = 0;
        const maxSlots = q.training ? 2 : 4;
        if (q.assigned.length > 0) {
            if (q.training) {
                estDays = '1日';
                chance = 100;
            } else if (q.defense) {
                estDays = 'Today: Battle';
                chance = 'Tactical Combat';
            } else if (q.type === 8) {
                const meetsAll = teamDex >= q.minDexterity && teamLuk >= q.minLuck;
                if (!meetsAll) {
                    estDays = '失敗 (DEX/LUC不足)';
                    chance = 0;
                } else {
                    let days;
                    if (q.inProgress && q.tradeRemainingDays !== undefined && q.tradeRemainingDays > 0) {
                        days = q.tradeRemainingDays;
                        estDays = `${days}日残り (確定成功)`;
                    } else {
                        const avgDex = teamDex / q.assigned.length || 1;
                        const avgLuc = teamLuk / q.assigned.length || 1;
                        days = calcTradeRequiredDays(avgDex, avgLuc);
                        estDays = q.inProgress ? `${days}日残り (確定成功)` : `${days}日 (確定成功)`;
                    }
                    chance = 100;
                }
            } else {
                const meetsAll = teamStr >= q.minStrength && teamWis >= q.minWisdom && teamDex >= q.minDexterity && teamLuk >= q.minLuck;
                if (!meetsAll) {
                    estDays = '失敗';
                    chance = 0;
                } else {
                    let teamFocus = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), q.focusStat), 0);
                    const excess = (teamFocus / q.minFocus) - 1;
                    const prob = Math.min(0.5, 0.1 + Math.max(0, excess) * 0.2);
                    chance = Math.round(prob * 100);
                    estDays = Math.max(1, Math.ceil(1 / prob));
                }
            }
        }
        let assignedHtml = '';
        q.assigned.forEach(id=>{
            const a=findAdv(id);
            if(a){
                if(q.inProgress){
                    const nameHtml = getNameHtml(a);
                    assignedHtml += `<span class="assigned-adventurer"><img src="${a.image}" class="adventurer-img">${nameHtml}</span>`;
                } else {
                    const nameHtml = getNameHtml(a);
                    assignedHtml += `<span class="assigned-adventurer"><img src="${a.image}" class="adventurer-img">${nameHtml} <button class="cancel-btn" onclick="unassign(${q.id}, ${id})">X</button></span>`;
                }
            }
        });
        const minHtml = `<img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${q.minStrength} | <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${q.minWisdom} | <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${q.minDexterity} | <img src="LUC.png" class="stat-icon" title="運"> 運 ${q.minLuck}`;
        const teamHtml = `<img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${teamStr} | <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${teamWis} | <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${teamDex} | <img src="LUC.png" class="stat-icon" title="運"> 運 ${teamLuk}`;
        html+=`<div class="quest-card ${typeClass}" data-quest-id="${q.id}"
                 ondrop="drop(event)" ondragover="allowDrop(event)" ondragleave="dragLeave(event)">
            <h3>${q.desc}</h3>`;
        if (q.training) {
            html += `<p><strong>常時利用可能なトレーニングクエスト（最大2人）</strong></p>`;
            html += `<p>低いレベルの冒険者はペアの高いレベル相当のEXPを獲得。リスクなし、報酬なし。</p>`;
            html += `<p>難易度: ${q.difficulty}（固定） | 必要ステータス: 全て0</p>`;
        } else {
            html += `<p>難易度: ${q.difficulty} | 残り日数: ${q.daysLeft} | 報酬: ${q.reward}g</p>`;
            if (q.defense) {
                html += `<p><strong style="color:red;">防衛クエスト - 1-4人の防衛者を割り当てなければゲームオーバー！</strong></p>`;
            }
            if (!q.defense && !q.playerPosted) {
                html += `<p>必要: ${minHtml}</p>`;
            }
        }
        html += `<p>予想日数: ${estDays}</p>
            <p>チーム: ${teamHtml} | 成功確率: ${chance}%</p>
            <div>割り当て済み (${q.assigned.length}/${maxSlots}): ${assignedHtml}</div>`;
        if(q.assigned.length === 0 && !q.inProgress && !q.defense && !q.training && !q.playerPosted){
            const rejectPenalty = (0.1 * q.difficulty).toFixed(1);
            html += `<p><button onclick="rejectQuest(${q.id})" style="background:#e74c3c; color:white; border:none; padding:4px 8px; border-radius:4px; cursor:pointer;">クエスト拒否 (評判 -${rejectPenalty})</button></p>`;
        }
        if(q.inProgress){
            html += `<p class="in-progress">進行中 - 冒険者の割り当て解除不可</p>`;
        }
        html += `</div>`;
    });
    return html;
}

function calcTradeRequiredDays(avgDex, avgLuc) {
    const avgStat = (avgDex + avgLuc) / 2;
    return Math.max(1, Math.ceil(80 / avgStat));
}

function updateDay(){
    const current_week = Math.floor((gameState.day - 1) / 7);
    const next_tax_day = (current_week + 1) * 7;
    const daysUntilTax = next_tax_day - gameState.day;
    const estimatedTax = Math.floor(gameState.gold * 0.2);
    let taxDisplay;
    if (daysUntilTax === 0) {
        taxDisplay = `今日の税金: ${estimatedTax}g (20%)`;
    } else {
        taxDisplay = `${daysUntilTax}日後の税金: 約${estimatedTax}g (20%)`;
    }
    let status = '';
    if (gameState.gameOver) {
        status = ' | <span style="color:red; font-weight:bold;">ゲームオーバー</span>';
    }
    document.getElementById('day').innerHTML=`<h2>日 ${gameState.day} | ゴールド: ${gameState.gold} | 評判: ${Math.max(0, gameState.reputation.toFixed(0))} | ${taxDisplay}${status}</h2>`;
}

function updateDisplays(){
    updateDay();
    document.getElementById('recruits').innerHTML=getRecruitsHtml();
    document.getElementById('availableAdvs').innerHTML=getAvailableHtml();
    renderQuests();
    const shopModal = document.getElementById('shopModal');
    if(shopModal && shopModal.style.display === 'flex'){
        document.getElementById('shopContent').innerHTML = renderCurrentShopPage();
    }
    const npcsModal = document.getElementById('npcsModal');
    if (npcsModal && npcsModal.style.display === 'flex') {
        document.getElementById('npcsContent').innerHTML = getNPCsContent();
    }

    const guildQuestsModal = document.getElementById('guildQuestsModal');
    if (guildQuestsModal && guildQuestsModal.style.display === 'flex') {
        getGuildQuestsContent();
    }
}

function startDay(){
    if (gameState.gameOver) {
        updateDisplays();
        return;
    }
    cleanupAdventurers();
    gameState.adventurers.forEach(a=>{
        if(!a.temp && !a.busy){
            a.hp=Math.min(a.maxHp, (a.hp || 0) + Math.floor(a.maxHp*0.1));
            a.mp=Math.min(a.maxMp, (a.mp || 0) + Math.floor(a.maxMp*0.1));
        }
        if (a.buffs) {
            a.buffs = a.buffs.filter(b => b.daysLeft > 1);
            a.buffs.forEach(b => b.daysLeft--);
        }
    });
    gameState.dailyMaterials = [];
    const numMaterialsToday = Math.floor(Math.random() * 3);
    const shuffled = [...materialShop].sort(() => 0.5 - Math.random());
    for (let i = 0; i < numMaterialsToday; i++) {
        const mat = shuffled[i];
        const price = Math.floor(mat.basePrice * (2 + Math.random() * mat.variance));
        gameState.dailyMaterials.push({name: mat.name, price: price});
    }
    cities.forEach(c => {
        if (c.guild) return;
        gameState.dailyPrices[c.name] = gameState.dailyPrices[c.name] || {};
        c.items.forEach(it => {
            gameState.dailyPrices[c.name][it.name] = Math.floor(it.minPrice + Math.random() * (it.maxPrice - it.minPrice + 1));
        });
    });

    // Quest limit: max 4 non-training quests
    let nonTrainingCount = gameState.quests.filter(q => !q.training).length;
    let availableSlots = 4 - nonTrainingCount;
    if (availableSlots > 0) {
        let nq = Math.min(Math.floor(Math.random() * 3) + 1, availableSlots);
        for(let i=0; i<nq; i++){
            let q=generateQuest(); 
            gameState.quests.push(q);
        }
    }

    if (gameState.day > 30 && Math.random() < 0.1 && !gameState.quests.some(q => q.defense)) {
        const dq = generateDefenseQuest();
        gameState.quests.push(dq);
    }

    let nt;
    if (gameState.reputation < 0) {
        nt = 0;
    } else {
        const repFactor = Math.max(0, gameState.reputation / 50);
        const maxNt = Math.min(5, 2 + Math.floor(repFactor));
        nt = Math.floor(Math.random() * maxNt) + 1;
    }
    for(let i=0;i<nt;i++){
        let a=generateTempAdventurer(); a.generatedDay=gameState.day; gameState.adventurers.push(a);
    }
    updateDisplays();
    ensureTrainingQuest();
}

function isPartyWiped(q) {
    if (!q || !q.assigned || q.assigned.length === 0) return false;
    return q.assigned.every(id => {
        const adv = findAdv(id);
        return !adv || adv.hp <= 0;
    });
}

function processQuestOutcome(q, eventDay, success, lowStatusFail, goldOverride = null) {

    if (q.training) {
        if (q.assigned.length === 0) return;
        let assignedAdvs = q.assigned.map(id => findAdv(id)).filter(a => a);
        if (assignedAdvs.length === 0) { q.assigned = []; return; }
        let levels = assignedAdvs.map(a => a.level || 1);
        let maxLv = Math.max(...levels);
        let names = assignedAdvs.map(a => a.name);
        let expDetails = [];
        assignedAdvs.forEach(adv => {
            let expGain = q.difficulty * 20;
            if (assignedAdvs.length > 1 && adv.level < maxLv) {
                expGain = maxLv * 20;
            }
            adv.exp += expGain;
            levelUp(adv);
            expDetails.push(`${adv.name} が ${expGain} EXP を獲得！`);
            adv.busy = false;
        });
        q.assigned = [];
        let msg = `トレーニングクエスト完了！<br>参加: ${names.join(' と ')}<br>${expDetails.join('<br>')}`;
        if (expDetails.some(line => line.includes((maxLv * 20).toString()))) {
            msg += `<br>低いレベルの冒険者が高いレベルの指導で大きく成長した！`;
        }
        gameState.eventHistory.unshift({day: eventDay, message: msg});
        return;
    }
    let teamRolled = {strength: 0, wisdom: 0, dexterity: 0, luck: 0};
    let adventurerRolls = {};
    q.assigned.forEach(id => {
        const adv = findAdv(id);
        if (!adv) return;
        const rolls = {
            strength: rollStat(adv, 'strength'),
            wisdom: rollStat(adv, 'wisdom'),
            dexterity: rollStat(adv, 'dexterity'),
            luck: rollStat(adv, 'luck')
        };
        adventurerRolls[id] = rolls;
        teamRolled.strength += rolls.strength;
        teamRolled.wisdom += rolls.wisdom;
        teamRolled.dexterity += rolls.dexterity;
        teamRolled.luck += rolls.luck;
    });
    const statDetails = `筋: ${teamRolled.strength} (min ${q.minStrength}), 知: ${teamRolled.wisdom} (min ${q.minWisdom}), 敏: ${teamRolled.dexterity} (min ${q.minDexterity}), 運: ${teamRolled.luck} (min ${q.minLuck})`;
    const adventurerNames = [];
    const permanentNames = [];
    let permanentCount = 0;
    const difficulty = q.difficulty;
    const damageMultiplier = success ? 1 : (lowStatusFail ? 1.5 : 2);
    for (let i = 0; i < q.assigned.length; i++) {
        const adventurerId = q.assigned[i];
        const adventurer = findAdv(adventurerId);
        if (!adventurer) {
            q.assigned.splice(i, 1);
            i--;
            continue;
        }
        if (success) {
            
            adventurer.exp += difficulty * 20;
            levelUp(adventurer);
        }
        const levelDiff = Math.max(0, q.difficulty - adventurer.level);
        const extraDamageFactor = 1 + levelDiff * 0.1;
        const hpDamage = difficulty * 5 * damageMultiplier * extraDamageFactor;
        const mpDamage = difficulty * 3 * damageMultiplier * extraDamageFactor;
        const effectiveHpDamage = Math.floor(hpDamage);
        const effectiveMpDamage = Math.floor(mpDamage);

        adventurer.hp = Math.max(0, (adventurer.hp || 0) - effectiveHpDamage);
        adventurer.mp = Math.max(0, (adventurer.mp || 0) - effectiveMpDamage);
        adventurer.busy = false;
        if (adventurer.hp <= 0) {
            const isPerm = !adventurer.temp;
            if (isPerm) {
                gameState.reputation = Math.max(-100, gameState.reputation - 10);
            }
            let deathMsg = `${adventurer.name} が "${q.desc}" で${isPerm ? '死亡しました' : '失われました'}！${isPerm ? ' 評判 -10。' : ''}`;
            gameState.eventHistory.unshift({day: eventDay, message: deathMsg});
            const mainIdx = gameState.adventurers.findIndex(a => a.id === adventurerId);
            if (mainIdx > -1) gameState.adventurers.splice(mainIdx, 1);
            const pendingIdx = gameState.recruitPending.findIndex(a => a.id === adventurerId);
            if (pendingIdx > -1) gameState.recruitPending.splice(pendingIdx, 1);
            q.assigned.splice(i, 1);
            i--;
            continue;
        }
        adventurerNames.push(adventurer.name);
        if (!adventurer.temp) {
            permanentCount++;
            permanentNames.push(adventurer.name);
        }
        if (adventurer.temp && success) {
            const recruitCopy = JSON.parse(JSON.stringify(adventurer));
            recruitCopy.recruitingCost = adventurer.recruitingCost;
            recruitCopy.generatedDay = eventDay + 1;
            recruitCopy.buffs = [];
            gameState.recruitPending.push(recruitCopy);
            const mainIdx = gameState.adventurers.findIndex(a => a.id === adventurerId);
            if (mainIdx > -1) gameState.adventurers.splice(mainIdx, 1);
        }
    }
    let extraMsg = '';

    if (success) {


        let payout = permanentCount * 0.1 * q.reward;
        let rewardGold = q.reward;
        if (goldOverride !== null) {
            rewardGold = goldOverride;
            payout = permanentCount * 0.1 * goldOverride;
        }
        gameState.gold += rewardGold - payout;
        let repGain = q.difficulty * 0.5;
        gameState.reputation += repGain;
        if (q.type === 6) {
            gameState.mainProgress++;
            gameState.reputation += 30;
            extraMsg += `<br><strong>ストーリーが進行しました！</strong> 次のメインクエストがギルドクエストメニューで確認できるようになりました。`;
        } else if (q.type === 7) {
            let treasureGold = q.floor * 300;
            gameState.gold += treasureGold;
            extraMsg += `<br>ダンジョン${q.floor}階の宝: +${treasureGold}g`;
            let rareStat = ['strength','wisdom','dexterity','luck'][Math.floor(Math.random()*4)];
            let rareBonus = 10 + q.floor * 5;
            addToInventory({name: `ダンジョン${q.floor}階の${statFull[rareStat]}リング`, stat: rareStat, bonus: rareBonus, id: gameState.nextId++},1);
            extraMsg += `<br>稀少装備発見！`;
        } else if (q.type === 8) {
            let td = q.tradeData;
            let cityItem = cities.find(c => c.name === td.city)?.items[0];
            if (!cityItem) {
                extraMsg += `<br>都市データエラー。`;
                return;
            }
            const currentPrice = gameState.dailyPrices[td.city][cityItem.name];
            const success = currentPrice <= td.maxPrice;
            const qty = td.qty;
            const actualCost = success ? currentPrice * qty : 0;
            const refund = td.deductedGold - actualCost;
            gameState.gold += refund;
            if (success) {
                for (let k = 0; k < qty; k++) {
                    addToInventory({
                        name: td.item,
                        minPrice: Math.floor(currentPrice * 1.2),
                        maxPrice: Math.floor(currentPrice * 1.5),
                        id: gameState.nextId++
                    },1);
                }
                extraMsg += `<br>${td.item} x${qty}個を${currentPrice}g/個で購入成功！返金${refund}g。`;
            } else {
                extraMsg += `<br>価格${currentPrice}g > 最大${td.maxPrice}gで失敗。全額${td.deductedGold}g返金。`;
            }
        } else if (q.type === 2) {
            const repChance = Math.min(0.8, 0.15 + q.difficulty * 0.0065);
            if (Math.random() < repChance) {
                const extraRep = q.difficulty * 0.6;
                gameState.reputation += extraRep;
                extraMsg += ` 感謝のクライアントが言葉を広め、+${extraRep.toFixed(1)} 評判！`;
            }
        }
        if (q.type === 1) {
            const discChance = 1;
            console.log("This is type 1 quest")
            console.log(q.npcIdx)
            if (Math.random() < discChance && q.npcIdx !== null && !gameState.discoveredNPCs.includes(q.npcIdx)) {
                gameState.discoveredNPCs.push(q.npcIdx);
                const npcName = discoveryNPCs[q.npcIdx];
                extraMsg += ` ${npcName}を発見！ NPCでサイドクエストを確認。`;
            }
        }
        if (q.side) {
            const expOrb = {
                name: 'EXPオーブ',
                type: 'consumable',
                effect: 'level_up',  // 使用時にレベル+10
                amount: 10,
                id: gameState.nextId++
            };
            addToInventory(expOrb, 1);
            extraMsg += ` EXPオーブを受け取りました！（使用で冒険者のレベル+10）`;
        }
        if (q.type === 3 && q.item) {
            // 100% chance (condition always true)
            const quantity = Math.floor(Math.random() * 5) + 1; // 1〜5個（difficultyに関係なくランダム）
            for (let k = 0; k < quantity; k++) {
                addToInventory({...q.item, id: gameState.nextId++}, 1);
            }
            extraMsg = ` 冒険者がギルドのために追加の${quantity}個の${q.item.name}を持って帰りました！${extraMsg}`;
        }
        if (q.type === 0 && Math.random() < 0.2) {
            const numPerms = gameState.adventurers.filter(a => !a.temp).length;
            if (numPerms >= gameState.maxPermanentSlots) {
                extraMsg += `${extraMsg ? ' ' : ''}感銘を受けた冒険者が加わりたがったが、ギルドは満杯です。`;
            } else {
                const newAdv = generateKillRecruit(q.difficulty);
                gameState.adventurers.push(newAdv);
                extraMsg += `${extraMsg ? ' ' : ''}感銘を受けた冒険者${newAdv.name}があなたのギルドに加わることを決めました！`;
            }
        }

        // 完了ダイアログ処理（サイドクエストは専用ダイアログ、初回のみ再生）
        if (q.side) {
            // サイドクエスト専用ダイアログ（npcIdxでインデックス）
            if (sideQuestCompletionDialogue[q.npcIdx]) {
                const key = `side-${q.npcIdx}`;
                
                if (gameState.seenCompletionDialogues.has(key)) {
                    console.log("(サイドクエストダイアログスキップ: 既に再生済み)");
                } else {
                    const dialogue = sideQuestCompletionDialogue[q.npcIdx];
                    queueQuestCompletionDialogue(dialogue);
                    gameState.seenCompletionDialogues.add(key);
                }
            }
        } else if (QuestCompletionDialogue[q.questType]?.[q.rank]?.[q.questStoryindex]) {
            // 通常クエストのダイアログ（初回のみ）
            const key = `${q.questType}-${q.rank}-${q.questStoryindex}`;
            
            if (gameState.seenCompletionDialogues.has(key)) {
                console.log("(通常クエストダイアログスキップ: 既に聞いた内容)");
            } else {
                const dialogue = QuestCompletionDialogue[q.questType][q.rank][q.questStoryindex];
                queueQuestCompletionDialogue(dialogue);
                gameState.seenCompletionDialogues.add(key);
            }
        }
        let successMsg = `
        クエスト: ${q.desc}<br>
        チーム: ${adventurerNames.join('、')}<br>
        ステータス: ${statDetails}<br>
        ギルド報酬: +${rewardGold - payout}g (恒久者支払い: ${payout}g)<br>
        評判: +${repGain.toFixed(1)}`;
        if (extraMsg) {
            successMsg += `<br>追加: ${extraMsg}`;
        }
        gameState.eventHistory.unshift({day: eventDay, message: successMsg});
    } else {
        const repLoss = q.difficulty * 2;
        gameState.reputation -= repLoss;
        let failMsg = `
        クエスト: ${q.desc}<br>
        失敗！<br>
        ステータス: ${statDetails}<br>
        評判: -${repLoss}`;
        gameState.eventHistory.unshift({day: eventDay, message: failMsg});
    }
}

function playDay(){
    if (gameState.gameOver) return;
// ===== 新規追加: 防衛クエスト未割り当て警告 =====
    const defenseQuest = gameState.quests.find(q => q.defense);
    if (defenseQuest && defenseQuest.assigned.length === 0) {
        const confirmMessage = 
`${defenseQuest.desc}

警告：防衛クエストに誰も割り当てられていません！

このまま日を進めるとギルドが襲撃され、誰も防衛しないため即座にゲームオーバーになります。

本当に日を進めますか？（キャンセルで日進めを中止できます）`;

        if (!confirm(confirmMessage)) {
            return; // プレイヤーがキャンセル → 日を進めず関数終了
        }
        // OKされた場合は強行的に進めてゲームオーバーへ
    }
    // ===== 追加終わり =====
    const evDay=gameState.day; gameState.day++;
    if (evDay % 7 === 0) {
        const tax = Math.floor(gameState.gold * 0.2);
        gameState.gold -= tax;
        gameState.eventHistory.unshift({day: evDay, message: `税金の日！${tax}g (保有の20%) を徴収。`});
        checkGameOver();
    }
    for (let i = gameState.quests.length - 1; i >= 0; i--) {
        const q = gameState.quests[i];
        if (q.defense) continue;
        if (q.type === 8) {
            if (q.assigned.length === 0) continue;
            if (!q.inProgress) {
                const teamDex = q.assigned.reduce((sum, id) => sum + getEffectiveStat(findAdv(id), 'dexterity'), 0);
                const teamLuk = q.assigned.reduce((sum, id) => sum + getEffectiveStat(findAdv(id), 'luck'), 0);
                if (teamDex < q.minDexterity || teamLuk < q.minLuck) {
                    q.assigned.forEach(id => {
                        const adv = findAdv(id);
                        if (adv) adv.busy = false;
                    });
                    q.assigned = [];
                    gameState.eventHistory.unshift({day: evDay, message: `貿易クエスト "${q.desc}" 開始失敗: DEXまたはLUC不足。`});
                    continue;
                }
                const qty = q.tradeData.qty;
                const maxPrice = q.tradeData.maxPrice;
                const neededGold = qty * maxPrice;
                if (gameState.gold < neededGold) {
                    q.assigned.forEach(id => {
                        const adv = findAdv(id);
                        if (adv) adv.busy = false;
                    });
                    q.assigned = [];
                    gameState.eventHistory.unshift({day: evDay, message: `貿易クエスト "${q.desc}" 開始失敗: 予算不足 (必要${neededGold}g)。`});
                    continue;
                }
                gameState.gold -= neededGold;
                q.inProgress = true;
                const avgDex = teamDex / q.assigned.length;
                const avgLuc = teamLuk / q.assigned.length;
                q.tradeRemainingDays = calcTradeRequiredDays(avgDex, avgLuc);
                q.deductedGold = neededGold;
                q.originalRequiredDays = q.tradeRemainingDays;
                gameState.eventHistory.unshift({day: evDay, message: `貿易クエスト開始: ${q.desc} (${q.tradeRemainingDays}日予定、予算${neededGold}g扣除)`});
            } else {
                q.tradeRemainingDays--;
                if (q.tradeRemainingDays <= 0) {
                    const city = q.tradeData.city;
                    const itemName = q.tradeData.item;
                    const qty = q.tradeData.qty;
                    const maxPrice = q.tradeData.maxPrice;
                    const currentPrice = gameState.dailyPrices[city][itemName];
                    const success = currentPrice <= maxPrice;
                    const actualCost = success ? currentPrice * qty : 0;
                    const refund = q.deductedGold - actualCost;
                    gameState.gold += refund;
                    let msg = success 
                        ? `貿易成功！${itemName} x${qty}を${currentPrice}g/個で購入（総${actualCost}g）。返金${refund}g。`
                        : `貿易失敗：価格${currentPrice}g > 最大${maxPrice}g。全額${q.deductedGold}g返金。`;
                    if (success) {
                        for (let k = 0; k < qty; k++) {
                            addToInventory({
                                name: itemName,
                                minPrice: Math.floor(currentPrice * 1.2),
                                maxPrice: Math.floor(currentPrice * 1.5),
                                id: gameState.nextId++
                            },1);
                        }
                        const expGain = 20 * q.originalRequiredDays;
                        q.assigned.forEach(id => {
                            const adv = findAdv(id);
                            if (adv) {
                                adv.exp += expGain;
                                levelUp(adv);
                                adv.busy = false;
                            }
                        });
                        msg += `<br>全員EXP +${expGain}獲得！`;
                    } else {
                        q.assigned.forEach(id => {
                            const adv = findAdv(id);
                            if (adv) adv.busy = false;
                        });
                    }
                    gameState.eventHistory.unshift({day: evDay, message: `貿易クエスト完了: ${q.desc}<br>${msg}`});
                    q.assigned = [];
                    gameState.quests.splice(i, 1);
                }
            }
            continue;
        }
        if (q.assigned.length > 0) {
            const teamStr = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'strength'), 0);
            const teamWis = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'wisdom'), 0);
            const teamDex = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'dexterity'), 0);
            const teamLuk = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'luck'), 0);
            const meetsAll = teamStr >= q.minStrength && teamWis >= q.minWisdom && teamDex >= q.minDexterity && teamLuk >= q.minLuck;
            if (!meetsAll) {
                processQuestOutcome(q, evDay, false, true);
                if (!q.training && !q.playerPosted) gameState.quests.splice(i, 1);
                continue;
            }
            let teamFocus = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), q.focusStat), 0);
            const excess = (teamFocus / q.minFocus) - 1;
            const prob = Math.min(0.5, 0.1 + Math.max(0, excess) * 0.2);
            let successToday = Math.random() < prob;
            if (q.training && q.assigned.length > 0) {
                successToday = true;
            }
            if (successToday) {
                        processQuestOutcome(q, evDay, true, false);
                        if (!q.training) {  // ← !q.playerPosted を削除
                            gameState.quests.splice(i, 1);
                        }
                    } else {
                        if (!q.training) {  // ← !q.playerPosted を削除
                            q.inProgress = true;
                        }
                    }
        }
    }
    gameState.quests.forEach(q => {
        if (!q.training && !q.playerPosted && q.type !== 8) q.daysLeft--;
    });
    for (let i = gameState.quests.length - 1; i >= 0; i--) {
        const q = gameState.quests[i];
        if (q.defense || q.training || q.playerPosted || q.type === 8) continue;
        if (q.daysLeft <= 0) {
            if (q.assigned.length > 0) {
                processQuestOutcome(q, evDay, false, false);
            } else {
                const penalty = 0.5 * q.difficulty;
                gameState.reputation -= penalty;
                gameState.eventHistory.unshift({day: evDay, message: `無視されたクエスト "${q.desc}" が期限切れ。評判 -${penalty}。`});
            }
            gameState.quests.splice(i, 1);
        }
    }
    if (defenseQuest) {
        gameState.quests = gameState.quests.filter(q => !q.defense);
        if (defenseQuest.assigned.length === 0) {
            gameState.eventHistory.unshift({day: evDay, message: `防衛クエスト失敗！誰も割り当てられず、ギルドは崩壊。ゲームオーバー！`});
            gameState.gameOver = true;
            showModal(evDay);
            updateDisplays();
            return;
        } else {
            generateEnemies(defenseQuest);
            const team = defenseQuest.assigned.map(id => {
                const adv = findAdv(id);
                return adv ? {...adv, id: id} : null;
            }).filter(a => a);

            currentBattle = {
                quest: defenseQuest,
                day: evDay,
                team: team,
                enemies: defenseQuest.enemies.map(e => ({...e})),
                round: 0,
                actions: {},
                phase: 'setup',
                actionIndex: 0,
                combatants: []
            };

            document.getElementById('battleTitle').innerHTML = `防衛戦: ${defenseQuest.desc}`;
            document.getElementById('battleModal').style.display = 'flex';
            renderBattle();

            // ← 新規追加：戦闘BGMにクロスフェードで切り替え（約1.5秒で緊張感を演出）
            crossfadeTo('battleBgm', 1500);

            return;
        }
    }
    checkGameOver();
    showModal(evDay);
}

function renderBattle() {
    if (!currentBattle) return;
    let topHtml = '<div class="battle-top"><h3>防衛戦</h3><div id="battleLog"></div>';
    if (currentBattle.phase === 'setup') {
        topHtml += '<button onclick="startRound()">ラウンド開始</button>';
    } else {
        topHtml += '<button onclick="nextAction()">次の行動</button>';
    }
    topHtml += '</div>';
    let enemiesHtml = '<div class="battle-section"><h3>敵 (上)</h3><div class="battle-enemies">';
    currentBattle.enemies.filter(e => e.hp > 0).forEach(e => {
        const hpPct = (e.hp / e.maxHp) * 100;
        const selectableClass = currentSelectingAdvId ? 'selectable' : '';
        enemiesHtml += `
            <div class="battle-enemy ${selectableClass}" id="div_${e.id}" data-id="${e.id}" ${currentSelectingAdvId ? `onclick="selectEnemyForCurrentAdv('${e.id}')"` : ''}>
                <img src="${e.image}" class="enemy-img" alt="${e.name}">
                ${e.name}
                <div class="progress-bar"><div class="progress-fill hp-fill" style="width:${hpPct}%"></div></div>
                HP ${Math.floor(e.hp)}/${e.maxHp}
            </div>
        `;
    });
    enemiesHtml += '</div></div>';
    let teamHtml = '<div class="battle-section"><h3>チーム (下)</h3><div class="battle-team">';
    currentBattle.team.filter(adv => adv.hp > 0).forEach(adv => {
        const hpPct = (adv.hp / adv.maxHp) * 100;
        const mpPct = (adv.mp / adv.maxMp) * 100;
        let actionHtml = '';
        if (currentBattle.phase === 'setup') {
            const act = currentBattle.actions[adv.id] || {};
            const isAttack = ['physical', 'magic'].includes(act.type);
            const targetName = act.target ? currentBattle.enemies.find(e => e.id === act.target)?.name || '不明' : 'なし';
            const selectingNote = currentSelectingAdvId === adv.id ? '<br><em>(敵をクリックして対象を選択)</em>' : '';
            actionHtml = `
                <button onclick="setAction(${adv.id}, 'physical')">Physical (STR)</button>
                <button onclick="setAction(${adv.id}, 'magic')">Magic (WIS, -10 MP)</button>
                <button onclick="setAction(${adv.id}, 'defense')">Defense</button>
                <br>行動: ${act.type || '未選択'}
                ${isAttack ? `<br>対象: ${targetName}` : ''}
                ${selectingNote}
            `;
        }
        teamHtml += `
            <div class="team-member" id="div_${adv.id}">
                <div class="adventurer-card">
                    <img src="${adv.image}" class="adventurer-img" alt="${adv.name}">
                    ${getNameHtml(adv)}
                    <br>
                    <div id="hp_${adv.id}" style="background:transparent;">HP: 
                        <div class="progress-bar" style="background:transparent; border:1px solid rgba(255,255,255,0.3);">
                            <div class="progress-fill hp-fill" style="width:${hpPct}%"></div>
                        </div> 
                        ${Math.floor(adv.hp)}/${adv.maxHp}
                    </div>
                    <br>
                    <div id="mp_${adv.id}" style="background:transparent;">MP: 
                        <div class="progress-bar" style="background:transparent; border:1px solid rgba(255,255,255,0.3);">
                            <div class="progress-fill mp-fill" style="width:${mpPct}%"></div>
                        </div> 
                        ${Math.floor(adv.mp)}/${adv.maxMp}
                    </div>
                </div>
                <div class="actions">${actionHtml}</div>
            </div>
        `;
    });
    teamHtml += '</div></div>';
    document.getElementById('battleContent').innerHTML = topHtml + enemiesHtml + teamHtml;
}

function setAction(advId, type) {
    let act = currentBattle.actions[advId] || {};
    act.type = type;
    if (type === 'defense') act.target = null;
    currentBattle.actions[advId] = act;
    currentSelectingAdvId = (type === 'physical' || type === 'magic') ? advId : null;
    renderBattle();
}

function selectEnemyForCurrentAdv(targetId) {
    if (currentSelectingAdvId) {
        const act = currentBattle.actions[currentSelectingAdvId];
        if (act && (act.type === 'physical' || act.type === 'magic')) {
            act.target = targetId;
        }
        currentSelectingAdvId = null;
    }
    renderBattle();
}

function startRound() {
    currentBattle.enemies.filter(e => e.hp > 0).forEach(e => {
        const aliveAdv = currentBattle.team.filter(a => a.hp > 0);
        if (aliveAdv.length > 0) {
            const randTarget = aliveAdv[Math.floor(Math.random() * aliveAdv.length)];
            e.action = { type: 'physical', target: randTarget.id };
        }
    });
    currentBattle.combatants = [...currentBattle.team.filter(a => a.hp > 0), ...currentBattle.enemies.filter(e => e.hp > 0)];
    currentBattle.combatants.sort((a, b) => getEffectiveStat(b, 'dexterity') - getEffectiveStat(a, 'dexterity'));
    currentBattle.actionIndex = 0;
    currentBattle.phase = 'executing';
    renderBattle();
    addBattleLog(`Round ${currentBattle.round + 1} 開始...`);
}

function nextAction() {
    executeAction();
}

function executeAction() {
    while (currentBattle.actionIndex < currentBattle.combatants.length) {
        const c = currentBattle.combatants[currentBattle.actionIndex];
        if (c.hp <= 0) {
            currentBattle.actionIndex++;
            continue;
        }
        const isPlayer = !c.id.toString().startsWith('enemy_');
        const act = isPlayer ? currentBattle.actions[c.id] : c.action;
        if (!act) {
            currentBattle.actionIndex++;
            continue;
        }
        if (act.type === 'defense') {
            c.defending = true;
            addBattleLog(`${c.name} が防御の構えを取った！`);
        } else {
            let target = null;
            let dmg = 0;
            if (isPlayer) {
                target = currentBattle.enemies.find(e => e.id === act.target);
            } else {
                target = currentBattle.team.find(a => a.id === act.target) || currentBattle.team.filter(a => a.hp > 0)[0];
            }
            if (!target || target.hp <= 0) {
                currentBattle.actionIndex++;
                continue;
            }
            if (act.type === 'physical') {
                dmg = getEffectiveStat(c, 'strength') * (1 + Math.random() * 0.5);
            } else if (act.type === 'magic') {
                if (isPlayer) c.mp = Math.max(0, c.mp - 10);
                dmg = getEffectiveStat(c, 'wisdom') * (1.5 + Math.random() * 0.5);
            }
            let finalDmg = dmg;
            if (target.defending) {
                finalDmg *= 0.5;
                target.defending = false;
            }
            target.hp = Math.max(0, target.hp - finalDmg);
            if (finalDmg > 0) {
                if (act.type === 'physical') {
                    strSound.currentTime = 0;
                    strSound.play();
                } else if (act.type === 'magic') {
                    wisSound.currentTime = 0;
                    wisSound.play();
                }
            }
            const typeStr = act.type === 'physical' ? '物理攻撃' : '魔法攻撃';
            console.log(`${c.name} の ${typeStr}！ ${target.name} に ${Math.floor(finalDmg)} ダメージ！`);
            addBattleLog(`${c.name} の ${typeStr}！ ${target.name} に ${Math.floor(finalDmg)} ダメージ！`);
            const hpPct = (target.hp / target.maxHp) * 100;
            const hpEl = document.getElementById(`hp_${target.id}`);
            if (hpEl) hpEl.innerHTML = `HP: <div class="progress-bar"><div class="progress-fill hp-fill" style="width:${hpPct}%"></div></div> ${Math.floor(target.hp)}/${target.maxHp}`;
            const targetDiv = document.getElementById(`div_${target.id}`);
            if (targetDiv) {
                const isCritical = false; // ← クリティカル判定がなければ false のまま
                console.log(targetDiv)
                showDamagePopup(targetDiv, Math.floor(finalDmg), false, isCritical);
            }
            if (act.type === 'magic' && isPlayer) {
                const mpPct = (c.mp / c.maxMp) * 100;
                const mpEl = document.getElementById(`mp_${c.id}`);
                if (mpEl) mpEl.innerHTML = `MP: <div class="progress-bar"><div class="progress-fill mp-fill" style="width:${mpPct}%"></div></div> ${Math.floor(c.mp)}/${c.maxMp}`;
            }
        }
        currentBattle.actionIndex++;
        const aliveAdv = currentBattle.team.filter(a => a.hp > 0).length;
        const aliveEn = currentBattle.enemies.filter(e => e.hp > 0).length;
        if (aliveAdv === 0) {
            endBattle(false);
            return;
        }
        if (aliveEn === 0) {
            endBattle(true);
            return;
        }
        renderBattle();
        return;
    }
    endRound();
}

function endRound() {
    currentBattle.team.forEach(a => {
        a.defending = false;
        delete currentBattle.actions[a.id];
    });
    currentBattle.enemies.forEach(e => {
        e.defending = false;
        delete e.action;
    });
    currentBattle.round++;
    currentBattle.phase = 'setup';
    renderBattle();
}

function closeBattle() {
    endBattle(false);
}

function endBattle(win) {
    document.getElementById('battleModal').style.display = 'none';
    const q = currentBattle.quest;
    const day = currentBattle.day;
    currentBattle.team.forEach(battleAdv => {
        const origAdv = findAdv(battleAdv.id);
        if (origAdv) {
            origAdv.hp = battleAdv.hp;
            origAdv.mp = battleAdv.mp;
            if (battleAdv.hp <= 0) {
                gameState.reputation = Math.max(-100, gameState.reputation - 10);
                gameState.eventHistory.unshift({day: day, message: `${battleAdv.name} が防衛戦で死亡！ 評判 -10。`});
                const idx = gameState.adventurers.findIndex(a => a.id === battleAdv.id);
                if (idx > -1) gameState.adventurers.splice(idx, 1);
            }
        }
    });
    if (win) {
        let teamLUC = currentBattle.team.reduce((sum, a) => sum + getEffectiveStat(a, 'luck'), 0);
        q.reward = Math.floor(teamLUC * (Math.floor(gameState.reputation) + 1) * 0.5);
        processQuestOutcome(q, day, true, false, q.reward);
        crossfadeTo('bgm', 2000);
    } else {
        gameState.eventHistory.unshift({day: day, message: '防衛戦で全滅！ギルドは陥落しました。ゲームオーバー！'});
        gameState.gameOver = true;
    }
    currentBattle = null;
    showModal(day);
}




function getFacilitiesContent() {
    let html = '';
    const names = {blacksmith: '鍛冶屋', tavern: '酒場', alchemy: '錬金工房'};
    for (let f in gameState.facilities) {
        let level = gameState.facilities[f];
        html += `<h3>${names[f]} レベル ${level}</h3>`;
        if (level < 4) {
            const nextCost = {blacksmith: [1500,4000,8000,15000], tavern: [1200,3500,7000,13000], alchemy: [2000,5000,10000,18000]};
            const cost = nextCost[f][level];
            if (cost > 0) html += `<button onclick="upgradeFacility('${f}')">アップグレード (${cost}g)</button><br><br>`;
        }
        if (level > 0) {
            if (f === 'alchemy') {
                html += `
                        <div class="facility-section">
                            <h3>錬金術 Lv${gameState.facilities.alchemy}</h3>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <select id="alchemyIng1" onchange="updateAlchemyPreview()" style="flex: 1; min-width: 140px; padding: 5px;"></select>
                                <select id="alchemyIng2" onchange="updateAlchemyPreview()" style="flex: 1; min-width: 140px; padding: 5px;"></select>
                                <input type="number" id="alchemyQty" value="1" min="1" max="999" onchange="updateAlchemyPreview()" style="width: 80px; padding: 5px;">
                                <button onclick="performAlchemy()" style="padding: 8px 16px; background: #27ae60;">作成</button>
                            </div>
                            <div id="alchemyPreview" style="margin-top: 10px; padding: 12px; background: #e8f5e8; border-radius: 4px; border-left: 4px solid #27ae60; min-height: 60px;"></div>
                        </div>
                    `;
            } else {
                const recipes = f === 'blacksmith' ? blacksmithRecipes : tavernRecipes;
                html += `<h4>${names[f]} 生産</h4><ul>`;
                recipes.forEach((r, j) => {
                    if (r.level > level) return;
                    let canMake = gameState.gold >= r.cost;
                    let matStr = '';
                    if (r.materials && r.materials.length > 0) {
                        r.materials.forEach(m => {
                            let have = gameState.inventory.filter(it => it.name === m.name).length;
                            matStr += `${m.name} x${m.qty} (保有${have}) `;
                            if (have < m.qty) canMake = false;
                        });
                    }
                    html += `<li>${r.name} - ${r.cost}g ${matStr}
                             <button onclick="produce('${f}', ${j})" ${canMake ? '' : 'disabled'}>生産</button></li>`;
                });
                html += `</ul>`;
            }
        }
    }
    document.getElementById('facilitiesContent').innerHTML = html;
    // Add this block at the very end of toggleFacilities(), after the innerHTML is set
    if (document.getElementById('alchemyIng1')) {
        const optionsHtml = getAlchemyMaterialOptions();
        document.getElementById('alchemyIng1').innerHTML = optionsHtml;
        document.getElementById('alchemyIng2').innerHTML = optionsHtml;
        updateAlchemyPreview();  // Show preview immediately (will be empty until selections made)
}

}

function selectMix(slot, idx) {
    if (slot === 1) selectedMix1 = idx;
    else selectedMix2 = idx;
    document.getElementById('mix1').innerHTML = selectedMix1 !== null ? gameState.inventory[selectedMix1].name : 'なし';
    document.getElementById('mix2').innerHTML = selectedMix2 !== null ? gameState.inventory[selectedMix2].name : 'なし';
    document.getElementById('mixBtn').disabled = selectedMix1 === null || selectedMix2 === null || selectedMix1 === selectedMix2;
}



function produce(fac, rid) {
    const recipes = fac === 'blacksmith' ? blacksmithRecipes : tavernRecipes;
    const r = recipes[rid];
    if (!spendGold(r.cost)) return;
    if (r.materials) {
        r.materials.forEach(m => {
            for (let k = gameState.inventory.length - 1; k >= 0; k--) {
                if (gameState.inventory[k].name === m.name && m.qty > 0) {
                    gameState.inventory.splice(k, 1);
                    m.qty--;
                }
            }
        });
    }
    let item = {name: r.name, id: gameState.nextId++};
    if (r.stat) {
        item.stat = r.stat;
        item.bonus = r.bonus;
    } else {
        item.type = 'consumable';
        item.buff = r.buff;
    }
    addToInventory(item,1);
    getFacilitiesContent();
    updateDisplays();
}

function toggleGuildQuests() {
    document.getElementById('guildQuestsModal').style.display = 'flex';
    getGuildQuestsContent();
}

function closeGuildQuests() {
    document.getElementById('guildQuestsModal').style.display = 'none';
}

function getGuildQuestsContent() {
    let html = `<select id="gqType" onchange="updateGQFields()">
        <option value="main">メインクエスト</option>
        <option value="dungeon">ダンジョンクエスト</option>
        <option value="trade">トレードクエスト</option>
    </select><div id="gqFields"></div><button onclick="postGuildQuest()">投稿</button>`;
    document.getElementById('guildQuestsContent').innerHTML = html;
    updateGQFields();
}

function updateGQFields() {
    let type = document.getElementById('gqType').value;
    let html = '';
    if (type === 'main') {
        if (gameState.mainProgress >= mainQuests.length) {
            html = '<p><strong>すべてのメインクエストを完了しました！</strong><br>深淵の王ヴォルガスは倒され、世界に平和が戻った。おめでとう！</p>';
        } else {
            let mq = mainQuests[gameState.mainProgress];
            const requiredRep = mq.repRequired || 0;
            const hasActiveMain = gameState.quests.some(q => q.type === 6);
            const canPost = gameState.reputation >= requiredRep && !hasActiveMain;

            html = `<h4>現在のストーリークエスト</h4>
                    <p>${mq.desc}</p>
                    <p>難易度 ${mq.difficulty} | 報酬 ${mq.reward}g</p>
                    <p>必要評判: ${requiredRep} （現在 ${gameState.reputation}）</p>`;

            if (hasActiveMain) {
                html += '<p style="color:orange;">既にメインクエストが進行中です。完了するまで次の投稿はできません。</p>';
            } else if (gameState.reputation < requiredRep) {
                html += '<p style="color:red;">評判不足です。サイドクエストなどで評判を上げてください。</p>';
            }

            if (canPost) {
                html += '<button onclick="postGuildQuest()">このメインクエストを投稿する</button>';
            }
        }
    } else if (type === 'dungeon') {
        html = `階層: <input type="number" id="dungeonFloor" min="1" value="5">`;
    } else if (type === 'trade') {
        html = `都市: <select id="tradeCity" onchange="updateTradeInfo()">`;
        cities.filter(c => !c.guild).forEach(c => html += `<option value="${c.name}">${c.name}</option>`);
        html += `</select>`;
        html += `<div id="tradeInfo"></div>`;
        html += `数量: <input type="number" id="tradeQty" value="5" min="1">`;
        html += `最大単価: <input type="number" id="tradeMaxPrice" value="0">`;
    }
    document.getElementById('gqFields').innerHTML = html;
    if (type === 'trade') updateTradeInfo();
}

function updateTradeInfo() {
    let cityName = document.getElementById('tradeCity').value;
    let city = cities.find(c => c.name === cityName);
    let info = '';
    if (city && city.items[0]) {
        let it = city.items[0];
        info += `アイテム: ${it.name}<br>価格範囲: ${it.minPrice}~${it.maxPrice}g`;
        let curr = gameState.dailyPrices[cityName] ? gameState.dailyPrices[cityName][it.name] : 'N/A';
        info += `<br>今日の価格: ${curr}g`;
        document.getElementById('tradeMaxPrice').value = it.maxPrice;
    }
    document.getElementById('tradeInfo').innerHTML = info;
}

function toggleFacilities() {
    currentFacility = null;
    document.getElementById('facilitiesModal').style.display = 'flex';
    renderFacilities();
}

function closeFacilities() {
    document.getElementById('facilitiesModal').style.display = 'none';
}



function toggleFacilities() {
    currentFacility = null;
    document.getElementById('facilitiesModal').style.display = 'flex';
    renderFacilities();
}

function closeFacilities() {
    document.getElementById('facilitiesModal').style.display = 'none';
}

function selectFacility(fac) {
    currentFacility = fac;
    renderFacilities();
}

function getAlchemyMaterialOptions() {
    const materials = [
        // 元の基本素材
        '薬草', '鉄鉱石', 'スパイス', '宝石', '活力の粉', '鋼のインゴット', '炎の粉', '魔法の結晶',
        
        // fetchクエスト生素材（全ランク）
        'キノコ', '花', '普通の薬草', '川魚', '鉄の欠片',
        '狼の毛皮', '魔力の結晶（小）',
        'オークの牙', '古代の巻物断片', '希少スパイス',
        'グリフォンの羽', 'ヒドラの毒袋', '聖水',
        'ユニコーンの角', '禁断の魔導書頁', 'フェニックスの灰',
        '星の欠片', '天使の羽', 'デーモンの心臓',
        '古代ドラゴンの鱗', 'エーテルの結晶', '神の涙',
        'タイタンの骨', '永遠の炎', '神聖な遺物',
        'エルダードラゴンの心臓', '深淵の核', '光の神器の欠片',
        '世界の源石', '創世の欠片', '滅びの結晶',
        
        // 新規クラフト素材（チェイン用）
        '鉄草合金粉', '森のエキス',
        '精鉄インゴット', '獣皮エキス',
        '牙鋼インゴット', '古魔導粉', '希少活力粉',
        '風翼結晶', '聖魔導結晶',
        '禁断魔導晶', '不死鳥炎粉',
        '龍鋼装甲材', 'エーテル魔晶',
        '巨神骨鋼', '永劫炎粉', '神聖遺晶',
        '古龍心鋼', '深淵エーテル晶', '光神器晶', '終焉破壊粉',
        '滅び深淵晶'
    ].sort((a, b) => a.localeCompare(b, 'ja')); // 五十音順ソートでUIを整理
    
    let html = '<option value="">-- 選択 --</option>';
    materials.forEach(mat => {
        const qty = countItem(mat);
        if (qty > 0) {
            html += `<option value="${mat}">${mat} (${qty}個)</option>`;
        }
    });
    return html;
}

function updateAlchemyPreview() {
    const ing1 = document.getElementById('alchemyIng1')?.value;
    const ing2 = document.getElementById('alchemyIng2')?.value;
    const qty = parseInt(document.getElementById('alchemyQty')?.value) || 1;
    const preview = document.getElementById('alchemyPreview');
    if (!preview || !ing1 || !ing2 || ing1 === ing2) {
        preview.innerHTML = '<p style="color:#aaa;">異なる材料を2つ選択するとレシピが表示されます</p>';
        return;
    }

    const sorted = [ing1, ing2].sort();
    const recipe = alchemyRecipes.find(r => {
        const rSorted = [...r.inputs].sort();
        return rSorted[0] === sorted[0] && rSorted[1] === sorted[1];
    });

    if (!recipe) {
        preview.innerHTML = '<p style="color:#ff6b6b;">この組み合わせのレシピはありません</p>';
        return;
    }

    const have1 = countItem(ing1);
    const have2 = countItem(ing2);
    const canMake = have1 >= qty && have2 >= qty;

    preview.innerHTML = `
        <p><strong>出力:</strong> ${recipe.output.name} ×${qty}</p>
        <p><strong>必要材料:</strong></p>
        <p style="color:${have1 >= qty ? '#ffffff' : '#ff6b6b'};">・${ing1} ×${qty} (保有: ${have1}個)</p>
        <p style="color:${have2 >= qty ? '#ffffff' : '#ff6b6b'};">・${ing2} ×${qty} (保有: ${have2}個)</p>
        <p style="margin-top:15px; color:${canMake ? '#27ae60' : '#ff6b6b'};"><strong>${canMake ? '作成可能' : '材料不足'}</strong></p>
    `;
}

function performAlchemy() {
    const ing1 = document.getElementById('alchemyIng1').value;
    const ing2 = document.getElementById('alchemyIng2').value;
    const qty = parseInt(document.getElementById('alchemyQty').value) || 1;

    if (!ing1 || !ing2 || ing1 === ing2) {
        alert('異なる有効な材料を2つ選択してください。');
        return;
    }

    const sortedInputs = [ing1, ing2].sort();
    const recipe = alchemyRecipes.find(r => {
        const rInputs = [...r.inputs].sort();
        return rInputs[0] === sortedInputs[0] && rInputs[1] === sortedInputs[1];
    });

    if (!recipe) {
        alert('この組み合わせにはレシピがありません。');
        return;
    }

    if (countItem(ing1) < qty || countItem(ing2) < qty) {
        alert('材料が不足しています！');
        return;
    }

    removeItems(ing1, qty);
    removeItems(ing2, qty);
    addToInventory(recipe.output, qty);

    const optionsHtml = getAlchemyMaterialOptions();
    document.getElementById('alchemyIng1').innerHTML = optionsHtml;
    document.getElementById('alchemyIng2').innerHTML = optionsHtml;
    updateAlchemyPreview();

    alert(`${recipe.output.name} を ${qty}個 作成しました！`);
    renderFacilities(); // 在庫更新のため再描画
}

function orderTavernItem(recipeIdx) {
    const r = tavernRecipes[recipeIdx];
    if (gameState.gold < r.cost) {
        alert('ゴールドが不足しています');
        return;
    }

    // 素材チェック（あれば）
    if (r.materials) {
        for (let m of r.materials) {
            if (countItem(m.name) < (m.qty || 1)) {
                alert('素材が不足しています');
                return;
            }
        }
    }

    const perms = gameState.adventurers.filter(a => !a.temp);
    if (perms.length === 0) {
        alert('永久冒険者がいないため適用できません');
        return;
    }

    // 冒険者選択リスト（画像を小さめの円形で表示）
    let selectHtml = `<div style="margin:40px 0; padding:30px; background:rgba(255,255,255,0.15); border-radius:16px;">
        <p style="font-size:1.4em; margin-bottom:25px; text-align:center;"><strong>${r.name}</strong> を注文（${r.cost}g）<br>
        適用する冒険者を選択してください</p>
        <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(200px,1fr)); gap:20px;">`;

    perms.forEach(adv => {
        selectHtml += `<div style="text-align:center; padding:15px; background:rgba(255,255,255,0.1); border-radius:12px;">
            <!-- 小さめ（80px）の円形ポートレート（歪みなし、適切なクロップ） -->
            <div style="width:80px; height:80px; border-radius:50%; overflow:hidden; margin:0 auto 12px; box-shadow:0 4px 12px rgba(0,0,0,0.4); border:2px solid rgba(255,255,255,0.3);">
                <img src="${adv.image}" style="width:100%; height:100%; object-fit:cover; object-position:center top;">
            </div>
            <strong style="font-size:1.2em; display:block; margin-bottom:8px;">${adv.name}</strong>
            <button onclick="applyTavernBuff(${recipeIdx}, ${adv.id})" style="padding:10px 24px; background:#27ae60; font-size:1.1em; border:none; border-radius:8px;">適用</button>
        </div>`;
    });

    selectHtml += `</div>
        <div style="text-align:center; margin-top:30px;">
            <button onclick="renderFacilities()" style="padding:10px 24px; background:#e74c3c; font-size:1.1em; border:none; border-radius:8px;">キャンセル</button>
        </div>
    </div>`;

    document.querySelector('.facility-panel').insertAdjacentHTML('beforeend', selectHtml);
}
function applyTavernBuff(recipeIdx, advId) {
    const r = tavernRecipes[recipeIdx];
    const adv = findAdv(advId);
    if (!adv || adv.temp) return;

    // 消費
    gameState.gold -= r.cost;
    if (r.materials) {
        for (let m of r.materials) {
            removeItems(m.name, m.qty || 1);
        }
    }

    // バフ適用
    const buffCopy = JSON.parse(JSON.stringify(r.buff));
    buffCopy.daysLeft = buffCopy.days;
    adv.buffs.push(buffCopy);

    alert(`${adv.name} に ${r.name} を適用しました！（${buffCopy.days}日間有効）`);
    renderFacilities();
    if (typeof updateGold === 'function') updateGold();
}

function produceBlacksmith(recipeIdx) {
    const r = blacksmithRecipes[recipeIdx];
    if (gameState.gold < r.cost) {
        alert('ゴールドが不足しています');
        return;
    }
    if (r.materials) {
        for (let m of r.materials) {
            if (countItem(m.name) < (m.qty || 1)) {
                alert('素材が不足しています');
                return;
            }
        }
    }

    gameState.gold -= r.cost;
    if (r.materials) {
        for (let m of r.materials) {
            removeItems(m.name, m.qty || 1);
        }
    }

    addToInventory({name: r.name, stat: r.stat, bonus: r.bonus});
    alert(`${r.name} を製作しました！`);
    renderFacilities();
    if (typeof updateGold === 'function') updateGold();
}

function renderFacilities() {
    const content = document.getElementById('facilitiesContent');
    const modalContent = document.querySelector('#facilitiesModal .modal-content');

    if (currentFacility === null) {
        modalContent.style.backgroundImage = "url('Images/Street.jpg')";
        content.innerHTML = `
            <div id = "renderedfacilitiesContent" style="text-align:center; padding:60px;">
                <h2>街</h2>
                <h2 style="font-size:1.6em; margin:40px 0;">施設を選択してください</h2>
                <div class="buttons" style="gap:30px; flex-wrap:wrap;">
                    <button onclick="selectFacility('blacksmith')" style="padding:40px 40px; font-size:1.4em; background:rgba(231,76,60,0.9);">鍛冶屋</button>
                    <button onclick="selectFacility('tavern')" style="padding:40px 40px; font-size:1.4em; background:rgba(52,152,219,0.9);">酒場</button>
                    <button onclick="selectFacility('alchemy')" style="padding:40px 40px; font-size:1.4em; background:rgba(46,204,113,0.9);">錬金工房</button>
                </div>
            </div>
        `;
    } else {
        let bgFile = '';
        let title = '';
        let recipes = [];

        if (currentFacility === 'blacksmith') {
            bgFile = '鍛冶屋.jpg';
            title = '鍛冶屋';
            recipes = blacksmithRecipes;
        } else if (currentFacility === 'tavern') {
            bgFile = '酒場.jpg';
            title = '酒場';
            recipes = tavernRecipes;
        } else if (currentFacility === 'alchemy') {
            bgFile = '錬金工房.jpg';
            title = '錬金工房';
            recipes = alchemyRecipes;
        }

        modalContent.style.backgroundImage = `url('Images/${bgFile}')`;

        const level = gameState.facilities[currentFacility];
        let html = `<div class="facility-panel">
            <h2>${title}　レベル ${level}</h2>
            <div style="text-align:center; margin:30px 0;">
                <button onclick="currentFacility=null; renderFacilities()" style="padding:14px 36px; background:#87878777; font-size:1em;">街に戻る</button>
            </div>`;

        // アップグレード（施設ごとに最大レベル対応）
        const maxLevel = facilityMaxLevels[currentFacility] || 4;  // 安全策（未定義時は4）
        if (level < maxLevel) {
            const nextCost = facilityUpgradeCosts[currentFacility][level];
            html += `
                <div style="text-align:center; margin:30px 0;">
                    <p style="font-size:1.4em;">
                        レベル ${level} → ${level + 1} アップグレード費用：${nextCost} gold
                    </p>
                    <button onclick="upgradeFacility('${currentFacility}')" 
                            ${gameState.gold < nextCost ? 'disabled style="background:#777;"' : ''} 
                            style="padding:14px 40px; font-size:1.4em;">
                        アップグレード
                    </button>
                </div>`;
        } else {
            html += `
                <div style="text-align:center; margin:30px 0;">
                    <p style="font-size:1.6em; color:#ffd700;">
                        最大レベル ${maxLevel} に到達しました！
                    </p>
                </div>`;
        }

        if (level > 0 && recipes.length > 0) {
            html += `<h3 style="text-align:center; margin-top:40px;">製作可能アイテム</h3>
                     <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(320px, 1fr)); gap:30px; margin-top:30px;">`;

            let hasItems = false;

            recipes.forEach((r, originalIndex) => {
                if (r.level > level) return;  // レベル不足は非表示

                hasItems = true;

                const cost = r.cost || 0;
                let canMake = gameState.gold >= cost;

                // 必要素材取得（錬金はinputs、それ以外はmaterials）
                const materials = currentFacility === 'alchemy' 
                    ? r.inputs.map(name => ({name, qty: 1}))
                    : (r.materials || []);

                let matHtml = '<p style="margin:15px 0;"><strong>必要素材:</strong></p>';
                if (materials.length > 0) {
                    materials.forEach(m => {
                        const have = countItem(m.name);
                        canMake = canMake && have >= m.qty;
                        const color = have >= m.qty ? '#ffffff' : '#ff6b6b';
                        matHtml += `<p style="color:${color}; margin:5px 0;">・${m.name} ×${m.qty} (保有: ${have}個)</p>`;
                    });
                } else {
                    matHtml += '<p style="color:#aaaaaa; margin:5px 0;">・なし</p>';
                }

                // アイテム名表示（錬金は「A + B → 出力」形式）
                const itemName = currentFacility === 'alchemy' 
                    ? `${r.inputs.join(' + ')} → ${r.output.name}`
                    : r.name;

                // 効果表示
                let effectHtml = '';
                if (currentFacility === 'blacksmith') {
                    const statText = {
                        strength: 'STR',
                        wisdom: 'WIS',
                        dexterity: 'DEX',
                        luck: 'LUC'
                    }[r.stat] || r.stat.toUpperCase();
                    effectHtml = `<p style="margin:12px 0; color:#ffeb3b; font-weight:bold; font-size:1.1em;">
                                    装備効果: ${statText} +${r.bonus}
                                  </p>`;
                } else if (currentFacility === 'tavern') {
                    if (r.buff.stat) {
                        const statText = {
                            strength: 'STR',
                            wisdom: 'WIS',
                            dexterity: 'DEX',
                            luck: 'LUC'
                        }[r.buff.stat] || r.buff.stat.toUpperCase();
                        const percent = r.buff.percent ? '%' : '';
                        effectHtml = `<p style="margin:12px 0; color:#81ff81; font-weight:bold; font-size:1.1em;">
                                        バフ効果: ${statText} +${r.buff.bonus}${percent}<br>
                                        持続: ${r.buff.days}日間
                                      </p>`;
                    } else if (r.buff.type) {
                        const typeText = r.buff.type === 'hpRegen' ? 'HP再生' : 'MP再生';
                        effectHtml = `<p style="margin:12px 0; color:#81ff81; font-weight:bold; font-size:1.1em;">
                                        バフ効果: ${typeText} +${r.buff.bonus}<br>
                                        持続: ${r.buff.days}日間
                                      </p>`;
                    }
                } else if (currentFacility === 'alchemy' && r.output.type === 'potion') {
                    const restoreText = r.output.restore === 'hp' ? 'HP回復' : 'MP回復';
                    effectHtml = `<p style="margin:12px 0; color:#a0f7a0; font-weight:bold; font-size:1.1em;">
                                    効果: ${restoreText} +${r.output.amount}
                                  </p>`;
                }

                // ボタン設定
                let buttonText, onclick;
                if (currentFacility === 'alchemy') {
                    buttonText = '合成';
                    onclick = `craftAlchemyRecipe(${originalIndex})`;
                } else if (currentFacility === 'tavern') {
                    buttonText = '注文（冒険者選択）';
                    onclick = `orderTavernItem(${originalIndex})`;
                } else {
                    buttonText = '製作';
                    onclick = `produceBlacksmith(${originalIndex})`;
                }

                html += `
                    <div class="facility-item">
                        <h3>${itemName}</h3>
                        ${effectHtml}
                        <p>コスト：${cost} gold</p>
                        ${matHtml}
                        <button onclick="${onclick}" 
                                ${!canMake ? 'disabled style="background:#777;"' : ''}
                                style="margin-top:15px; padding:12px 30px; font-size:1.2em;">
                            ${buttonText}
                        </button>
                    </div>`;
            });

            if (!hasItems) {
                html += `<p style="grid-column:1/-1; text-align:center; font-size:1.4em;">レベルを上げると新しいレシピが解放されます</p>`;
            }

            html += `</div>`;
        } else {
            html += `<p style="text-align:center; font-size:1.4em; margin-top:40px;">施設をアップグレードすると利用可能になります</p>`;
        }

        html += `</div>`;
        content.innerHTML = html;
    }
}


// 在庫から指定数量を消費する関数（removeFromInventory）
// inventory → gameState.inventory に修正（ゲームの構造に合わせ）
function removeFromInventory(itemName, qtyToRemove) {
    if (qtyToRemove <= 0) return true;

    // gameState.inventory を使用（標準的なゲーム構造）
    if (!gameState.inventory || !Array.isArray(gameState.inventory)) {
        console.error('gameState.inventory が未定義または配列ではありません');
        return false;
    }

    let removed = 0;
    for (let i = gameState.inventory.length - 1; i >= 0; i--) {  // 逆順ループでsplice安全
        const item = gameState.inventory[i];
        if (item.name === itemName) {
            const canRemove = Math.min(qtyToRemove - removed, item.qty || 1);
            item.qty = (item.qty || 1) - canRemove;
            removed += canRemove;

            if (item.qty <= 0) {
                gameState.inventory.splice(i, 1);  // 0個になったら削除
            }

            if (removed >= qtyToRemove) {
                return true;  // 要求数量すべて消費
            }
        }
    }

    // 不足した場合
    console.warn(`在庫不足: ${itemName} (要求: ${qtyToRemove}, 消費できた: ${removed})`);
    return false;
}

function craftAlchemyRecipe(index) {
    const recipe = alchemyRecipes[index];
    if (!recipe) {
        alert("無効なレシピです。");
        return;
    }

    // コストチェック（alchemyRecipesにcostがなければ0）
    const cost = recipe.cost || 0;
    if (gameState.gold < cost) {
        alert("ゴールドが不足しています！");
        return;
    }

    // 入力素材チェック（inputsは配列、qtyは常に1）
    for (const inputName of recipe.inputs) {
        const have = countItem(inputName);
        if (have < 1) {
            alert(`素材不足: ${inputName} が足りません！`);
            return;
        }
    }

    // 消費処理
    if (cost > 0) {
        gameState.gold -= cost;
    }
    for (const inputName of recipe.inputs) {
        removeFromInventory(inputName, 1);  // 1個消費（スタック対応関数を想定）
    }

    // 出力追加
    const output = recipe.output;
    let itemToAdd = {
        name: output.name,
        type: output.type  // 'material' or 'potion'
    };

    // ポーションの場合、restore/amount/minPrice/maxPriceを付与
    if (output.type === 'potion') {
        itemToAdd.restore = output.restore;
        itemToAdd.amount = output.amount;
    }

    // 売却価格（min/max）
    if (output.minPrice !== undefined && output.maxPrice !== undefined) {
        itemToAdd.minPrice = output.minPrice;
        itemToAdd.maxPrice = output.maxPrice;
    }

    addToInventory(itemToAdd, 1);

    // 成功メッセージ
    let msg = `${output.name} を合成しました！`;
    if (output.type === 'potion') {
        const restoreText = output.restore === 'hp' ? 'HP' : 'MP';
        msg += ` (${restoreText} +${output.amount})`;
    }
    alert(msg);

    // UI更新
    updateDisplays();
    renderFacilities();  // レシピリスト再描画（在庫変化反映）
}


const facilityMaxLevels = {
    alchemy: 4,
    blacksmith: 12,
    tavern: 12
};

const facilityUpgradeCosts = {
    alchemy: [
        1000,    // Lv0 → Lv1 (序盤容易)
        2500,    // Lv1 → Lv2
        6000,
        10000     // Lv2 → Lv3 (Lv4はmax)
    ],
    blacksmith: [
        1500,    // Lv0 → Lv1
        2700,    // Lv1 → Lv2
        4900,    // Lv2 → Lv3
        8800,    // Lv3 → Lv4
        15800,   // Lv4 → Lv5
        28400,   // Lv5 → Lv6
        51000,   // Lv6 → Lv7
        92000,   // Lv7 → Lv8
        165000,  // Lv8 → Lv9
        300000,  // Lv9 → Lv10
        540000,  // Lv10 → Lv11
        970000   // Lv11 → Lv12
    ],
    tavern: [
        1200,    // Lv0 → Lv1 (酒場少し安め)
        2200,    // Lv1 → Lv2
        4000,    // Lv2 → Lv3
        7200,    // Lv3 → Lv4
        13000,   // Lv4 → Lv5
        23000,   // Lv5 → Lv6
        41000,   // Lv6 → Lv7
        74000,   // Lv7 → Lv8
        133000,  // Lv8 → Lv9
        240000,  // Lv9 → Lv10
        430000,  // Lv10 → Lv11
        770000   // Lv11 → Lv12
    ]
};

function upgradeFacility(fac) {
    const currentLevel = gameState.facilities[fac];
    const maxLevel = facilityMaxLevels[fac];

    if (currentLevel >= maxLevel) {
        alert('この施設はすでに最大レベルです');
        return;
    }

    const cost = facilityUpgradeCosts[fac][currentLevel];

    if (gameState.gold >= cost) {
        gameState.gold -= cost;
        gameState.facilities[fac]++;
        renderFacilities();
        if (typeof updateGold === 'function') updateGold();
        alert(`${fac} がレベル ${gameState.facilities[fac]} にアップグレードされました！`);
    } else {
        alert('ゴールドが不足しています');
    }
    updateDisplays();
}




function craftFacilityItem(fac, recipeIdx) {
    const recipes = fac === 'blacksmith' ? blacksmithRecipes :
                    fac === 'tavern' ? tavernRecipes : alchemyRecipes;
    const r = recipes[recipeIdx];
    if (!r) return;

    const cost = r.cost || 0;
    if (gameState.gold < cost) { alert('ゴールド不足'); return; }

    // 素材チェック
    if (r.materials) {
        for (let m of r.materials) {
            if (countItem(m.name) < (m.qty || 1)) {
                alert('素材不足');
                return;
            }
        }
    }

    // 消費
    gameState.gold -= cost;
    if (r.materials) {
        for (let m of r.materials) {
            removeItems(m.name, m.qty || 1);
        }
    }

    // 生産
    if (fac === 'alchemy') {
        addToInventory(r.output);
        alert(`${r.output.name} を製作しました！`);
    } else if (fac === 'blacksmith') {
        addToInventory({name: r.name, stat: r.stat, bonus: r.bonus});
        alert(`${r.name} を製作しました！`);
    } else if (fac === 'tavern') {
        const perms = gameState.adventurers.filter(a => !a.temp);
        if (perms.length === 0) {
            alert('永久冒険者がいないため適用できません');
            gameState.gold += cost;  // 返金
            return;
        }
        const target = perms[Math.floor(Math.random() * perms.length)];
        const buffCopy = JSON.parse(JSON.stringify(r.buff));
        buffCopy.daysLeft = buffCopy.days;
        target.buffs.push(buffCopy);
        alert(`${target.name} に ${r.name} を適用しました！（${buffCopy.days}日間有効）`);
    }

    renderFacilities();
    if (typeof updateGold === 'function') updateGold();
}

function postGuildQuest() {
    let type = document.getElementById('gqType').value;
    let q = null;
    let alertMessage = 'ギルドクエストを投稿しました！';

    if (type === 'main') {
        if (gameState.mainProgress >= mainQuests.length) {
            alert('すべてのメインクエストを完了しました！');
            return;
        }

        if (gameState.quests.some(q => q.type === 6)) {
            alert('既にメインクエストが進行中です。現在のメインクエストを完了してください。');
            return;
        }

        let mq = mainQuests[gameState.mainProgress];
        if (gameState.reputation < (mq.repRequired || 0)) {
            alert(`評判が不足しています（必要: ${mq.repRequired || 0} / 現在: ${gameState.reputation}）。`);
            return;
        }

        q = {
            id: gameState.nextId++,
            desc: mq.desc,
            difficulty: mq.difficulty,
            minStrength: mq.minStrength,
            minWisdom: mq.minWisdom,
            minDexterity: mq.minDexterity,
            minLuck: mq.minLuck,
            focusStat: mq.focusStat,
            minFocus: mq.minFocus,
            type: 6,
            reward: mq.reward,
            playerPosted: true,
            daysLeft: 999,
            assigned: [],
            inProgress: false
        };

        alertMessage = 'メインクエストを投稿しました！クエストボードに表示されます。';
    } else if (type === 'dungeon') {
        let floor = parseInt(document.getElementById('dungeonFloor').value) || 1;
        let diff = floor * 12;
        q = {
            id: gameState.nextId++,
            desc: `ダンジョン ${floor}階探索`,
            difficulty: diff,
            minStrength: diff * 1.2,
            minWisdom: diff * 0.8,
            minDexterity: diff * 1.5,
            minLuck: diff * 0.5,
            focusStat: "dexterity",
            minFocus: diff * 2,
            type: 7,
            reward: floor * 300,
            playerPosted: true,
            floor: floor,
            daysLeft: 999,
            assigned: [],
            inProgress: false
        };
    } else if (type === 'trade') {
        let cityName = document.getElementById('tradeCity').value;
        let city = cities.find(c => c.name === cityName);
        let itemName = city.items[0].name;
        let qty = parseInt(document.getElementById('tradeQty').value) || 1;
        let maxPrice = parseInt(document.getElementById('tradeMaxPrice').value) || city.items[0].maxPrice;
        q = {
            id: gameState.nextId++,
            desc: `${cityName}で${itemName} ${qty}個購入 (最大${maxPrice}g/個)`,
            difficulty: 1,
            minDexterity: 5,
            minLuck: 5,
            focusStat: "trade",
            minFocus: 10,
            type: 8,
            reward: 0,
            playerPosted: true,
            tradeData: {city: cityName, item: itemName, qty: qty, maxPrice: maxPrice},
            daysLeft: 999,
            assigned: [],
            inProgress: false
        };
    }

    if (q) {
        gameState.quests.push(q);
        updateDisplays();
        alert(alertMessage);
        closeGuildQuests();  // オプション: 投稿後にモーダルを閉じる
    }
}

function toggleShop() {
    const modal = document.getElementById('shopModal');
    modal.style.display = 'flex';
    document.getElementById('shopContent').innerHTML =renderCurrentShopPage();
}

function closeShop() {
    document.getElementById('shopModal').style.display = 'none';
}

function toggleCharacters() {
    document.getElementById('charactersModal').style.display = 'flex';
    currentCharIndex = 0;
    renderCurrentCharacter();
}

function closeCharacters() {
    document.getElementById('charactersModal').style.display = 'none';
}
function toggleNPCs() {
    const modal = document.getElementById('npcsModal');
    if (modal.style.display === 'block') {
        modal.style.display = 'none';
    } else {
        currentNPCIndex = 0;
        renderCurrentNPC();
        modal.style.display = 'block';
    }
}

function closeNPCs() {
    document.getElementById('npcsModal').style.display = 'none';
}



function useSpecificPotion(charIndex, itemId) {
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[charIndex];
    if (!adv) return;

    const idx = gameState.inventory.findIndex(i => i.id === itemId);
    if (idx === -1) return;

    const potion = gameState.inventory[idx];
    if (potion.type !== 'potion') return;

    if (potion.restore === 'hp') {
        adv.hp = Math.min(adv.maxHp, adv.hp + potion.amount);
    } else if (potion.restore === 'mp') {
        adv.mp = Math.min(adv.maxMp, adv.mp + potion.amount);
    }

    gameState.inventory.splice(idx, 1);
    renderCurrentCharacter();
}

function receiveSideQuest(idx) {
    const existing = gameState.quests.find(q => q.side && q.npcIdx === idx);
    if (existing) {
        alert('このNPCのサイドクエストは既に受注中です。');
        return;
    }
    const sq = generateSideQuest(idx);
    gameState.quests.push(sq);
    updateDisplays();
    alert(`${discoveryNPCs[idx]}からサイドクエストを受注しました！`);
}

function getNameHtml(adv) {
    if (!adv || adv.primary === undefined) return adv.name;
    const colors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00'];
    const color = colors[adv.primary];
    return `<span style="color:${color}; font-weight:bold;">${adv.name}</span>`;
}


function useExpOrbOnChar(charIndex, itemId) {
    const perms = gameState.adventurers.filter(a => !a.temp);
    const adv = perms[charIndex];
    if (!adv) return;

    const itemIdx = gameState.inventory.findIndex(it => it.id === itemId && it.name === 'EXPオーブ');
    if (itemIdx === -1) return;

    const orb = gameState.inventory[itemIdx];
    const levelsToAdd = orb.amount || 10;

    // EXP無視で直接レベルアップ（ステータス成長・HP/MP最大値増加・フルヒール）
    levelUp(adv, levelsToAdd);

    // オーブ消費（スタック対応）
    if ((orb.qty || 1) > 1) {
        orb.qty -= 1;
    } else {
        gameState.inventory.splice(itemIdx, 1);
    }

    alert(`${adv.name} がEXPオーブを使用！レベルが${levelsToAdd}アップしました！`);

    renderCurrentCharacter();  // 即時反映
    updateDisplays();
}

function renderCurrentCharacter() {
    const perms = gameState.adventurers.filter(a => !a.temp);
    if (perms.length === 0) {
        document.getElementById('charactersContent').innerHTML = '<p>恒久的な冒険者がいません。</p>';
        return;
    }
    if (currentCharIndex >= perms.length || currentCharIndex < 0) currentCharIndex = 0;
    const adv = perms[currentCharIndex];
    const eff = {
        strength: getEffectiveStat(adv, 'strength'),
        wisdom: getEffectiveStat(adv, 'wisdom'),
        dexterity: getEffectiveStat(adv, 'dexterity'),
        luck: getEffectiveStat(adv, 'luck')
    };
    const expNeeded = adv.level * 100;
    const expPct = Math.min(100, (adv.exp / expNeeded) * 100 || 0);
    const hpPct = (adv.hp / adv.maxHp) * 100 || 0;
    const mpPct = (adv.mp / adv.maxMp) * 100 || 0;

    let html = `<div class="char-nav" style="margin-bottom:20px;">
        <button onclick="prevChar()">‹ 前</button>
        <span>${currentCharIndex + 1} / ${perms.length}</span>
        <button onclick="nextChar()">次 ›</button>
    </div>`;

    // メインコンテンツ：flexで左右配置
    html += `<div style="display:flex; align-items:flex-start; justify-content:center; gap:40px; flex-wrap:wrap;">`;

    // 左側：名前・ステータス・バー・バフ・装備・アイテム・ボタン
    html += `<div style="flex:1; min-width:300px; max-width:500px;">`;

    html += `<h3 style="margin:0 0 15px 0; text-align:center;">${getNameHtml(adv)} Lv ${adv.level}</h3>`;

    html += `<p style="margin:10px 0;"><strong>ステータス（装備・バフ込み）</strong></p><ul style="margin:0; padding-left:20px;">`;
    html += `<li>筋力: ${eff.strength} (ベース ${adv.strength})</li>`;
    html += `<li>知恵: ${eff.wisdom} (ベース ${adv.wisdom})</li>`;
    html += `<li>敏捷: ${eff.dexterity} (ベース ${adv.dexterity})</li>`;
    html += `<li>運: ${eff.luck} (ベース ${adv.luck})</li>`;
    html += `</ul>`;

    html += `<div style="margin:15px 0;">
                <div class="progress-bar"><div class="progress-fill exp-fill" style="width:${expPct}%"></div></div>
                EXP ${adv.exp}/${expNeeded}<br>
                <div class="progress-bar"><div class="progress-fill hp-fill" style="width:${hpPct}%"></div></div>
                HP ${adv.hp}/${adv.maxHp}<br>
                <div class="progress-bar"><div class="progress-fill mp-fill" style="width:${mpPct}%"></div></div>
                MP ${adv.mp}/${adv.maxMp}
             </div>`;

    if (adv.buffs && adv.buffs.length > 0) {
        html += `<p style="margin:10px 0;"><strong>アクティブバフ</strong></p><ul style="margin:0; padding-left:20px;">`;
        adv.buffs.forEach(b => {
            const bonus = b.percent ? `${b.bonus}%` : `+${b.bonus}`;
            const target = b.stat ? statFull[b.stat] : b.type;
            html += `<li>${bonus} ${target}（残り${b.daysLeft}日）</li>`;
        });
        html += `</ul>`;
    }

    html += `<p style="margin:15px 0 10px;"><strong>装備（最大2）</strong></p><ul style="margin:0; padding-left:20px;">`;
    if (adv.equipment.length === 0) html += `<li>なし</li>`;
    adv.equipment.forEach((eq, i) => {
        html += `<li>${eq.name} (+${eq.bonus} ${statFull[eq.stat]})
                 <button class="cancel-btn" onclick="removeFromChar(${currentCharIndex}, ${i})">解除</button></li>`;
    });
    html += `</ul>`;

    const equippable = gameState.inventory.filter(it => it.stat && adv.equipment.length < 2 && (it.qty || 1) > 0);
    if (equippable.length > 0) {
        html += `<p style="margin:15px 0 10px;"><strong>装備可能アイテム</strong></p><ul style="margin:0; padding-left:20px;">`;
        equippable.forEach(it => {
            html += `<li>${it.name} x${it.qty || 1} (+${it.bonus} ${statFull[it.stat]}) 
                     <button onclick="equipToChar(${currentCharIndex}, ${it.id})">装備</button></li>`;
        });
        html += `</ul>`;
    }

    const potions = gameState.inventory.filter(it => it.type === 'potion' && (it.qty || 1) > 0);
    if (potions.length > 0) {
        html += `<p style="margin:15px 0 10px;"><strong>ポーション</strong></p><ul style="margin:0; padding-left:20px;">`;
        potions.forEach(it => {
            const target = it.restore === 'hp' ? `HP +${it.amount}` : `MP +${it.amount}`;
            const safeName = it.name.replace(/'/g, "\\'");
            html += `<li>${it.name} x${it.qty || 1} (${target}) 
                     <button onclick="usePotionOnChar(${currentCharIndex}, '${safeName}')">使用</button></li>`;
        });
        html += `</ul>`;
    }

    // 新規追加: EXPオーブ（レベルアップアイテム）専用セクション
    const expOrbs = gameState.inventory.filter(it => it.name === 'EXPオーブ' && (it.qty || 1) > 0);
    if (expOrbs.length > 0) {
        html += `<p style="margin:15px 0 10px;"><strong>レベルアップアイテム</strong></p><ul style="margin:0; padding-left:20px;">`;
        expOrbs.forEach(it => {
            html += `<li>${it.name} x${it.qty || 1} (使用でレベル+10) 
                     <button onclick="useExpOrbOnChar(${currentCharIndex}, ${it.id})">使用</button></li>`;
        });
        html += `</ul>`;
    }

    // 既存のバフ消費アイテムはそのまま（EXPオーブとは別）
    const consumables = gameState.inventory.filter(it => it.type === 'consumable' && it.name !== 'EXPオーブ');
    if (consumables.length > 0) {
        html += `<p style="margin:15px 0 10px;"><strong>消費アイテム（バフ）</strong></p><ul style="margin:0; padding-left:20px;">`;
        consumables.forEach(it => {
            const bonus = it.buff.percent ? `${it.buff.bonus}%` : `+${it.buff.bonus}`;
            const target = it.buff.stat ? statFull[it.buff.stat] : it.buff.type;
            html += `<li>${it.name} (${bonus} ${target} ${it.buff.days}日)
                     <button onclick="useConsumable(${currentCharIndex}, ${it.id})">使用</button></li>`;
        });
        html += `</ul>`;
    }

    html += `<hr style="margin:20px 0;">`;
    if (adv.busy) {
        html += `<p style="color:red; text-align:center;">クエスト中 - 解雇不可</p>`;
    } else {
        html += `<div style="text-align:center;">
                    <button style="background:#e74c3c; color:white; padding:10px 20px; border:none; border-radius:4px; cursor:pointer;"
                            onclick="firePerm(${currentCharIndex})">この冒険者を解雇</button>
                 </div>`;
    }

    html += `</div>`; // 左側閉じ

    // 右側：画像（大きめ表示）
    html += `<div style="flex:0 0 auto; text-align:center;">`;
    html += `<img src="${adv.image}" 
                 style="width:220px; height:auto; max-height:400px; object-fit:contain; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.2);"
                 onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMjAiIGhlaWdodD0iNDAwIiB2aWV3Qm94PSIwIDAgMjIwIDQwMCI+PHJlY3Qgd2lkdGg9IjIyMCIgaGVpZ2h0PSI0MDAiIGZpbGw9IiM3NDc0NzQiLz48dGV4dCB4PSIxMTAiIHk9IjIwMCIgZm9udC1zaXplPSIzMCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPuOCpuODiOOBpzwvdGV4dD48L3N2Zz4=';">`;
    html += `</div>`;

    html += `</div>`; // flexコンテナ閉じ

    document.getElementById('charactersContent').innerHTML = html;
}


function getDisplayableQuests() {
    // 完了していないクエストを表示（プレイヤー投稿のメイン/ダンジョンなどは daysLeft:999 なので常に表示）
    return gameState.quests.filter(q => !q.completed);
}

function renderQuests() {
    const quests = getDisplayableQuests(); // !q.completed のクエスト
    const container = document.getElementById('quests');
    const counter = document.getElementById('questCounter');

    if (quests.length === 0) {
        container.innerHTML = '<p style="text-align:center; color:#ffffff; padding:60px; font-size:1.4em;">利用可能なクエストはありません。</p>';
        counter.textContent = '';
        return;
    }

    // インデックスを範囲内に収める
    if (currentQuestIndex >= quests.length) currentQuestIndex = 0;
    if (currentQuestIndex < 0) currentQuestIndex = quests.length - 1;

    const q = quests[currentQuestIndex];
    counter.textContent = `${currentQuestIndex + 1} / ${quests.length}`;

    // タイプクラス設定
    let typeClass = questTypeClasses[q.type] || '';
    if (q.side) typeClass += ' side';
    if (q.training) typeClass = 'training';
    if (q.playerPosted) {
        if (q.type === 6) typeClass = 'main';
        else if (q.type === 7) typeClass = 'dungeon';
        else if (q.type === 8) typeClass = 'trade';
    }

    // チーム有効ステータス合計
    const teamStr = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'strength'), 0);
    const teamWis = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'wisdom'), 0);
    const teamDex = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'dexterity'), 0);
    const teamLuk = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), 'luck'), 0);

    // 予想日数・成功確率計算
    let estDays = 'N/A';
    let chance = 0;
    const maxSlots = q.training ? 2 : 4;

    if (q.assigned.length > 0) {
        if (q.training) {
            estDays = '1日';
            chance = 100;
        } else if (q.defense) {
            estDays = 'Today: Battle';
            chance = 'Tactical Combat';
        } else if (q.type === 8) { // trade
            const meetsAll = teamDex >= q.minDexterity && teamLuk >= q.minLuck;
            if (!meetsAll) {
                estDays = '失敗 (DEX/LUC不足)';
                chance = 0;
            } else {
                let days;
                if (q.inProgress && q.tradeRemainingDays !== undefined && q.tradeRemainingDays > 0) {
                    days = q.tradeRemainingDays;
                    estDays = `${days}日残り (確定成功)`;
                } else {
                    const avgDex = teamDex / q.assigned.length || 1;
                    const avgLuc = teamLuk / q.assigned.length || 1;
                    days = calcTradeRequiredDays(avgDex, avgLuc);
                    estDays = q.inProgress ? `${days}日残り (確定成功)` : `${days}日 (確定成功)`;
                }
                chance = 100;
            }
        } else { // 通常クエスト
            const meetsAll = teamStr >= q.minStrength && teamWis >= q.minWisdom && 
                            teamDex >= q.minDexterity && teamLuk >= q.minLuck;
            if (!meetsAll) {
                estDays = '失敗';
                chance = 0;
            } else {
                let teamFocus = q.assigned.reduce((s, id) => s + getEffectiveStat(findAdv(id), q.focusStat), 0);
                const excess = (teamFocus / q.minFocus) - 1;
                const prob = Math.min(0.5, 0.1 + Math.max(0, excess) * 0.2);
                chance = Math.round(prob * 100);
                estDays = Math.max(1, Math.ceil(1 / prob));
            }
        }
    }

    // 割り当て済み冒険者HTML
    let assignedHtml = '';
    q.assigned.forEach(id => {
        const a = findAdv(id);
        if (a) {
            const nameHtml = getNameHtml(a);
            if (q.inProgress) {
                assignedHtml += `<span class="assigned-adventurer"><img src="${a.image}" class="adventurer-img">${nameHtml}</span>`;
            } else {
                assignedHtml += `<span class="assigned-adventurer"><img src="${a.image}" class="adventurer-img">${nameHtml} <button class="cancel-btn" onclick="unassign(${q.id}, ${id})">X</button></span>`;
            }
        }
    });

    // 必要ステータスHTML（アイコン付き）
    const minHtml = `<img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${q.minStrength || 0} | 
                     <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${q.minWisdom || 0} | 
                     <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${q.minDexterity || 0} | 
                     <img src="LUC.png" class="stat-icon" title="運"> 運 ${q.minLuck || 0}`;

    const teamHtml = `<img src="STR.png" class="stat-icon" title="筋力"> 筋力 ${teamStr} | 
                      <img src="WIS.png" class="stat-icon" title="知恵"> 知恵 ${teamWis} | 
                      <img src="DEX.png" class="stat-icon" title="敏捷"> 敏捷 ${teamDex} | 
                      <img src="LUC.png" class="stat-icon" title="運"> 運 ${teamLuk}`;

    // メインHTML構築
    let html = `
        <div class="quest-card ${typeClass}" 
             data-quest-id="${q.id}"
             ondrop="drop(event)" 
             ondragover="allowDrop(event)" 
             ondragleave="dragLeave(event)">
            <h3>${q.desc}</h3>`;

    if (q.training) {
        html += `<p><strong>常時利用可能なトレーニングクエスト（最大2人）</strong></p>`;
        html += `<p>低いレベルの冒険者はペアの高いレベル相当のEXPを獲得。リスクなし、報酬なし。</p>`;
        html += `<p>難易度: ${q.difficulty} | 必要ステータス: 全て0</p>`;
    } else {
        html += `<p>難易度: ${q.difficulty} (${q.rank}) | 残り日数: ${q.daysLeft} | 報酬: ${q.reward}g</p>`;
        if (q.defense) {
            html += `<p><strong style="color:red;">防衛クエスト - 1-4人の防衛者を割り当てなければゲームオーバー！</strong></p>`;
        }
        if (!q.defense && !q.playerPosted) {
            html += `<p>必要: ${minHtml}</p>`;
        }
    }

    html += `<p>予想日数: ${estDays}</p>
             <p>チーム: ${teamHtml} | 成功確率: ${chance}${chance === 'Tactical Combat' ? '' : '%'} </p>
             <div style="margin-top:15px;">割り当て済み (${q.assigned.length}/${maxSlots}): 
                 ${assignedHtml || '<span style="color:#aaa;">未割り当て</span>'}
             </div>`;

    // 拒否ボタン（条件一致時のみ）
    if (q.assigned.length === 0 && !q.inProgress && !q.defense && !q.training && !q.playerPosted) {
        const rejectPenalty = (0.1 * q.difficulty).toFixed(1);
        html += `<p style="margin-top:15px;">
                    <button onclick="rejectQuest(${q.id})" 
                            style="background:#e74c3c; color:white; border:none; padding:6px 12px; border-radius:6px; cursor:pointer;">
                        クエスト拒否 (評判 -${rejectPenalty})
                    </button>
                 </p>`;
    }

    if (q.inProgress) {
        html += `<p class="in-progress" style="margin-top:15px;">進行中 - 冒険者の割り当て解除不可</p>`;
    }

    html += `</div>`; // .quest-card 閉じ

    container.innerHTML = html;
}

function prevQuest() {
    const quests = getDisplayableQuests();
    if (quests.length <= 1) return;
    currentQuestIndex--;
    if (currentQuestIndex < 0) currentQuestIndex = quests.length - 1;
    renderQuests();
}

function nextQuest() {
    const quests = getDisplayableQuests();
    if (quests.length <= 1) return;
    currentQuestIndex++;
    if (currentQuestIndex >= quests.length) currentQuestIndex = 0;
    renderQuests();
}

function renderCurrentNPC() {
    const discoveredIndices = gameState.discoveredNPCs;
    const content = document.getElementById('npcsContent');
    if (discoveredIndices.length === 0) {
        content.innerHTML = '<div style="text-align:center; padding:40px; color:#6c757d;"><h3>発見したNPC</h3><p style="font-size:1.2em;">まだNPCを発見していません。<br>発見クエストを成功させてください。</p></div>';
        return;
    }
    const idx = discoveredIndices[currentNPCIndex];
    const name = discoveryNPCs[idx];
    let html = '<div style="max-width:500px; margin:0 auto; padding:40px; text-align:center;">';
    html += `<img src="Images/${name}.jpg" alt="${name}" class="npc-img" onerror="this.src=\'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNDAiIGhlaWdodD0iMTgwIiB2aWV3Qm94PSIwIDAgMTQwIDE4MCI+PHJlY3Qgd2lkdGg9IjE0MCIgaGVpZ2h0PSIxODAiIGZpbGw9IiM3NDc0NzQiLz48dGV4dCB4PSI3MCIgeT0iOTAiIGZvbnQtc2l6ZT0iMjAiIGZpbGw9IiNmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj7nlLvlg4/jgarjgZc8L3RleHQ+PC9zdmc+\'; this.onerror=null;">`;
    html += `<h2 style="color:#2c3e50; margin:20px 0 10px;">${name}</h2>`;
    html += '<div style="background:#f8f9fa; padding:20px; border-radius:12px; margin:20px 0; font-size:1.1em; color:#495057;">';
    html += '<p>発見済みNPC</p>';
    html += '<div class="char-nav">';
    html += `<button onclick="prevNPC()" style="padding:10px 20px;">前</button>`;
    html += `<span style="font-size:1.2em; margin:0 20px;">${currentNPCIndex + 1} / ${discoveredIndices.length}</span>`;
    html += `<button onclick="nextNPC()" style="padding:10px 20px;">次</button>`;
    html += '</div>';
    html += '</div>';
    html += '<div>';
    html += `<button onclick="receiveSideQuest(${idx})" style="background:#27ae60; color:white; padding:15px 30px; font-size:1.2em; border:none; border-radius:8px; cursor:pointer;">サイドクエスト受注</button>`;
    html += '</div>';
    html += '</div>';

    content.innerHTML = html;
}

function prevNPC() {
    const len = gameState.discoveredNPCs.length;
    if (len === 0) return;
    currentNPCIndex = (currentNPCIndex - 1 + len) % len;
    renderCurrentNPC();
}

function nextNPC() {
    const len = gameState.discoveredNPCs.length;
    if (len === 0) return;
    currentNPCIndex = (currentNPCIndex + 1) % len;
    renderCurrentNPC();
}

function prevChar() {
    const perms = gameState.adventurers.filter(a => !a.temp);
    if (perms.length === 0) return;
    currentCharIndex = (currentCharIndex - 1 + perms.length) % perms.length;
    renderCurrentCharacter();
}

function nextChar() {
    const perms = gameState.adventurers.filter(a => !a.temp);
    if (perms.length === 0) return;
    currentCharIndex = (currentCharIndex + 1) % perms.length;
    renderCurrentCharacter();
}

function dragLeave(e){
    if(e.currentTarget.classList.contains('quest-card')){
        e.currentTarget.classList.remove('drag-over');
    }
}

function allowDrop(e) {
    e.preventDefault();
    if (e.currentTarget.classList.contains('quest-card')) {
        e.currentTarget.classList.add('drag-over');
    }
}

function dragLeave(e) {
    if (e.currentTarget.classList.contains('quest-card')) {
        e.currentTarget.classList.remove('drag-over');
    }
}

function drop(e) {
    e.preventDefault();
    if (e.currentTarget.classList.contains('quest-card')) {
        e.currentTarget.classList.remove('drag-over');
        const questId = parseInt(e.currentTarget.dataset.questId);
        if (draggedAdvId !== null && questId !== undefined) {
            assign(questId, parseInt(draggedAdvId));
        }
        draggedAdvId = null;
    }
}

document.addEventListener('dragstart', e => {
    const card = e.target.closest('.adventurer-card');
    if (card) {
        draggedAdvId = card.dataset.advId;
        card.classList.add('dragging');
        // Optional: for better browser compatibility
        e.dataTransfer.setData('text/plain', draggedAdvId);
    }
});

// 新規追加：BGMクロスフェード共通関数（再利用可能）
function crossfadeTo(newBgmId, duration = 2000) {
    const newBgm = document.getElementById(newBgmId);
    const currentBgms = [
        document.getElementById('bgm'),
        document.getElementById('introBgm'),
        document.getElementById('battleBgm')
    ].filter(b => b !== newBgm && !b.paused);

    // 現在再生中のBGMをすべてフェードアウト（複数対応安全策）
    // 新しいBGMをボリューム0で再生開始
    newBgm.currentTime = 0;
    newBgm.volume = 0;
    newBgm.play().catch(e => console.log('BGM再生エラー:', e));

    const targetVol = 0.3;
    const startTime = Date.now();

    const interval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // 現在鳴っているBGMをフェードアウト
        currentBgms.forEach(bgm => {
            bgm.volume = targetVol * (1 - progress);
        });

        // 新しいBGMをフェードイン
        newBgm.volume = targetVol * progress;

        if (progress >= 1) {
            clearInterval(interval);
            // 古いBGMを完全に停止・リセット
            currentBgms.forEach(bgm => {
                bgm.pause();
                bgm.currentTime = 0;
            });
            newBgm.volume = targetVol;
        }
    }, 50);
}

document.addEventListener('dragend', e => {
    const card = e.target.closest('.adventurer-card');
    if (card) {
        card.classList.remove('dragging');
    }
    draggedAdvId = null; // Reset on end
});

startDay();

document.getElementById('bgm').volume = 0.3;
document.getElementById('introBgm').volume = 0.3;  // ← 新規追加
document.getElementById('battleBgm').volume = 0.3;
let audioPlayed = false;
document.addEventListener('click', function() {
    if (!audioPlayed) {
        document.getElementById('bgm').play().catch(e => console.log('BGM再生エラー:', e));
        audioPlayed = true;
    }
}, { once: true });

// 横スクロール制御（利用可能冒険者） – 端近くで左クリック（ホールド）して3カードずつページングスクロール版
const scrollContainer = document.getElementById('availableAdvs');
let scrollInterval = null;
let scrollDirection = 0; // -1: 左, 1: 右, 0: 停止
const SCROLL_THRESHOLD = 100;    // 端からの感度範囲（px）
const PAGE_INTERVAL = 600;       // ホールド中の連続ページング間隔（ms） – 速めで快適（調整可能）
let stepAmount = 0;              // 動的に計算する3カード分のスクロール量

// カード幅 + gap を計算
function calculateStepAmount() {
    if (stepAmount > 0) return;

    const cards = scrollContainer.querySelectorAll('.adventurer-card');
    if (cards.length === 0) return;

    const card = cards[0];
    const cardWidth = card.offsetWidth;
    const style = getComputedStyle(scrollContainer);
    const gap = parseFloat(style.gap) || 0;

    stepAmount = cardWidth * 3 + gap * 2;
}

// ページングスクロール実行（1回）
function performPageScroll() {
    if (scrollDirection === 0 || stepAmount === 0) return;

    const currentLeft = scrollContainer.scrollLeft;
    const maxLeft = scrollContainer.scrollWidth - scrollContainer.clientWidth;

    let newLeft = currentLeft + (scrollDirection * stepAmount);

    if (newLeft < 0) {
        newLeft = 0;
        clearInterval(scrollInterval);
        scrollInterval = null;
        scrollDirection = 0;
    } else if (newLeft > maxLeft) {
        newLeft = maxLeft;
        clearInterval(scrollInterval);
        scrollInterval = null;
        scrollDirection = 0;
    }

    scrollContainer.scrollTo({
        left: newLeft,
        behavior: 'smooth'
    });
}

// マウスダウン（左クリック）で方向判定・連続開始
scrollContainer.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return; // 左クリックのみ

    calculateStepAmount();

    const rect = scrollContainer.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const width = rect.width;

    let newDirection = 0;

    if (mouseX < SCROLL_THRESHOLD) {
        newDirection = -1;
    } else if (mouseX > width - SCROLL_THRESHOLD) {
        newDirection = 1;
    }

    if (newDirection !== 0) {
        e.preventDefault(); // ドラッグ選択防止

        if (scrollInterval) {
            clearInterval(scrollInterval);
        }
        scrollDirection = newDirection;

        // 即時1回移動
        performPageScroll();

        // ホールドで連続ページング
        scrollInterval = setInterval(performPageScroll, PAGE_INTERVAL);
    }
});

// マウスアップ・マウス離脱で停止
document.addEventListener('mouseup', () => {
    if (scrollInterval) {
        clearInterval(scrollInterval);
        scrollInterval = null;
    }
    scrollDirection = 0;
});

scrollContainer.addEventListener('mouseleave', () => {
    if (scrollInterval) {
        clearInterval(scrollInterval);
        scrollInterval = null;
    }
    scrollDirection = 0;
});

// コンテキストメニュー防止（右クリック対策）
scrollContainer.addEventListener('contextmenu', (e) => {
    e.preventDefault();
});

// ホイールスクロール（従来通り）
scrollContainer.addEventListener('wheel', (e) => {
    e.preventDefault();
    scrollContainer.scrollBy({
        left: e.deltaY * 4,
        behavior: 'smooth'
    });
});

// カーソルで操作を示唆
scrollContainer.style.cursor = 'grab'; // つかめる感じでヒント

// 導入対話を管理する変数
let playerName = "";
let dialogueIndex = 0;

const dialogues = [
    {
        speaker: "ナレーター",
        text: "……炎が空を赤く染めていた。あの夜、静かな村は突然の襲撃を受けた。<br>黒い鎧の軍勢——その正体も目的もわからないまま、すべてを焼き払い、奪い去っていった。"
    },
    {
        speaker: "ナレーター",
        text: "あなた、<strong>{player}</strong>は、幼なじみのカイトとルナと共に、必死に逃げ延びた。<br>家族も、家も、故郷も……すべてを失った。"
    },
    {
        speaker: "カイト",
        image: "Images/カイト.png",
        text: "……よう、{player}。まだ起きてたのか。<br>ルナもさっきまで泣いてたけど、今は寝ちまったみたいだな。"
    },
    {
        speaker: "カイト",
        image: "Images/カイト.png",
        text: "俺たち……本当にここまで来ちまったな。<br>あの村から逃げて、このセントラルシティまで……<br>家族も、友達も、みんな……"
    },
    {
        speaker: "あなた",
        text: "……ああ。でも、生きてる。俺たち三人だけでも。"
    },
    {
        speaker: "ルナ",
        image: "Images/ルナ.png",
        text: "……{player}、カイト……ごめん、起きちゃった。<br>夢を見たの。あの夜の夢……またみんなが……"
    },
    {
        speaker: "カイト",
        image: "Images/カイト.png",
        text: "ルナ……もう大丈夫だ。俺たちがいる。<br>でもよ、{player}。このままじゃダメだよな。<br>ただ逃げて、隠れて生きるだけじゃ……"
    },
    {
        speaker: "ルナ",
        image: "Images/ルナ.png",
        text: "うん……私も思う。あの軍勢の正体、なぜ村が狙われたのか……<br>知りたい。真実を知りたい。<br>そして、生きていくためにも……お金が必要よね。"
    },
    {
        speaker: "カイト",
        image: "Images/カイト.png",
        text: "残ってる金は1000gだけだ。<br>でもよ、{player}。俺たちには力がある。<br>お前とルナと俺——三人なら、冒険者としてやっていけるはずだ。"
    },
    {
        speaker: "ルナ",
        image: "Images/ルナ.png",
        text: "だから……ギルドを作ろう。ここに。<br>私たちのギルド。小さくてもいい。<br>依頼を受けて、強くなって、真実を探すための力をつけるの。"
    },
    {
        speaker: "カイト",
        image: "Images/カイト.png",
        text: "決まりだな、{player}。<br>俺たち三人で、この街に新しいギルドを立ち上げる。<br>名前は……お前が決めろよ。リーダーなんだから。"
    },
    {
        speaker: "ナレーター",
        text: "こうして、あなたたちは少ない所持金と、失われた故郷への想いを胸に——<br><strong>冒険者ギルド</strong>を設立した。<br><br>復讐と真実、そして新しい未来のために。"
    },
    {
        speaker: "ナレーター",
        text: "あなたたちの冒険が、今始まる……"
    }
];

// startIntroDialogue 関数を以下のように修正
function startIntroDialogue() {
    playerName = document.getElementById('playerNameInput').value.trim();
    if (playerName === "") {
        alert("名前を入力してください！");
        return;
    }
    
    document.getElementById('stepName').style.display = 'none';
    document.getElementById('stepDialogue').style.display = 'block';
    
    dialogueIndex = 0;
    renderCurrentDialogue();

    // ← ここから追加：イントロBGM再生
    const mainBgm = document.getElementById('bgm');
    const introBgm = document.getElementById('introBgm');

    // もしメインBGMが再生中だったら止める（ほぼありえないが念のため）
    if (!mainBgm.paused) {
        mainBgm.pause();
    }

    // イントロBGMを最初から再生
    introBgm.currentTime = 0;
    introBgm.play().catch(e => console.log('イントロBGM再生エラー:', e));
    // ← ここまで追加
}

// renderCurrentDialogue 関数内の「ゲーム開始」ボタンの処理を以下のように修正
function renderCurrentDialogue() {
    const box = document.getElementById('dialogueBox');
    let current = dialogues[dialogueIndex];
    
    let text = current.text.replace(/{player}/g, playerName);
    
    let html = `<p><strong>${current.speaker}:</strong><br>${text}</p>`;
    
    if (current.image) {
        html = `<img src="${current.image}" style="width:120px; height:auto; float:left; margin-right:20px; border-radius:10px;">` + html;
    }
    
    box.innerHTML = html;
    
// renderCurrentDialogue 内の「ゲーム開始」ボタン処理を以下に置き換え
if (dialogueIndex === dialogues.length - 1) {
    document.getElementById('nextBtn').textContent = "ゲーム開始";
    document.getElementById('nextBtn').onclick = function() {
        document.getElementById('introModal').style.display = 'none';

        // === クロスフェード処理（急なBGM切り替えを防止）===
        const introBgm = document.getElementById('introBgm');
        const mainBgm = document.getElementById('bgm');

        // メインBGMを巻き戻してボリューム0で再生開始
        mainBgm.currentTime = 0;
        mainBgm.volume = 0;
        mainBgm.play().catch(e => console.log('メインBGM再生エラー:', e));

        const fadeDuration = 2500;  // 2.5秒でクロスフェード（調整可能）
        const introInitialVol = introBgm.volume;  // 通常0.3
        const targetVol = 0.3;
        const startTime = Date.now();

        const crossfadeInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / fadeDuration, 1);

            // イントロをフェードアウト
            introBgm.volume = introInitialVol * (1 - progress);

            // メインをフェードイン
            mainBgm.volume = targetVol * progress;

            if (progress >= 1) {
                clearInterval(crossfadeInterval);
                // フェード完了後、イントロを停止・リセット
                introBgm.pause();
                introBgm.currentTime = 0;
                // メインはフルボリュームでループ継続
                mainBgm.volume = targetVol;
            }
        }, 50);  // 50msごとに更新（滑らかで負荷も軽い）

        audioPlayed = true;

        // ゲーム本編開始
        startDay();
    };
} else {
    // それ以外は従来通り
    document.getElementById('nextBtn').textContent = "次へ";
    document.getElementById('nextBtn').onclick = nextDialogue;
}}

function nextDialogue() {
    dialogueIndex++;
    if (dialogueIndex < dialogues.length) {
        renderCurrentDialogue();
    }
}

// ゲームロード時に自動表示（例: ページ読み込み後やstartDay()の前に）
window.addEventListener('load', function() {
    if (gameState.day === 1) { // 初回起動判定
        document.getElementById('introModal').style.display = 'flex';
    }})

// クエスト完了ダイアログ表示関数
// introのダイアログシステム（introModal, stepDialogue, dialogueBox, nextBtn）を再利用
// 単一ダイアログのみ表示 → 依頼主の感謝セリフとしてスタイル統一
// 画像はなし、speakerは「依頼主」で固定（Fランクはすべて村人/町の人系の依頼主なので自然）
// プレイヤー名置換は不要（完了ダイアログに{player}は入っていない）


let typingInterval = null;  // タイピング間隔のクリア用
let isTyping = false;       // タイピング中フラグ

let completionQueue = [];     // 完了ダイアログのキュー（複数同時完了対応）
let isPlayingDialogue = false; // 現在ダイアログ再生中フラグ

function queueQuestCompletionDialogue(sequence) {
    if (!sequence || sequence.length === 0) return;

    completionQueue.push(sequence);

    // 再生中でなければ即開始
    if (!isPlayingDialogue) {
        playNextDialogue();
    }
}

function playNextDialogue() {
    if (completionQueue.length === 0) {
        isPlayingDialogue = false;
        return;
    }

    isPlayingDialogue = true;
    const sequence = completionQueue.shift();

    // 単一ダイアログ再生（すべてローカル変数化で競合防止）
    (function displaySingleDialogue(seq) {
        // 既存モーダル削除（安全策）
        const existing = document.getElementById('questCompletionModal');
        if (existing) existing.remove();

        const modal = document.createElement('div');
        modal.id = 'questCompletionModal';
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        modal.style.display = 'flex';
        modal.style.justifyContent = 'center';
        modal.style.alignItems = 'center';
        modal.style.zIndex = '1000';

        const content = document.createElement('div');
        content.style.backgroundColor = '#747474df';
        content.style.padding = '30px';
        content.style.borderRadius = '15px';
        content.style.maxWidth = '900px';
        content.style.width = '90%';
        content.style.boxShadow = '0 10px 30px rgba(0,0,0,0.5)';
        content.style.display = 'flex';
        content.style.alignItems = 'flex-start';
        content.style.gap = '40px';
        content.style.fontFamily = '"Segoe UI", Arial, sans-serif';

        // === キャラ画像（話者に応じて切り替え、デフォルトはペア画像）===
        const charImage = document.createElement('img');
        charImage.style.width = '220px';
        charImage.style.height = 'auto';
        charImage.style.maxHeight = '400px';
        charImage.style.objectFit = 'contain';
        charImage.style.borderRadius = '12px';
        charImage.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
        charImage.style.alignSelf = 'flex-start';
        charImage.onerror = function() { this.style.display = 'none'; };

        // === テキスト＋ボタンのコンテナ（右側）===
        const textContainer = document.createElement('div');
        textContainer.style.flex = '1';
        textContainer.style.display = 'flex';
        textContainer.style.flexDirection = 'column';
        textContainer.style.justifyContent = 'space-between';
        textContainer.style.minHeight = '200px';

        const dialogueBox = document.createElement('div');
        dialogueBox.id = 'questDialogueBox';
        dialogueBox.style.minHeight = '150px';
        dialogueBox.style.marginBottom = '30px';
        dialogueBox.style.fontSize = '1.2em';
        dialogueBox.style.lineHeight = '1.6';

        const nextBtn = document.createElement('button');
        nextBtn.textContent = '次へ';
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.6';
        nextBtn.style.padding = '12px 30px';
        nextBtn.style.fontSize = '1.2em';
        nextBtn.style.backgroundColor = '#e94560';
        nextBtn.style.color = 'white';
        nextBtn.style.border = 'none';
        nextBtn.style.borderRadius = '8px';
        nextBtn.style.cursor = 'pointer';
        nextBtn.style.alignSelf = 'center';

        textContainer.appendChild(dialogueBox);
        textContainer.appendChild(nextBtn);

        content.appendChild(charImage);
        content.appendChild(textContainer);
        modal.appendChild(content);
        document.body.appendChild(modal);

        // すべてローカル変数
        let localIndex = 0;
        let localTyping = false;
        let localInterval = null;

        function typeText(targetText, speaker) {
            localTyping = true;
            nextBtn.disabled = true;
            nextBtn.style.opacity = '0.6';

            dialogueBox.innerHTML = `<p><strong>${speaker}:</strong><br><span id="typingText"></span></p>`;
            const typingText = document.getElementById('typingText');

            let i = 0;
            localInterval = setInterval(() => {
                if (i < targetText.length) {
                    typingText.innerHTML += targetText.charAt(i);
                    i++;
                } else {
                    clearInterval(localInterval);
                    localTyping = false;
                    nextBtn.disabled = false;
                    nextBtn.style.opacity = '1';

                    if (localIndex === seq.length - 1) {
                        nextBtn.textContent = '閉じる';
                    } else {
                        nextBtn.textContent = '次へ';
                    }
                }
            }, 30);
        }

        function renderCurrent() {
            const current = seq[localIndex];
            let imageSrc = 'Images/main_char.png'; 
            if (current.speaker === '冒険者') {
                const images = [
                    'STR_M.png',
                    'STR_F.png',

                    'WIS_F.png',
                    'DEX_M.png',
                    'DEX_F.png',
                    'LUC_M.png',
                    'LUC_F.png'
                ];
                
                const randomIndex = Math.floor(Math.random() * images.length);
                imageSrc = images[randomIndex];
            }     
            if (current.speaker === 'カイト') {
                imageSrc = 'Images/カイト.png';
            } else if (current.speaker === 'ルナ') {
                imageSrc = 'Images/ルナ.png';
            }
            // それ以外の話者（冒険者、依頼主、ギルドマスターなど）でもペア画像のままにする
            charImage.src = imageSrc;
            charImage.style.display = 'block'; // 常に表示

            typeText(current.text, current.speaker);
        }

        nextBtn.onclick = function() {
            if (localTyping) {
                clearInterval(localInterval);
                const current = seq[localIndex];
                dialogueBox.innerHTML = `<p><strong>${current.speaker}:</strong><br>${current.text}</p>`;
                localTyping = false;
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';

                if (localIndex === seq.length - 1) {
                    nextBtn.textContent = '閉じる';
                } else {
                    nextBtn.textContent = '次へ';
                }
            } else {
                localIndex++;
                if (localIndex < seq.length) {
                    renderCurrent();
                } else {
                    modal.remove();
                    playNextDialogue();
                }
            }
        };

        modal.onclick = function(e) {
            if (e.target === modal) {
                if (localInterval) clearInterval(localInterval);
                modal.remove();
                playNextDialogue();
            }
        };

        renderCurrent();
    })(sequence);
}